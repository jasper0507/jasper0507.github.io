{"posts":[{"title":"Markdown快速上手语法","text":"你希望优化这份 Markdown 教程，核心要求是每个操作先展示可复制的 Markdown 源代码，再展示对应的预览效果，这样能让学习者更直观地对照学习、快速上手。我保持了你原来的整体框架，只优化了每个知识点的展示形式，同时规范了部分格式层级，让教程更清晰易懂。 一、基本语法1. 引用Markdown 源代码1234&gt; 这就是引用！&gt; 这是引用的第二行（换行无需额外操作，直接续写即可）&gt;&gt; 空一行（在引用语法内空行），可以实现引用内的段落分隔 预览效果 这就是引用！这是引用的第二行（换行无需额外操作，直接续写即可） 空一行（在引用语法内空行），可以实现引用内的段落分隔 2. 列表列表分为「无序列表」、「有序列表」、「嵌套列表」，以下分别展示： 2.1 无序列表Markdown 源代码123456789无序列表支持三种标记（+、-、*），效果一致+ 无序列表项 1（+ 标记）+ 无序列表项 2（+ 标记）- 无序列表项 1（- 标记）- 无序列表项 2（- 标记）* 无序列表项 1（* 标记）* 无序列表项 2（* 标记） 预览效果无序列表支持三种标记（+、-、*），效果一致 无序列表项 1（+ 标记） 无序列表项 2（+ 标记） 无序列表项 1（- 标记） 无序列表项 2（- 标记） 无序列表项 1（* 标记） 无序列表项 2（* 标记） 2.2 有序列表Markdown 源代码12341. 有序列表项 12. 有序列表项 23. 有序列表项 3（注：数字仅起标记作用，即使写成 1. 3. 2.，预览仍会按顺序排列） 预览效果 有序列表项 1 有序列表项 2 有序列表项 3（注：数字仅起标记作用，即使写成 1. 3. 2.，预览仍会按顺序排列） 2.3 嵌套列表Markdown 源代码1234567# 嵌套规则：子列表前空 4 个空格（或 1 个制表符）1. 一级有序列表项 1. 二级有序列表项 1. 三级有序列表项2. 另一级一级有序列表项 - 二级无序列表项（+/-/* 均可） + 三级无序列表项 预览效果嵌套规则：子列表前空 4 个空格（或 1 个制表符） 一级有序列表项 二级有序列表项 三级有序列表项 另一级一级有序列表项 二级无序列表项（+/-/* 均可） 三级无序列表项 3. TodoList（任务清单）Markdown 源代码1234- [ ] 未完成任务 a- [x] 已完成任务 b- [ ] 未完成任务 c（注：[ ] 内的空格不可省略，已完成用 [x]（小写x/大写X均可）） 预览效果 未完成任务 a 已完成任务 b 未完成任务 c（注：[ ] 内的空格不可省略，已完成用 [x]（小写x/大写X均可）） 4. 表格Markdown 源代码123456# 表格语法：表头与内容用 | 分隔，对齐方式写在第二行| 左对齐 | 中对齐 | 右对齐 ||:--- |:---: |---: || 内容1 | 内容2 | 内容3 || 下面 | 接着 | 写 |（注：第二行的 - 数量至少 3 个，| 可省略首尾，对齐标记（:）控制对齐方向） 预览效果表格语法：表头与内容用 | 分隔，对齐方式写在第二行 左对齐 中对齐 右对齐 内容1 内容2 内容3 下面 接着 写 （注：第二行的 - 数量至少 3 个， 可省略首尾，对齐标记（:）控制对齐方向） 5. 段落相关格式5.1 换行Markdown 源代码1234567# 方式1：行尾加 2 个及以上空格 + 回车第一行（行尾有2个空格） 第二行# 方式2：两行之间空一行（更推荐，可读性更强）第一行第二行 预览效果方式1：行尾加 2 个及以上空格 + 回车第一行（行尾有2个空格）第二行方式2：两行之间空一行（更推荐，可读性更强）第一行 第二行 5.2 分割线Markdown 源代码1234# 三种常用语法（效果一致，推荐用 --- 或 ***）---***___（下划线，需切换英文输入法） 预览效果三种常用语法（效果一致，推荐用 — 或 ***） 5.3 字体样式Markdown 源代码1234567891011121314151617# 先展示字体样式汇总表格| 字体效果 | Markdown 源代码 | 常用快捷键 ||----------|----------------|------------|| 斜体 | *斜体* 或 _斜体_ | Ctrl+I || 高亮 | ==高亮== | 无（部分编辑器支持） || 粗体 | **粗体** 或 __粗体__ | Ctrl+B || 斜粗体 | ***斜粗体*** 或 ___斜粗体___ | 无（组合快捷键） || 删除线 | ~~删除线~~ | 无（部分编辑器支持 Ctrl+Shift+S） || 下划线 | &lt;u&gt;下划线&lt;/u&gt; | 无（HTML 标签，Markdown 原生不支持） |# 单独展示每个字体效果的实际表现*斜体*==高亮==**粗体*****斜粗体***~~删除线~~&lt;u&gt;下划线&lt;/u&gt; 预览效果先展示字体样式汇总表格 字体效果 Markdown 源代码 常用快捷键 斜体 斜体 或 斜体 Ctrl+I 高亮 ==高亮== 无（部分编辑器支持） 粗体 粗体 或 粗体 Ctrl+B 斜粗体 斜粗体 或 斜粗体 无（组合快捷键） 删除线 删除线 无（部分编辑器支持 Ctrl+Shift+S） 下划线 下划线 无（HTML 标签，Markdown 原生不支持） 单独展示每个字体效果的实际表现斜体==高亮==粗体斜粗体删除线下划线 5.4 脚注Markdown 源代码1234这是一段话[^1]，这里还有一个脚注引用[^2]。[^1]: 这是脚注 1 的具体内容（可以放在文档任意位置，推荐放在文档末尾）[^2]: 这是脚注 2 的具体内容，支持换行和简单格式**（粗体）** 预览效果这是一段话[^1]，这里还有一个脚注引用[^2]。 [^1]: 这是脚注 1 的具体内容（可以放在文档任意位置，推荐放在文档末尾）[^2]: 这是脚注 2 的具体内容，支持换行和简单格式**（粗体）** 6. 代码代码分为「行内代码」和「代码块」，以下分别展示： 6.1 行内代码Markdown 源代码12行内代码用于标注少量代码，语法：`代码内容`，例如：我在 C++ 中常用 `#include &lt;iostream&gt;` 引入输入输出流库 预览效果行内代码用于标注少量代码，语法：代码内容，例如：我在 C++ 中常用 #include &lt;iostream&gt; 引入输入输出流库 6.2 代码块（带语言高亮）Markdown 源代码123456789# 语法：```+编程语言名称 + 回车 + 代码内容 + 回车 + ``````cpp#include &lt;iostream&gt;using namespace std;int main() { cout &lt;&lt; &quot;Hello Markdown!&quot; &lt;&lt; endl; return 0;} 123456789101112#### 预览效果语法：` ```+编程语言名称 + 回车 + 代码内容 + 回车 + ``` ````c++#include &lt;iostream&gt;using namespace std;int main() { cout &lt;&lt; &quot;Hello Markdown!&quot; &lt;&lt; endl; return 0;} 7. 超链接超链接分为「行内式」和「参考式」，以下分别展示： 7.1 行内式超链接Markdown 源代码12# 语法：[链接显示文本](链接地址 &quot;可选：鼠标悬浮提示文本&quot;)这是一个[B站教程链接](https://www.bilibili.com/video/BV1bK4y1i7BY?vd_source=fe146844c3a7d03bc7a83fe89415755d &quot;Markdown 教学视频&quot;) 预览效果语法：链接显示文本这是一个B站教程链接 7.2 参考式超链接（适合大量重复引用同一链接）Markdown 源代码12345# 步骤1：正文中引用参考标记请[点击链接][教程]查看详细内容，再次[引用同一链接][教程]。# 步骤2：定义参考标记（可放在文档任意位置，推荐末尾）[教程]: https://www.bilibili.com/video/BV1bK4y1i7BY?vd_source=fe146844c3a7d03bc7a83fe89415755d &quot;Markdown 教学视频&quot; 预览效果步骤1：正文中引用参考标记请[点击链接][教程]查看详细内容，再次[引用同一链接][教程]。 步骤2：定义参考标记（可放在文档任意位置，推荐末尾）[教程]: https://www.bilibili.com/video/BV1bK4y1i7BY?vd_source=fe146844c3a7d03bc7a83fe89415755d “Markdown 教学视频” 8. 图片Markdown 源代码1234# 基础语法：![图片描述](图片地址 &quot;可选：鼠标悬浮提示文本&quot;)# 带超链接的图片：[![图片替代文本](图片地址)](超链接地址)利用[图床网站](https://imgse.com/)上传图片获取图片地址，示例：[![pV2YO4P.jpg](https://i-blog.csdnimg.cn/img_convert/7902d7710a54639d80e0bd1b2b26b375.jpeg)](https://imgse.com/i/pV2YO4P) 预览效果利用图床网站上传图片获取图片地址，示例： 二、其他操作（进阶）1. 行内显示公式Markdown 源代码12语法：$公式内容$（需编辑器支持 LaTeX 公式渲染）行内公式示例：$f(x)=ax+b$ 预览效果语法：$公式内容$（需编辑器支持 LaTeX 公式渲染）行内公式示例：$f(x)=ax+b$ 2. 块内显示公式（独立公式块）Markdown 源代码1234567语法：$$ + 回车 + 公式内容 + 回车 + $$$$\\begin{Bmatrix}a &amp; b\\\\c &amp; d\\end{Bmatrix}$$ 预览效果语法：$$ + 回车 + 公式内容 + 回车 + $$$$\\begin{Bmatrix}a &amp; b\\c &amp; d\\end{Bmatrix}$$","link":"/2026/01/23/Markdown%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E8%AF%AD%E6%B3%95/"},{"title":"git新手入门参考","text":"Git 零基础学习笔记目录 Git 安装配置详细教程 前置知识：Git常用Linux命令 Git 核心理论 Git 基础操作命令 Git 分支操作 参考资料 1. Git 安装与配置安装配置参考文档 Git 安装配置详细教程 2. 前置知识：Git常用Linux命令Git操作依赖Linux终端命令，以下是高频使用的命令分类整理： 2.1 目录操作命令 命令 功能描述 基本语法 示例 pwd 显示当前工作目录的绝对路径 pwd pwd → 输出：/home/user/git-learn cd 切换工作目录 cd [目录路径] 1. cd ~ → 回到当前用户主目录2. cd .. → 回到上级目录3. cd /home/user → 切换到指定绝对路径 ls 列出目录下的文件和子目录 ls [选项] [目录] 1. ls → 简单列出文件2. ls -l → 详细列表（权限、大小、时间等）3. ls -a → 显示隐藏文件（以.开头的文件，如.git） mkdir 创建新目录 mkdir [选项] 目录名 1. mkdir my-blog → 创建单级目录2. mkdir -p dir1/dir2/dir3 → 递归创建多级目录 rmdir 删除空目录 rmdir [选项] 目录名 rmdir empty-dir → 删除空目录（非空目录需用rm -r） 2.2 文件操作命令 命令 功能描述 基本语法 示例 touch 创建空文件或更新文件的时间戳 touch 文件名 touch README.md → 创建空的README文件 cat 查看文件内容（适合小文件） cat [选项] 文件名 1. cat README.md → 输出文件全部内容2. cat file1.txt file2.txt &gt; file3.txt → 合并两个文件到file3 cp 复制文件或目录 cp [选项] 源路径 目标路径 1. cp README.md docs/ → 复制文件到docs目录2. cp -r dir1 dir2 → 递归复制整个目录 mv 移动/重命名文件或目录 mv [选项] 源路径 目标路径 1. mv old.txt new.txt → 重命名文件2. mv new.txt docs/ → 移动文件到docs目录 rm 删除文件或目录（谨慎使用） rm [选项] 路径 1. rm test.txt → 删除单个文件2. rm -r dir1 → 递归删除目录及内容3. rm -rf dir1 → 强制删除（忽略提示，慎用） tail 查看文件尾部内容（常用于日志） tail [选项] 文件名 1. tail -n 10 README.md → 查看最后10行2. tail -f app.log → 实时监控文件变化（按Ctrl+C退出） 2.3 权限管理命令Git仓库的文件权限会影响提交和拉取，核心命令如下： 命令 功能描述 基本语法 示例 chmod 修改文件/目录的权限 chmod [权限值/符号] 路径 1. chmod 755 script.sh → 所有者读写执行，其他用户读执行2. chmod +x script.sh → 给所有用户添加执行权限 chown 修改文件/目录的所有者和所属组 chown [选项] 所有者:所属组 路径 chown user:user-group my-file.txt → 修改文件所有者为user，组为user-group 2.4 查找与搜索命令在Git仓库中搜索内容/文件时高频使用： 命令 功能描述 基本语法 示例 find 按路径/名称/类型查找文件 find [搜索路径] [条件] 1. find . -name &quot;*.md&quot; → 在当前目录下查找所有md文件2. find /home -type d -name &quot;git*&quot; → 查找所有以git开头的目录 grep 在文件中搜索指定字符串 grep [选项] 关键词 文件名 1. grep &quot;git&quot; README.md → 在文件中搜索git关键词2. grep -r &quot;hello&quot; ./ → 递归搜索当前目录下所有文件中的hello diff 对比两个文件的内容差异 diff [选项] 文件1 文件2 diff old.txt new.txt → 显示两个文件的差异（和git diff原理类似） 2.5 压缩与解压命令Git备份/下载资源时常用： 命令 功能描述 基本语法 示例 tar 打包/解压文件（最常用） tar [选项] 压缩包名 源文件/目录 1. tar -zcvf my-git.tar.gz ./ → 打包并压缩当前目录2. tar -zxvf my-git.tar.gz → 解压压缩包到当前目录 2.6 Git协作相关命令用于和远程Git仓库（GitHub/Gitee）交互： 命令 功能描述 基本语法 示例 ssh 连接远程服务器（克隆私有仓库时用） ssh [用户名]@[服务器地址] ssh git@github.com → 测试与GitHub的SSH连接 scp 跨机器传输文件 scp [选项] 源文件 目标地址 scp local-file.txt user@server:/home/user/ → 本地文件传到远程服务器 2.7 其他常用命令 命令 功能描述 基本语法 示例 echo 输出内容到终端或文件 echo [内容] 1. echo &quot;Hello Git&quot; → 终端输出字符串2. echo &quot;test&quot; &gt; test.txt → 写入内容到文件（覆盖原有内容） man 查看命令的官方手册（新手必备） man 命令名 man git → 查看git的详细帮助文档man ls → 查看ls命令的所有选项 clear 清空终端屏幕 clear clear → 一键清空当前终端内容 3. Git 核心理论3.1 Git 四个工作区域 工作区（Working Directory）：即本地电脑中可见的文件目录，是日常编写代码、修改文件的区域。工作区的文件状态分为“未跟踪”和“已跟踪”，未跟踪文件是指从未被Git管理过的文件。 暂存区（Stage/Index）：位于.git目录下的index文件中，用于临时存储工作区中已修改并准备提交的文件。暂存区相当于“缓冲区”，可将多个修改分批暂存，再一次性提交到本地仓库，便于灵活管理提交内容。 本地仓库（Local Repository）：即.git隐藏目录，包含了所有版本的提交记录、分支信息等核心数据，是Git版本控制的核心。提交到本地仓库的文件会形成历史版本，可随时回退到任意版本。 远程仓库（Remote Repository）：位于服务器上的仓库（如GitHub、Gitee），用于多人协作共享代码。本地仓库可与远程仓库同步，实现代码推送（push）和拉取（pull），完成协作开发。 流转关系：工作区修改 → git add 到暂存区 → git commit 到本地仓库 → git push 到远程仓库；反之，远程仓库代码可通过 git pull 拉取到本地仓库，再同步到工作区。 3.2 Git 文件的四种状态 未跟踪（Untracked）：文件在工作区，但从未执行过git add命令，Git不管理该文件。执行git add后，状态变为“已暂存”。 已暂存（Staged）：文件已存入暂存区，等待提交到本地仓库。执行git commit后，状态变为“已提交”；若修改已暂存的文件，会同时存在“已暂存”和“已修改”状态，需重新执行git add更新暂存区。 已提交（Committed）：文件已提交到本地仓库，形成历史版本。此时文件在本地仓库中是稳定的，可通过git reset回退版本，或通过git push推送到远程仓库。 已修改（Modified）：文件在工作区被修改过，但尚未暂存。执行git add可将其转为“已暂存”状态；执行git checkout – 文件名可丢弃修改，回到“已提交”或“已暂存”状态。 可通过git status命令随时查看文件当前状态，明确下一步操作方向。 4. Git 基础操作命令4.1 仓库初始化与克隆 命令 功能描述 示例 git init 初始化本地Git仓库 git init → 在当前目录创建.git隐藏目录 git clone [url] 克隆远程仓库到本地 git clone https://github.com/username/repo.git → 克隆远程仓库 4.2 文件状态与修改查看 命令 功能描述 示例 git status [文件] 查看文件/所有文件的状态 1. git status test.txt → 查看指定文件状态2. git status → 查看所有文件状态 git diff [文件] 查看文件的具体修改内容 git diff test.txt → 查看test.txt的修改内容 4.3 暂存与提交 命令 功能描述 示例 git add [文件] 添加指定文件到暂存区 git add test.txt → 添加单个文件 git add . 添加所有修改的文件到暂存区 git add . → 批量添加所有文件 git commit -m &quot;提交信息&quot; 提交暂存区内容到本地仓库 git commit -m &quot;新增test.txt文件&quot; → 提交并添加描述 4.4 版本日志与回退 命令 功能描述 示例 git log 显示从近到远的提交日志（完整信息） git log → 查看所有提交记录 git log --pretty=oneline 精简显示提交日志（仅版本号+描述） git log --pretty=oneline → 简化日志输出 git reflog 显示所有操作的命令日志（含回退记录） git reflog → 查看所有Git操作记录 git reset --hard HEAD^ 回退到上一个版本（已提交状态） git reset --hard HEAD^ → 彻底回退到上个版本 git reset --soft HEAD^ 回退到上一个版本（未提交状态） git reset --soft HEAD^ → 保留修改，回到未提交状态 git reset --mixed HEAD^ 回退到上一个版本（已暂存未提交） git reset --mixed HEAD^ → 回到暂存后未提交状态 git reset --hard [版本号] 回退到指定版本 git reset --hard 1094a → 回退到版本号为1094a的版本 备注：HEAD表示当前版本，HEAD^=上一版本，HEAD~100=往上100个版本 4.5 撤销修改与删除文件 命令 功能描述 适用场景 git checkout -- [文件] 丢弃工作区的修改 1. 文件仅在工作区修改，未暂存 → 回到版本库状态2. 文件已暂存后又修改 → 回到暂存后的状态 git reset HEAD [文件] 撤销暂存区的修改（放回工作区） 文件已添加到暂存区，想撤销暂存 git rm [文件] 删除版本库中的文件 git rm test.txt &amp;&amp; git commit -m &quot;remove test.txt&quot; → 删除文件并提交 撤销修改场景总结： 场景1：仅改乱工作区 → git checkout -- 文件 场景2：改乱工作区+已暂存 → 先git reset HEAD 文件，再执行场景1 场景3：已提交错误版本 → 用git reset --hard回退（未推送到远程时可用） 4.6 远程仓库交互 命令 功能描述 示例 git remote add origin [远程地址] 关联远程仓库（origin为默认名称） git remote add origin git@github.com:username/repo.git git push -u origin main 第一次推送main分支到远程（-u绑定关联） git push -u origin main → 推送本地main分支到远程 git push origin main 后续推送本地修改到远程main分支 git push origin main → 日常推送更新 git remote -v 查看已关联的远程仓库信息 git remote -v → 显示远程仓库的fetch/push地址 git remote rm origin 删除已关联的远程仓库 git remote rm origin → 解除和远程仓库的关联 5. Git 分支操作5.1 分支基础命令 命令 功能描述 示例 git branch 查看所有本地分支（*标记当前分支） git branch → 列出所有分支 git branch [分支名] 创建新分支 git branch test → 创建test分支 git checkout [分支名] 切换分支（旧语法） git checkout test → 切换到test分支 git switch [分支名] 切换分支（新语法，推荐） git switch test → 切换到test分支 git checkout -b [分支名] 创建+切换分支（旧语法） git checkout -b test → 创建并切换到test分支 git switch -c [分支名] 创建+切换分支（新语法，推荐） git switch -c test → 创建并切换到test分支 git merge [分支名] 合并指定分支到当前分支 git merge test → 把test分支合并到当前分支 git branch -d [分支名] 删除本地分支（需先切换到其他分支） git branch -d test → 删除test分支 git log --graph 查看分支合并的图形化日志 git log --graph → 可视化分支合并历史 5.2 分支冲突处理当不同分支修改同一文件导致合并冲突时： Git会标记冲突文件的冲突位置 手动编辑文件，删除冲突标记并调整代码逻辑 保存后执行git add [冲突文件] → git commit -m &quot;解决分支冲突&quot; 完成合并 6. 参考资料 Git 速查表（Cheat Sheet） 廖雪峰 Git 教程（零基础入门）","link":"/2026/01/23/git%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E5%8F%82%E8%80%83/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2026/01/21/hello-world/"},{"title":"如何新增博客内容？","text":"本文详细介绍基于Icarus主题的Hexo博客新增文章全流程，涵盖从文章创建、编辑、本地预览到最终部署的所有操作，同时适配Icarus主题专属功能（目录、评论、代码高亮等）。 一、 核心操作流程（从创建到部署）步骤1：终端创建文章/草稿在Hexo博客根目录打开终端，执行对应命令创建文章，生成的文件会自动存入指定目录，Icarus主题可正常渲染。 1.1 创建正式文章（推荐）1234# 完整命令hexo new &quot;你的博客文章标题&quot;# 简写命令（更高效，推荐使用）hexo n &quot;Hexo Icarus 主题新增文章教程&quot; 1.2 创建草稿（先撰写后发布）如果暂不想公开，可先创建草稿进行编辑： 123456# 创建草稿（生成到 source/_drafts/ 目录）hexo new draft &quot;草稿标题&quot;# 预览草稿（需添加 -d 参数）hexo s -d# 发布草稿（自动移动到 source/_posts/ 目录，转为正式文章）hexo publish &quot;草稿标题&quot; 1.3 关键注意点 文章标题含空格时，必须用英文引号括起来。 文件名建议使用英文/拼音，避免出现渲染异常。 若开启post_asset_folder: true（Hexo根目录_config.yml），创建文章时会生成同名文件夹，用于存放文章配图，方便管理。 步骤2：编辑Markdown文章文件打开source/_posts/目录下生成的.md文件，按照「Front-Matter配置 + Markdown正文」的结构进行编辑。 2.1 必配Front-Matter（Icarus主题兼容）这是文章的配置头部，决定Icarus主题的渲染效果，核心配置如下： 1234567891011121314151617---# 文章核心信息title: Hexo Icarus 主题新增文章教程 # 文章标题date: 2026-01-22 22:00:00 # 发布日期（自动生成，可手动修改）updated: 2026-01-22 23:30:00 # 更新日期（可选，不同与date时会显示在文章底部）categories: # 多级分类（对应侧边栏Categories widget） - Hexo教程(父类) - Icarus主题(子类)tags: # 文章标签（对应侧边栏Tags widget，最多显示10个） - Hexo - Icarus - 博客搭建# Icarus主题专属配置excerpt: 这是一篇基于Icarus主题的Hexo新增文章教程，包含评论、目录等功能适配。 # 列表页显示的摘要toc: true # 开启左侧自动生成目录（对应toc widget）comments: true # 开启底部Gitalk评论框（关闭则不显示）--- 2.2 Front-Matter关键说明 toc: true：配合你配置的左侧TOC部件，自动生成1-3级标题目录，支持跳转。 comments: true：触发已配置的Gitalk评论框，无需额外修改，部署后即可显示。 代码高亮：无需额外配置，Icarus已预设atom-one-light主题，正文代码块会自动高亮并附带复制按钮。 2.3 编写Markdown正文（Icarus自动渲染）Front-Matter下方使用标准Markdown语法编写正文即可，Icarus会自动渲染以下特色功能： 代码块：自动高亮、带复制按钮、默认展开（配置fold: unfolded）。 图片：推荐放入文章同名文件夹，引用格式![图片描述](文章标题/图片名.webp)。 阅读时间：自动计算并显示在文章标题下方（配置readtime: true）。 更新时间：updated与date不同时，自动显示在文章底部（配置update_time: auto）。 2.4 正文示例（可直接复制测试）12345## 一、核心创建命令回顾创建正式文章的核心终端命令：```bash# 简写命令，高效创建hexo n &quot;你的文章标题&quot; 二、Icarus主题功能验证要点 左侧是否自动生成TOC目录（依赖toc: true配置）。 代码块是否有原子白高亮效果，且右侧带有复制按钮。 文章底部是否显示Gitalk评论框（需登录GitHub账号）。 三、图片引用示例（推荐方式）开启post_asset_folder: true后，图片引用格式如下：![Icarus主题LOGO](新增文章教程/icarus-logo.png) 12345678## 步骤3：本地预览（验证功能是否生效）编辑完成后，先进行本地预览，避免部署后出现问题，优先排查功能异常。### 3.1 启动本地预览服务器```bash# 清除旧缓存 + 启动本地服务器（默认端口4000）hexo clean &amp;&amp; hexo s 3.2 验证核心功能在浏览器访问http://localhost:4000，逐一检查以下内容： 新文章是否出现在首页、对应分类页、对应标签页中。 文章左侧TOC目录是否正常显示，且跳转功能可用。 代码块是否高亮，复制按钮是否可以正常使用。 文章底部Gitalk评论框是否显示（即使提示“未找到相关Issue”，也说明配置正常）。 步骤4：生成静态文件并一键部署本地预览无误后，执行命令发布到GitHub Pages，完成博客更新。 4.1 部署终端命令12# 清除缓存 → 生成静态文件 → 部署到GitHub Pageshexo clean &amp;&amp; hexo g -d 4.2 部署注意点 GitHub Pages存在1-3分钟延迟，部署后无需立即刷新，等待片刻再访问。 Gitalk评论框首次使用时，需登录GitHub账号，点击“初始化评论”自动创建对应Issue，之后即可正常评论。 二、 Icarus主题专属注意事项1. Gitalk评论功能生效补充 确保公开仓库repo: blog-comments已创建完成。 确保client_id和client_secret与GitHub OAuth App信息一致。 若评论框报错，检查proxy地址（你配置的https://gh-proxy.com/可解决国内访问问题）是否可用。 2. 图片路径优化建议 优先开启post_asset_folder: true，图片放入文章同名文件夹，引用更便捷且无加载异常。 图片名避免使用中文，建议采用「英文/拼音+连字符」命名（如icarus-logo.webp）。 3. 侧边栏Widget自动同步 左侧侧边栏（分类、目录、友情链接）、右侧侧边栏（最新文章、归档、标签）会自动同步新文章的categories和tags，无需手动修改配置。 4. 数学公式支持 已开启mathjax: true，文章中可直接使用MathJax语法插入数学公式（如$E=mc^2$），Icarus会自动渲染。 三、 总结 核心流程：hexo n &quot;标题&quot; → 编辑Markdown（适配Front-Matter） → hexo clean &amp;&amp; hexo s预览 → hexo clean &amp;&amp; hexo g -d部署。 关键适配：Front-Matter中开启toc: true和comments: true，对应Icarus主题的目录和Gitalk评论功能。 避坑要点：本地预览优先于部署，可提前验证所有功能，减少返工成本。","link":"/2026/01/22/%E5%A6%82%E4%BD%95%E6%96%B0%E5%A2%9E%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%EF%BC%9F/"},{"title":"零基础利用Github、Hexo搭建个人博客(超详细版)","text":"一、需求描述希望搭建一个属于自己的个人博客平台，用于分享 Markdown 格式的技术教程、学习笔记，同时支持自身在线查阅；但受限于零服务器资源、零建站经验，不想投入成本购买服务器，也不愿花费大量时间研究复杂的建站技术；需要一份从环境配置、主题定制，到内容发布、部署上线的超详细分步指南，确保按步骤操作就能完成博客搭建。免费托管需求可通过 GitHub 平台实现，Markdown 内容快速生成静态博客的需求可通过 Hexo 框架满足，两者结合即可打造一套零成本、易维护的个人博客系统。 二、准备工作2.1 安装Git参考超详细Git安装指南一步一步跟着做即可。 附赠Git快速上手教程 Git新手入门参考 Git教程-廖雪峰的官方网站(强推) B站狂神说建议：主看Git教程-廖雪峰的官方网站，遇到不理解的地方参考B站狂神说，想快速上手看Git新手入门参考。 2.2 安装Node.js参考超详细Node.js安装指南一步一步跟着做即可。 2.3 安装Hexo2.3.1 安装npm按正常步骤已经安装完毕，如不放心可执行以下命令查看： 123输入命令node -v # 若输出v20.x.x，说明Node.js安装成功。输入命令npm -v # 若输出对应版本号，说明npm包管理工具同步安装成功。 2.3.2 安装Hexo12345#1-使用npm下载安装Hexonpm install hexo-cli -g #2-查看hexo版本信息(显示对应的版本信息则表示安装成功)hexo -v 2.4 创建Hexo项目1234567891011121314151617181920212223#1-进入指定路径(博客内容放置的目录下)cd D:\\MyBlog #2-创建一个Hexo新项目hexo init ckblogs #3-进入该内容目录中cd ckblogs #4-安装Hexo项目核心依赖内容（必须步骤，保证项目正常运行）npm install #5-安装Hexo部署到GitHub专用依赖包（后续部署必须，提前安装）npm install hexo-deployer-git --save #6-启动Hexo项目（按下【Ctrl+C】停止服务）hexo server# 备选：如果4000端口被占用，可指定其他端口启动，例如4001端口# hexo server -p 4001#7-在浏览器输入【localhost:4000】访问到项目页面（表示项目安装配置完成）http://localhost:4000/ 三、主题配置3.1安装主题到Hexo主题官网(或在Github上搜索)挑选自己喜欢的主题(下面我将以ICARUS主题为例，其他主题同理) 这里推荐一些简约主题：NEXT、Fluid、Aurora 在Hexo主题官网挑选喜欢的主题后，可点击**’Visit preview site’**体验主题。一般原作者会在此处写下安装及配置教程 寻找主题配置教程示例 寻找主题安装教程示例 按照主题内置教程安装好后，执行以下命令： 1234567891011121314#1-进入创建好的blog项目中cd D:\\MyBlog\\ckblogs#2-安装blog项目所需的依赖内容(如已安装请忽略)npm install #3-清除缓存hexo clean #4-编译hexo g #5-启动服务hexo s 注意：所有的命令操作都是在Hexo根目录下进行的 安装好主题后，一般情况下可以在”D:\\MyBlog\\ckblogs\\themes”目录下找到，但是有些特殊的主题会安装到”D:\\MyBlog\\ckblogs\\node_modules”目录下(如ICARUS)。此时可以在本地预览效果。 3.2 主题个性化配置可在_config.yml文件(在主题目录下，不是Hexo根目录下的文件！)中自行编辑配置。 有些特殊主题下该文件的名字可以不同，不过大同小异。可根据主题提供的教程文档进行配置 配置_config.yml时的一些坑： 版本号一般不用改 换logo及头像的图片时要注意路径问题及图片格式、尺寸 有些导航栏的页面需要你自己填写。(如About导航栏，你可以这么配置：About: [你的Github主页链接或其他链接]) 一些插件最好用国内的，以免网速慢或日后出问题麻烦 有不懂的地方一定要参考教程文档或问AI，不要自己乱改，出bug很麻烦。 配置好主题后先到本地预览效果。可以在网页中打开开发者工具（快捷键：ctrl+shift+i）查看是否有报错，有些报错可能是浏览器自身扩展引发的，可以忽略。 推荐好用的图床网站点击跳转，不要上传二维码等隐私图片（bz曾上传了微信二维码，过一段时间链接自动失效了），不要上传违法图片。也可以使用github或gitee等仓库托管图片，不过要注意防盗链的问题！ 以上都是bz血与泪的教训[哭] 3.3 启用主题俩种方式：一 手动修改打开Hexo根目录下的_config.yml文件并编辑，找到文件中的theme: landscape（Hexo 默认主题），将其修改为theme: [你的主题] 注意：这里的主题名必须和主题文件夹名称一致，大小写敏感） 四、将Hexo项目部署到Github上4.1 将本机配置为免密登录GitHub这步在安装Git中应该操作完成。没有配置好的可以问下AI或重新看下教程。验证方法： 123ssh -T git@github.com# 回车后如果出现 GitHub 用户名相关提示，即表示配置成功# 首次验证会提示Are you sure you want to continue connecting (yes/no)?，输入yes回车即可 4.2 将本地生成的SSH公钥内容复制到Github中按正常步骤也已操作完毕。 操作步骤：1、 登录你的 GitHub 账号（ID：jasper0507），点击页面右上角的头像图标2、 在弹出的下拉菜单中，点击进入【Settings】（设置）页面3、 在左侧菜单栏中，找到并点击【SSH and GPG keys】选项4、 点击页面右上角的【New SSH key】按钮，进入 SSH 密钥添加界面5、填写密钥配置项：【Title】：自定义填写（可填如hexo-blog-deploy等标识性名称，无特殊要求）【Key type】：选择【Authentication key】（身份验证密钥）【Key】：打开本地生成的 SSH 密钥对中后缀为.pub的公钥文件，全选文件内的所有内容，粘贴到输入框中6、点击页面底部的【Add SSH key】按钮，完成公钥的添加操作 4.3 在Github上创建所属博客的仓库操作步骤 登录 GitHub 账号后，点击页面右上角的加号图标【+】 在弹出的下拉菜单中，点击【New repository】选项，进入仓库创建页面 根据自身需求填写仓库名称（[你的github用户名].github.io），选择公开(私有仓库无法搭建博客)，其他配置可默认 点击页面底部的【Create repository】按钮，完成 GitHub 仓库的创建 仓库创建成功后，在当前仓库界面的右侧区域，找到并点击【code】按钮 在展开的选项中，切换到【local】标签页 选择【ssh】选项，点击右侧的复制图标，即可获取该仓库的 SSH 链接 4.4 配置文件打开编辑Hexo根目录下_config.yml文件添加并编辑以下配置 123456deploy: type: 'git' repo: git@github.com:自己在github上的用户名称/仓库名称.git branch: main name: 自己在github上的用户名称 email: 自己在github上的用户对应的邮箱 4.5 部署项目1234567891011121314#1-进入本地的blog项目cd ckblogs#2-安装部署项目到github所需的包npm install hexo-deployer-git --save #3--清除缓存hexo clean #4-编译blog项目hexo g #5-部署blog项目到github上hexo d 看到”INFO Deploy done: git”就代表部署成功了，可到github仓库中查看(可能有延迟)。 五、打开博客网站查看效果至此，你的个人博客网站已经部署成功了！在浏览器中输入[你的github用户名].github.io即可进入你的专属博客。仍需测试博客的功能等是否一切正常，如果异常可以翻阅教程文档或询问ai后修改主题文件相关代码。修改后需执行以下命令： 1234567# 首先在本地预览，测试效果hexo clean #清理缓存hexo s #启动本地服务，可访问`http://localhost:4000/`# 确认无误后再上传hexo clean &amp;&amp; hexo g -d #一键部署 注意：修改后可能因为延迟等原因无法立即在网页上看到效果，可以等几分钟或者启动科学上网刷新网页. 六、新增博客内容可参考如何新增博客内容？，有详细教程。 七、 结语本文章结合了bz自己在搭建过程中的经验教训以及好的教学文档。如发现文章有任何错误欢迎留言或评论。谢谢大家！","link":"/2026/01/23/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%A9%E7%94%A8Github%E3%80%81Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E8%B6%85%E8%AF%A6%E7%BB%86%E7%89%88/"},{"title":"数据结构与算法(长期更新)","text":"栈与队列逆波兰表达式中缀表达式转化为后缀表达式转换规则（调度场算法）： 操作数直接输出。 运算符根据优先级处理，优先级高的先输出，同优先级左结合。 左括号 ( 入栈；遇到右括号 ) 时，弹出栈内运算符直到遇到左括号。 扫描完毕后，将栈中剩余运算符依次弹出。 举例原始表达式：a/b+(c*d-e*f)/g 扫描字符 动作 输出 栈（底→顶） a 输出 a a 空 / 入栈 / a / b 输出 b a b / + 弹出/输出，入栈+ a b / + ( 入栈 ( a b / + ( c 输出 c a b / c + ( * 入栈 * a b / c + ( * d 输出 d a b / c d + ( * - 弹出*输出，入栈- a b / c d * + ( - e 输出 e a b / c d * e + ( - * 入栈 * a b / c d * e + ( - * f 输出 f a b / c d * e f + ( - * ) 弹出*、-输出，弹出( a b / c d * e f * - + / 入栈 / a b / c d * e f * - + / g 输出 g a b / c d * e f * - g + / 结束 弹出/、+输出 a b / c d * e f * - g / + 空 最终后缀表达式：ab/cd*ef*-g/+ 后缀表达式求值算法步骤 从左到右扫描后缀表达式 遇到操作数 → 压入操作数栈 遇到运算符 → 弹出两个操作数（先右后左），计算结果压回栈中 扫描结束，栈顶即为表达式值 补充：先弹出的操作数对应运算符右侧的操作数，后弹出的对应运算符左侧的操作数。 举例设：a=8, b=2, c=3, d=4, e=5, f=6, g=2后缀表达式：ab/cd*ef*-g/+ 步骤 扫描字符 操作 操作数栈（底→顶） 1 a 压入 8 8 2 b 压入 2 8, 2 3 / 8÷2=4 4 4 c 压入 3 4, 3 5 d 压入 4 4, 3, 4 6 * 3×4=12 4, 12 7 e 压入 5 4, 12, 5 8 f 压入 6 4, 12, 5, 6 9 * 5×6=30 4, 12, 30 10 - 12-30=-18 4, -18 11 g 压入 2 4, -18, 2 12 / -18÷2=-9 4, -9 13 + 4+(-9)=-5 -5 结果：-5 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 运算符优先级int precedence(char op) { if (op == '+' || op == '-') return 1; if (op == '*' || op == '/') return 2; return 0;}// 中缀转后缀string infixToPostfix(const string&amp; infix) { stack&lt;char&gt; st; string postfix = &quot;&quot;; for (char ch : infix) { // 如果是操作数（字母或数字） if (isalnum(ch)) { postfix += ch; postfix += ' '; // 用空格分隔 } // 如果是左括号 else if (ch == '(') { st.push(ch); } // 如果是右括号 else if (ch == ')') { while (!st.empty() &amp;&amp; st.top() != '(') { postfix += st.top(); postfix += ' '; st.pop(); } st.pop(); // 弹出 '(' } // 如果是运算符 else if (ch == '+' || ch == '-' || ch == '*' || ch == '/') { while (!st.empty() &amp;&amp; precedence(st.top()) &gt;= precedence(ch)) { postfix += st.top(); postfix += ' '; st.pop(); } st.push(ch); } } // 弹出栈中剩余运算符 while (!st.empty()) { postfix += st.top(); postfix += ' '; st.pop(); } return postfix;}// 后缀表达式求值double evaluatePostfix(const string&amp; postfix, map&lt;char, double&gt;&amp; values) { stack&lt;double&gt; st; for (int i = 0; i &lt; postfix.length(); i++) { char ch = postfix[i]; // 跳过空格 if (ch == ' ') continue; // 如果是操作数 if (isalpha(ch)) { st.push(values[ch]); } // 如果是数字（多位数处理） else if (isdigit(ch)) { double num = 0; while (i &lt; postfix.length() &amp;&amp; isdigit(postfix[i])) { num = num * 10 + (postfix[i] - '0'); i++; } i--; // 回退一格 st.push(num); } // 如果是运算符 else { double b = st.top(); st.pop(); double a = st.top(); st.pop(); switch (ch) { case '+': st.push(a + b); break; case '-': st.push(a - b); break; case '*': st.push(a * b); break; case '/': st.push(a / b); break; } } } return st.top();} 字符串KMP算法关键定义前缀表（next数组）定义记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。 前缀：不包含最后一个字符的所有以第一个字符开头的连续子串。 后缀：不包含第一个字符的所有以最后一个字符结尾的连续子串。 举例 0 1 2 3 4 5 6 7 8 9 10 11 12 a a b a a b s a a b a a a 0 1 0 1 2 3 0 1 2 3 4 5 2 作用前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。 代码实现123456789101112131415161718192021222324252627282930void getNext(int* next, const string&amp; s) { int j = 0; next[0] = 0; for(int i = 1; i &lt; s.size(); i++) { while (j &gt; 0 &amp;&amp; s[i] != s[j]) { // j要保证大于0，因为下面有取j-1作为数组下标的操作 j = next[j - 1]; // 注意这里，是要找前一位的对应的回退位置了 } if (s[i] == s[j]) { j++; } next[i] = j; }}// j指向前缀末尾位置，i指向后缀末尾位置// j还代表着当前i之前（包括i）子串的最长相等前后缀的长度。// 主要聚焦于i指针，代表当前遍历到的子串的最后一个位置int strStr(string haystack, string needle) { if(needle.size()==0) return 0; vector&lt;int&gt; next(needle.size()); getNext(next,needle); int j=0; for(int i=0;i&lt;haystack.size();i++){ while(j&gt;0&amp;&amp;haystack[i]!=needle[j]) j=next[j-1]; if(haystack[i]==needle[j]) j++; if(j==needle.size()) return i-j+ 1; } return -1;}// i为当前遍历到的haystack字符串的位置// j为当前遍历到的needle字符串的位置 时间复杂度: O(n + m) 空间复杂度: O(m) 二叉树理论基础遍历方式DFS递归遍历递归三部曲 确定递归函数的参数和返回值确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 确定单层递归的逻辑确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。递归函数中，什么时候需要返回值？如果需要搜索整棵二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。 前序遍历123456void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 } 中序遍历123456void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; traversal(cur-&gt;left, vec); // 左 vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;right, vec); // 右} 后序遍历123456void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 vec.push_back(cur-&gt;val); // 中} 迭代遍历前序遍历1234567891011121314vector&lt;int&gt; preorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); // 中 st.pop(); result.push_back(node-&gt;val); if (node-&gt;right) st.push(node-&gt;right); // 右（空节点不入栈） if (node-&gt;left) st.push(node-&gt;left); // 左（空节点不入栈） } return result; } 后序遍历123456789101112131415vector&lt;int&gt; postorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); st.pop(); result.push_back(node-&gt;val); if (node-&gt;left) st.push(node-&gt;left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈） if (node-&gt;right) st.push(node-&gt;right); // 空节点不入栈 } reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了 return result; } 中序遍历1234567891011121314151617vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; TreeNode* cur = root; while (cur != NULL || !st.empty()) { if (cur != NULL) { // 指针来访问节点，访问到最底层 st.push(cur); // 将访问的节点放进栈 cur = cur-&gt;left; // 左 } else { cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据） st.pop(); result.push_back(cur-&gt;val); // 中 cur = cur-&gt;right; // 右 } } return result; } 统一迭代法BFS(层序遍历)12345678910111213141516171819vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { queue&lt;TreeNode*&gt; que; if (root != NULL) que.push(root); vector&lt;vector&lt;int&gt;&gt; result; while (!que.empty()) { int size = que.size(); vector&lt;int&gt; vec; // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的 for (int i = 0; i &lt; size; i++) { TreeNode* node = que.front(); que.pop(); vec.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); } result.push_back(vec); } return result; } 应用 对称二叉树（双指针遍历） 另一棵树的子树 二叉树的最大深度 二叉树的最小深度 二叉树的最近公共祖先（空节点做标记） 二叉搜索树验证二叉搜索树 关键点：中序遍历下，输出的二叉搜索树节点的数值是升序序列。 看到题目中出现二叉搜索树，首先想到该特性。 二叉搜索树的插入123456TreeNode* insertIntoBST(TreeNode* root, int val) { if(!root) return new TreeNode(val); if(root-&gt;val&gt;val) root-&gt;left=insertIntoBST(root-&gt;left,val); if(root-&gt;val&lt;val) root-&gt;right=insertIntoBST(root-&gt;right,val); return root;} 二叉搜索树的删除1234567891011121314151617181920212223242526272829303132333435363738394041TreeNode* deleteNode(TreeNode* root, int key) { if (root == nullptr) return root; // 第一种情况：没找到删除的节点，遍历到空节点直接返回了 if (root-&gt;val == key) { // 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点 if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) { ///! 内存释放 delete root; return nullptr; } // 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点 else if (root-&gt;left == nullptr) { auto retNode = root-&gt;right; ///! 内存释放 delete root; return retNode; } // 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点 else if (root-&gt;right == nullptr) { auto retNode = root-&gt;left; ///! 内存释放 delete root; return retNode; } // 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置 // 并返回删除节点右孩子为新的根节点。 else { TreeNode* cur = root-&gt;right; // 找右子树最左面的节点 while(cur-&gt;left != nullptr) { cur = cur-&gt;left; } cur-&gt;left = root-&gt;left; // 把要删除的节点（root）左子树放在cur的左孩子的位置 TreeNode* tmp = root; // 把root节点保存一下，下面来删除 root = root-&gt;right; // 返回旧root的右孩子作为新root delete tmp; // 释放节点内存（这里不写也可以，但C++最好手动释放一下吧） return root; } } if (root-&gt;val &gt; key) root-&gt;left = deleteNode(root-&gt;left, key); if (root-&gt;val &lt; key) root-&gt;right = deleteNode(root-&gt;right, key); return root;} 平衡二叉树（AVL树）理论理解代码模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std;struct AVLNode { int val; AVLNode* left; AVLNode* right; int height; // 节点高度（叶子节点高度=1，空节点高度=0） AVLNode(int x) : val(x), left(nullptr), right(nullptr), height(1) {}};// 1. 获取节点高度（空节点高度为0）int getHeight(AVLNode* node) { if (node == nullptr) return 0; return node-&gt;height;}// 2. 更新节点高度：当前节点高度 = 左右子树高度的最大值 + 1void updateHeight(AVLNode* node) { node-&gt;height = max(getHeight(node-&gt;left), getHeight(node-&gt;right)) + 1;}// 3. 计算平衡因子：平衡因子 = 左子树高度 - 右子树高度// 平衡因子绝对值&gt;1 时，节点失衡int getBalanceFactor(AVLNode* node) { if (node == nullptr) return 0; return getHeight(node-&gt;left) - getHeight(node-&gt;right);}// ===================== 旋转操作（核心） =====================/** * 右旋转（处理LL型失衡） * 失衡场景：节点的平衡因子&gt;1，且左孩子的平衡因子≥0 * 旋转逻辑： * y x * / \\ / \\ * x T3 右旋转 (y) z y * / \\ -------&gt; / \\ / \\ * z T2 T1 T4 T2 T3 * / \\ * T1 T4 */AVLNode* rightRotate(AVLNode* y) { AVLNode* x = y-&gt;left; // x是y的左孩子 AVLNode* T2 = x-&gt;right; // T2是x的右子树 // 执行旋转 x-&gt;right = y; y-&gt;left = T2; // 更新高度（先更子节点y，再更父节点x） updateHeight(y); updateHeight(x); return x; // 返回旋转后的新根节点x}/** * 左旋转（处理RR型失衡） * 失衡场景：节点的平衡因子&lt;-1，且右孩子的平衡因子≤0 * 旋转逻辑： * y x * / \\ / \\ * T1 x 左旋转 (y) y z * / \\ -------&gt; / \\ / \\ * T2 z T1 T2 T3 T4 * / \\ * T3 T4 */AVLNode* leftRotate(AVLNode* y) { AVLNode* x = y-&gt;right; // x是y的右孩子 AVLNode* T2 = x-&gt;left; // T2是x的左子树 // 执行旋转 x-&gt;left = y; y-&gt;right = T2; // 更新高度 updateHeight(y); updateHeight(x); return x; // 返回旋转后的新根节点x}// ===================== 插入操作 =====================/** * 递归插入节点（核心逻辑） * 步骤： * 1. 普通二叉搜索树的插入 * 2. 更新当前节点高度 * 3. 计算平衡因子，判断是否失衡 * 4. 失衡则根据类型旋转恢复平衡 */AVLNode* insert(AVLNode* root, int val) { // 第一步：普通BST插入 if (root == nullptr) { return new AVLNode(val); // 空节点，创建新节点 } if (val &lt; root-&gt;val) { root-&gt;left = insert(root-&gt;left, val); // 插入左子树 } else if (val &gt; root-&gt;val) { root-&gt;right = insert(root-&gt;right, val); // 插入右子树 } else { return root; // 不允许重复值，直接返回 } // 第二步：更新当前节点的高度 updateHeight(root); // 第三步：计算平衡因子，检查是否失衡 int balance = getBalanceFactor(root); // 第四步：处理4种失衡情况 // 1. LL型：平衡因子&gt;1，左孩子平衡因子≥0 → 右旋转 if (balance &gt; 1 &amp;&amp; getBalanceFactor(root-&gt;left) &gt;= 0) { return rightRotate(root); } // 2. RR型：平衡因子&lt;-1，右孩子平衡因子≤0 → 左旋转 if (balance &lt; -1 &amp;&amp; getBalanceFactor(root-&gt;right) &lt;= 0) { return leftRotate(root); } // 3. LR型：平衡因子&gt;1，左孩子平衡因子&lt;0 → 先左旋左孩子，再右旋当前节点 if (balance &gt; 1 &amp;&amp; getBalanceFactor(root-&gt;left) &lt; 0) { root-&gt;left = leftRotate(root-&gt;left); return rightRotate(root); } // 4. RL型：平衡因子&lt;-1，右孩子平衡因子&gt;0 → 先右旋右孩子，再左旋当前节点 if (balance &lt; -1 &amp;&amp; getBalanceFactor(root-&gt;right) &gt; 0) { root-&gt;right = rightRotate(root-&gt;right); return leftRotate(root); } // 未失衡，返回原根节点 return root;} 哈夫曼树定义哈夫曼树（也叫最优二叉树）：对于一组带有确定权值的叶子节点，构造的二叉树中带权路径长度（WPL）最小的二叉树。 构建思路反复合并最小权值的两棵树，直到只剩一棵 12345678910111213141516171819202122232425struct Compare{ bool operator()(HuffmanNode* a,HuffmanNode* b){ return a-&gt;weight&gt;b-&gt;weight; }};HuffmanNode* buildHuffmanTree(const vector&lt;int&gt; &amp;weights){ priority_queue&lt;HuffmanNode*,vector&lt;HuffmanNode*&gt;,Compare&gt; minHeap; for(int weight:weights) minHeap.push(new HuffmanNode(weight)); while(minHeap.size()&gt;1){ HuffmanNode* left=minHeap.top(); minHeap.pop(); HuffmanNode* right=minHeap.top(); minHeap.pop(); HuffmanNode* parent= new HuffmanNode(left-&gt;weight+right-&gt;weight); parent-&gt;left=left; parent-&gt;right=right; minHeap.push(parent); } return minHeap.top();}int calculateWPL(HuffmanNode* root,int depth){ if(!root) return 0; if(!root-&gt;left&amp;&amp;!root-&gt;right) return root-&gt;weight*depth; return calculateWPL(root-&gt;left,depth+1)+calculateWPL(root-&gt;right,depth+1);} 哈夫曼编码左分支标记为 0，右分支标记为 1 m阶B-树性质 阶数约束：每个节点最多有 m 个子节点。 关键字数量范围：非根节点（无论叶子或非叶子）：关键字数 k 满足 ⌈m/2⌉ - 1 ≤ k ≤ m - 1；根节点：若为非叶子节点，1 ≤ k ≤ m - 1；若为树中唯一节点（叶子），k 可为 0 或 1。子节点与关键字数量关系：节点的子节点数 = 关键字数 + 1。 有序性与范围约束：单个节点内的关键字严格升序排列；子树关键字范围由父节点关键字划分，左子树关键字小于对应父关键字，右子树关键字大于对应父关键字。 平衡性质：所有叶子节点都位于同一层。 动态维护性质：插入时节点关键字数超上限则触发分裂，删除时节点关键字数低于下限则触发借关键字或合并，操作后仍保持所有核心性质。 区别 B - 树：关键字分布在所有节点，叶子节点和非叶子节点都存数据； B + 树：仅叶子节点存数据，非叶子节点只存索引，叶子节点通过链表相连（更适合范围查询）； 查找查找方法评价指标 平均查找长度(ASL)：查找过程中主要操作是关键字的比较，查找过程中关键字的平均比较次数（平均查找长度）作为衡量一个查找算法效率高低的标准。 ASL=Pi*Ci(累加) Pi为查找第i个元素的概率 Ci为找到第i个元素所需的关键字与给定值的比较次数 查找方法分类 顺序表和链表的查找 哈希表的查找 索引查找表的查找 二分查找代码模板1234567891011121314151617181920// 关键：确定好循环不变量的定义。确定好if()括号内判断的逻辑。class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int left = 0; int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right] while (left &lt;= right) { // 当left==right，区间[left, right]依然有效，所以用 &lt;= int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2 if (nums[middle] &gt; target) { right = middle - 1; // target 在左区间，所以[left, middle - 1] } else if (nums[middle] &lt; target) { left = middle + 1; // target 在右区间，所以[middle + 1, right] } else { // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 } } // 未找到目标值 return -1; }}; 时间复杂度：O(log n) 空间复杂度：O(1) 经典题 跳石头 哈希表理论基础排序排序算法的稳定性 在待排序序列中，若存在两个或多个关键字相等的元素，排序后它们的相对顺序与排序前保持一致，则称该排序算法是「稳定的」；反之则为「不稳定的」。 衡量排序方法的标准 平均比较次数 平均移动 平均辅助存储空间 稳定性 插入排序直接插入排序基本思想将数组划分为已排序（初始仅首个元素）和未排序区间，依次取出未排序区间的元素，向前插入到已排序区间的合适位置（保证已排序区间始终有序），直至所有元素插入完成。 代码模板12345678910111213141516171819202122void insertionSort(std::vector&lt;T&gt;&amp; arr) { // 空数组或单元素数组无需排序 if (arr.size() &lt;= 1) return; // 已排序区间初始为 [0]，未排序区间从 i=1 开始遍历 for (int i = 1; i &lt; arr.size(); ++i) { // 保存当前待插入的元素（避免移动过程中被覆盖） T temp = arr[i]; // j 指向已排序区间的最后一个元素，向前遍历找插入位置 int j = i - 1; // 向前比较：若已排序元素 &gt; 待插入元素，则后移（腾出插入位置） // 相等元素不移动 → 保证稳定性 while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) { arr[j + 1] = arr[j]; // 元素后移 --j; // 继续向前找 } // 找到插入位置（j+1），放入待插入元素 arr[j + 1] = temp; }} 时间复杂度：O (n²) 稳定排序 举例 以数组 [5, 2, 9, 3, 7] 为例，直接插入排序过程如下（已排序区间用「」标注，未排序区间用 () 标注）：初始状态：「5」，(2, 9, 3, 7)取未排序首元素 2，插入「5」的合适位置 → 「2, 5」，(9, 3, 7)取 9，插入「2, 5」末尾（9&gt;5）→ 「2, 5, 9」，(3, 7)取 3，向前比较：5&gt;3 则后移，2≤3 则插入 → 「2, 3, 5, 9」，(7)取 7，向前比较：9&gt;7 则后移，5≤7 则插入 → 「2, 3, 5, 7, 9」（完成）。 希尔排序基本思想希尔排序基本思想：作为直接插入排序的改进算法，先按递减的增量（步长）将数组划分为若干个子序列，对每个子序列分别执行直接插入排序；逐步缩小增量直至为 1，最后对整个数组执行一次直接插入排序（此时数组已基本有序，大幅降低插入排序的时间开销）。 代码模板123456789101112131415161718192021222324252627282930template &lt;typename T&gt;void insertionSortWithGap(std::vector&lt;T&gt;&amp; arr, int gap) { int n = arr.size(); if (n &lt;= 1) return; // 逻辑和普通插入排序完全一致，仅将“1”改为“gap” for (int i = gap; i &lt; n; ++i) { T temp = arr[i]; // 保存待插入元素 int j = i-gap; // 已排序序列最后一个元素 // 向前遍历子序列（步长gap），找到插入位置 while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) { arr[j + gap] = arr[j]; // 元素后移（步长gap） j -= gap; } arr[j + gap] = temp; // 插入到合适位置 }}// 希尔排序template &lt;typename T&gt;void shellSort(std::vector&lt;T&gt;&amp; arr) { int n = arr.size(); if (n &lt;= 1) return; // 外层仅控制步长（增量），核心排序逻辑复用插入排序 for (int gap = n / 2; gap &gt; 0; gap /= 2) { std::cout &lt;&lt; &quot;当前步长gap=&quot; &lt;&lt; gap &lt;&lt; &quot;，调用带步长的插入排序&quot; &lt;&lt; std::endl; insertionSortWithGap(arr, gap); // 复用插入排序处理当前步长的子序列 }} 时间复杂度：O (n log n) ~ O (n²) 之间 不稳定排序 举例 数组：[8,5,9,1,7,2,6,4]选短数组 + 简单间隔（8→4→2→1）初始状态数组：[8, 5, 9, 1, 7, 2, 6, 4]数组长度 n=8，初始间隔（gap）=8/2=4第一步：gap=4（大间隔分组粗排）分组规则：索引差 4 为一组，共 4 组组 1（索引 0、4）：8、7 → 插入排序后：7、8组 2（索引 1、5）：5、2 → 插入排序后：2、5组 3（索引 2、6）：9、6 → 插入排序后：6、9组 4（索引 3、7）：1、4 → 插入排序后：1、4排序后数组：[7, 2, 6, 1, 8, 5, 9, 4]（从完全乱序→初步有序）第二步：gap=2（缩小间隔再粗排）分组规则：索引差 2 为一组，共 2 组组 1（索引 0、2、4、6）：7、6、8、9 → 插入排序后：6、7、8、9组 2（索引 1、3、5、7）：2、1、5、4 → 插入排序后：1、2、4、5排序后数组：[6, 1, 7, 2, 8, 4, 9, 5]（更接近有序，仅需微调）第三步：gap=1（间隔 1 = 普通插入排序）此时数组[6,1,7,2,8,4,9,5]已基本有序，插入排序仅需少量调整：1 插到 6 前 → [1,6,7,2,8,4,9,5]2 插到 6 前 → [1,2,6,7,8,4,9,5]4 插到 6 前 → [1,2,4,6,7,8,9,5]5 插到 9 前 → 最终：[1,2,4,5,6,7,8,9] 交换排序冒泡排序基本思想 俩俩比较待排序对象的关键字 代码模板1234567891011121314151617void bubbleSort(int arr[], int n) { // 外层循环：控制排序轮数（n个元素最多需要n-1轮） for (int i = 0; i &lt; n - 1; ++i) { bool swapped = false; // 优化：标记本轮是否发生交换（提前终止） // 内层循环：每轮比较相邻元素，把最大的&quot;冒泡&quot;到末尾 // 每轮结束后，末尾i个元素已排好，无需重复比较 for (int j = 0; j &lt; n - 1 - i; ++j) { // 相邻元素逆序，交换位置 if (arr[j] &gt; arr[j + 1]) { swap(arr[j], arr[j + 1]); swapped = true; // 标记有交换发生 } } // 本轮无交换 → 数组已完全有序，直接退出（优化效率） if (!swapped) break; }} 时间复杂度：O(n²) 稳定排序（判断条件为arr[j] ==&gt;== arr[j+1]） 举例 数组初始状态：21 25 49 25* 16 8第一趟：21 25 25* 16 8 49第二趟：21 25 16 8 25* 49第三趟：21 16 8 25 25* 49第四趟：16 8 21 25 25* 49第五趟：8 16 21 25 25* 49 快速排序思路 选一个基准值；遍历数组，将比基准小的放左、大的放右，基准归位（最终排序位置）；递归对基准左右的子数组重复操作，直到子数组仅 1 个元素（天然有序）。 代码模板12345678910111213141516vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { sort(nums,0,nums.size()-1); return nums; } void sort(vector&lt;int&gt; &amp;nums,int l,int r){ if(l&gt;=r) return; int x=nums[l],i=l-1,j=r+1; while(i&lt;j){ do i++;while(nums[i]&lt;x); do j--;while(nums[j]&gt;x); if(i&lt;j) swap(nums[i],nums[j]); } sort(nums,l,j); sort(nums,j+1,r); } 时间复杂度：复杂度 O (n log n) 不稳定排序 适用于n较大的情况 选择排序简单选择排序基本思想 外层循环：遍历数组，确定每轮要归位的位置（第i轮处理索引i）；内层循环：在[i, 数组末尾]的未排序区间，找到最小值的索引；交换：将最小值与未排序区间的第一个元素（索引i）交换，完成该位置的归位；重复上述步骤，直到所有元素归位。 代码模板1234567891011121314void selectionSort(int arr[], int n) { // 外层循环：确定每轮归位的位置i（0到n-2，最后1个元素无需处理） for (int i = 0; i &lt; n - 1; ++i) { int minIdx = i; // 初始化最小值索引为当前未排序区间的第一个位置 // 内层循环：在[i, n-1]找最小值的索引 for (int j = i + 1; j &lt; n; ++j) { if (arr[j] &lt; arr[minIdx]) { minIdx = j; // 更新最小值索引 } } // 交换：把最小值放到索引i的位置（归位） swap(arr[i], arr[minIdx]); }} 时间复杂度：O(n²) 不稳定排序 举例 数组初始状态：6, 3, 8, 5, 9, 1, 7, 2, 4, 0第一轮 [0, 3, 8, 5, 9, 1, 7, 2, 4, 6]第二轮 [0, 1, 8, 5, 9, 3, 7, 2, 4, 6]第三轮 [0, 1, 2, 5, 9, 3, 7, 8, 4, 6]第四轮 [0, 1, 2, 3, 9, 5, 7, 8, 4, 6]第五轮 [0, 1, 2, 3, 4, 5, 7, 8, 9, 6]第六轮 不变第七轮 [0, 1, 2, 3, 4, 5, 6, 8, 9, 7]第八轮 [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]第九轮 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 树形选择排序(打擂台)模拟 15 25 15 25 28 19 15 49 25 37 28 19 65 15 34 每个枝结点的关键字都等于其左、右孩子结点中较小的关键字，根结点是最小的。输出最小关键字后，只需将叶子结点中的最小关键字改为最大值，然后重复上述步骤即可 堆排序前置知识 堆是基于完全二叉树的一种数据结构，核心满足「堆序性」，分为两种类型（升序排序常用大顶堆）： 堆类型 核心规则 关键特征 大顶堆 每个父节点值 ≥ 左右子节点值 堆顶是全局最大值 小顶堆 每个父节点值 ≤ 左右子节点值 堆顶是全局最小值 数组模拟堆（索引从 0 开始）：父节点 i 的左子节点：2i+1，右子节点：2i+2；子节点 j 的父节点：(j-1)/2（整数除法）。 堆的特点：序列中第一个元素为序列中最大（最小）值 代码模板123456789101112131415161718192021//大顶堆-&gt;升序 // unsortLen为未排序区间（0,,,unsortLen）左闭右闭void heapAdjust(vector&lt;int&gt;&amp; nums,int root,int unsortLen){ int lChild=2*root+1,rChild=2*root+2; int maxIdx=root; if(lChild&lt;=unsortLen&amp;&amp;nums[lChild]&gt;nums[maxIdx]) maxIdx=lChild; if(rChild&lt;=unsortLen&amp;&amp;nums[rChild]&gt;nums[maxIdx]) maxIdx=rChild; if(root!=maxIdx){ swap(nums[root],nums[maxIdx]); heapAdjust(nums,maxIdx,unsortLen); }}vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { int n=nums.size()-1; for(int root=(n-1)/2;root&gt;=0;root--) heapAdjust(nums,root,n);// 子节点 j 的父节点：(j-1)/2（整数除法）。 for(int unsortLen=n;unsortLen&gt;0;unsortLen--){ swap(nums[0],nums[unsortLen]); heapAdjust(nums,0,unsortLen-1); } return nums;} 1234567891011121314151617181920//小顶堆-&gt;降序void heapAdjust(vector&lt;int&gt;&amp; nums,int root,int unsortLen){ int lChild=2*root+1,rChild=2*root+2; int minIdx=root; if(lChild&lt;=unsortLen&amp;&amp;nums[lChild]&lt;nums[minIdx]) minIdx=lChild; if(rChild&lt;=unsortLen&amp;&amp;nums[rChild]&lt;nums[minIdx]) minIdx=rChild; if(root!=minIdx){ swap(nums[root],nums[minIdx]); heapAdjust(nums,minIdx,unsortLen); }}vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { int n=nums.size()-1; for(int root=(n-1)/2;root&gt;=0;root--) heapAdjust(nums,root,n);// 子节点 j 的父节点：(j-1)/2（整数除法）。 for(int unsortLen=n;unsortLen&gt;0;unsortLen--){ swap(nums[0],nums[unsortLen]); heapAdjust(nums,0,unsortLen-1); } return nums;} 时间复杂度：O(nlogn) 排序不稳定 归并排序思路 分（拆分）：将待排序数组从中间递归拆分为左右两个子数组，直到每个子数组仅含 1 个元素（单个元素天然有序）。治（合并）：将两个有序的子数组，通过双指针逐个比较、按大小合并为一个有序数组，逐层向上合并后得到最终有序数组。 代码模板1234567891011121314151617int temp[10005];void merge_sort(vector&lt;int&gt; &amp;num,int l,int r){ if(l&gt;=r) return; int mid = (l+r)/2; merge_sort(num,l,mid),merge_sort(num,mid+1,r); int k=0,i=l,j=mid+1; // 双指针比较，把较小元素放入temp while(i&lt;=mid&amp;&amp;j&lt;=r) if(num[i]&lt;=num[j]) temp[k++] = num[i++];// 如果是num[i]&lt;num[j]排序会变得不稳定。 else temp[k++] = num[j++]; // 处理左子数组剩余元素 while(i&lt;=mid) temp[k++]=num[i++]; // 处理右子数组剩余元素 while(j&lt;=r) temp[k++]=num[j++]; // 把temp中有序数据复制回原数组num的[l, r]区间 for(i=l,j=0;i&lt;=r;i++,j++) num[i]=temp[j]; } 时间复杂度：O(nlogn) 排序稳定 图论图的遍历深度搜索DFS三部曲 确认递归函数参数 确认终止条件 处理目前搜索节点出发的路径 思路代码框架123456789101112void dfs(参数) { if (终止条件) { 存放结果; return; } for (选择：本节点所连接的其他节点) { 处理节点; dfs(图，选择的节点); // 递归 回溯，撤销处理结果 }} 模板题代码模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//邻接矩阵写法#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; result; // 收集符合条件的路径vector&lt;int&gt; path; // 1节点到终点的路径void dfs (const vector&lt;vector&lt;int&gt;&gt;&amp; graph, int x, int n) { // 当前遍历的节点x 到达节点n if (x == n) { // 找到符合条件的一条路径 result.push_back(path); return; } for (int i = 1; i &lt;= n; i++) { // 遍历节点x链接的所有节点 if (graph[x][i] == 1) { // 找到 x链接的节点 path.push_back(i); // 遍历到的节点加入到路径中来 dfs(graph, i, n); // 进入下一层递归 path.pop_back(); // 回溯，撤销本节点 } }}int main() { int n, m, s, t; cin &gt;&gt; n &gt;&gt; m; // 节点编号从1到n，所以申请 n+1 这么大的数组 vector&lt;vector&lt;int&gt;&gt; graph(n + 1, vector&lt;int&gt;(n + 1, 0)); while (m--) { cin &gt;&gt; s &gt;&gt; t; // 使用邻接矩阵 表示无线图，1 表示 s 与 t 是相连的 graph[s][t] = 1; } path.push_back(1); // 无论什么路径已经是从0节点出发 dfs(graph, 1, n); // 开始遍历 // 输出结果 if (result.size() == 0) cout &lt;&lt; -1 &lt;&lt; endl; for (const vector&lt;int&gt; &amp;pa : result) { for (int i = 0; i &lt; pa.size() - 1; i++) { cout &lt;&lt; pa[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; pa[pa.size() - 1] &lt;&lt; endl; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//邻接表写法#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; result; // 收集符合条件的路径vector&lt;int&gt; path; // 1节点到终点的路径void dfs (const vector&lt;list&lt;int&gt;&gt;&amp; graph, int x, int n) { if (x == n) { // 找到符合条件的一条路径 result.push_back(path); return; } for (int i : graph[x]) { // 找到 x指向的节点 path.push_back(i); // 遍历到的节点加入到路径中来 dfs(graph, i, n); // 进入下一层递归 path.pop_back(); // 回溯，撤销本节点 }}int main() { int n, m, s, t; cin &gt;&gt; n &gt;&gt; m; // 节点编号从1到n，所以申请 n+1 这么大的数组 vector&lt;list&lt;int&gt;&gt; graph(n + 1); // 邻接表 while (m--) { cin &gt;&gt; s &gt;&gt; t; // 使用邻接表 ，表示 s -&gt; t 是相连的 graph[s].push_back(t); } path.push_back(1); // 无论什么路径已经是从0节点出发 dfs(graph, 1, n); // 开始遍历 // 输出结果 if (result.size() == 0) cout &lt;&lt; -1 &lt;&lt; endl; for (const vector&lt;int&gt; &amp;pa : result) { for (int i = 0; i &lt; pa.size() - 1; i++) { cout &lt;&lt; pa[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; pa[pa.size() - 1] &lt;&lt; endl; }} 广度搜索BFS使用场景适合于解决两个点之间的最短路径问题。 求单源最短路径，何时用BFS？何时用dijkstra？是否需要求解最短路径？→ 是 → 图的边权是否相等（或无权）？ → 是 → 用 BFS（高效简洁） → 否 → 边权是否非负？ → 是 → 用 Dijkstra 算法（贪心+优先队列） → 否 → 用 Bellman-Ford/SPFA 算法（处理负权） 思路代码模板123456789101112131415161718192021222324int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向// grid 是地图，也就是一个二维数组// visited标记访问过的节点，不要重复访问// x,y 表示开始搜索节点的下标void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) { queue&lt;pair&lt;int, int&gt;&gt; que; // 定义队列 que.push({x, y}); // 起始节点加入队列 visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点 while(!que.empty()) { // 开始遍历队列里的元素 pair&lt;int ,int&gt; cur = que.front(); que.pop(); // 从队列取元素 int curx = cur.first; int cury = cur.second; // 当前节点坐标 for (int i = 0; i &lt; 4; i++) { // 开始想当前节点的四个方向左右上下去遍历 int nextx = curx + dir[i][0]; int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标 if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue; // 坐标越界了，直接跳过 if (!visited[nextx][nexty]) { // 如果节点没被访问过 que.push({nextx, nexty}); // 队列添加该节点为下一轮要遍历的节点 visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问 } } }} 大家应该好奇，这一圈一圈的搜索过程是怎么做到的，是放在什么容器里，才能这样去遍历。很多网上的资料都是直接说用队列来实现。其实，我们仅仅需要一个容器，能保存我们要遍历过的元素就可以，那么用队列，还是用栈，甚至用数组，都是可以的。用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针。因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。如果用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历。因为栈是先进后出，加入元素和弹出元素的顺序改变了。那么广搜需要注意 转圈搜索的顺序吗？ 不需要！所以用队列，还是用栈都是可以的，但大家都习惯用队列了，所以下面的讲解用我也用队列来讲，只不过要给大家说清楚，并不是非要用队列，用栈也可以。 并查集适用场景 需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。（常用来解决连通性问题） 思路代码模板123456789101112131415161718192021222324252627class Union{private: vector&lt;int&gt; father;public:// 初始化 Union(int num){ father.resize(num); for(int i=0;i&lt;num;++i) father[i]=i; }// 并查集里寻根的过程 int find(int u){ if(u==father[u]) return u; father[u]=find(father[u]);//路径压缩 return father[u]; }// 核心// 将u-v 这条边加入并查集 void join(int u,int v){ u=find(u); v=find(v); if(u==v) return; father[u]=v; }// 判断 u 和 v是否找到同一个根 bool isSame(int u,int v){ return find(u)==find(v); }}; 模板题最小生成树概念生成树：是一个极小连通子图，它含有图中的全部顶点，但只有n-1条边。生成森林：由若干棵生成树组成，含全部顶点，但构成这些树的边是最少的。最小生成树：所有节点的最小连通子图，即：以最小的成本（边的权值）将图中所有节点链接到一起。 prim算法三部曲 第一步，选距离生成树最近节点第二步，最近节点加入生成树第三步，更新非生成树节点到生成树的距离（即更新minDist数组） 适用条件：无向图 连通图 无回路 权值无论正负模板题思路代码模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;vector&gt;#include &lt;climits&gt;using namespace std;int main() { int v, e; int x, y, k; cin &gt;&gt; v &gt;&gt; e; // 填一个默认最大值，题目描述val最大为10000 vector&lt;vector&lt;int&gt;&gt; grid(v + 1, vector&lt;int&gt;(v + 1, 10001)); while (e--) { cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; // 因为是双向图，所以两个方向都要填上 grid[x][y] = k; grid[y][x] = k; } // 所有节点到最小生成树的最小距离 vector&lt;int&gt; minDist(v + 1, 10001); // 这个节点是否在树里 vector&lt;bool&gt; isInTree(v + 1, false); // 我们只需要循环 n-1次，建立 n - 1条边，就可以把n个节点的图连在一起 for (int i = 1; i &lt; v; i++) { // 1、prim三部曲，第一步：选距离生成树最近节点 int cur = -1; // 选中哪个节点 加入最小生成树 int minVal = INT_MAX; for (int j = 1; j &lt;= v; j++) { // 1 - v，顶点编号，这里下标从1开始 // 选取最小生成树节点的条件： // （1）不在最小生成树里 // （2）距离最小生成树最近的节点 if (!isInTree[j] &amp;&amp; minDist[j] &lt; minVal) { minVal = minDist[j]; cur = j; } } // 2、prim三部曲，第二步：最近节点（cur）加入生成树 isInTree[cur] = true; // 3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新minDist数组） // cur节点加入之后， 最小生成树加入了新的节点，那么所有节点到 最小生成树的距离（即minDist数组）需要更新一下 // 由于cur节点是新加入到最小生成树，那么只需要关心与 cur 相连的 非生成树节点 的距离 是否比 原来 非生成树节点到生成树节点的距离更小了呢 for (int j = 1; j &lt;= v; j++) { // 更新的条件： // （1）节点是 非生成树里的节点 // （2）与cur相连的某节点的权值 比 该某节点距离最小生成树的距离小 // 很多录友看到自己 就想不明白什么意思，其实就是 cur 是新加入 最小生成树的节点，那么 所有非生成树的节点距离生成树节点的最近距离 由于 cur的新加入，需要更新一下数据了 if (!isInTree[j] &amp;&amp; grid[cur][j] &lt; minDist[j]) { minDist[j] = grid[cur][j]; } } } // 统计结果 int result = 0; for (int i = 2; i &lt;= v; i++) { // 不计第一个顶点，因为统计的是边的权值，v个节点有 v-1条边 result += minDist[i]; } cout &lt;&lt; result &lt;&lt; endl;} kruskal算法思路 边的权值排序，因为要优先选最小的边加入到生成树里遍历排序后的边如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合 代码模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct Edge{ int u; int v; int w;};class Union{private: vector&lt;int&gt; father;public: Union(int n){ father.resize(n+1); for(int i=1;i&lt;=n;i++) father[i]=i; } int find(int u){ if(u==father[u]) return father[u]; father[u]=find(father[u]); return father[u]; } void join(int u,int v){ u=find(u); v=find(v); if(u==v) return; father[u]=v; } bool isSame(int u,int v){ return find(u)==find(v); }};int main(){ int v,e; cin&gt;&gt;v&gt;&gt;e; vector&lt;Edge&gt; edges; for(int i=0;i&lt;e;i++){ int u,v,w; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; edges.push_back({u,v,w}); } sort(edges.begin(),edges.end(),[&amp;](const Edge a,const Edge b){ return a.w&lt;b.w; }); Union setv(v); int result=0; for(auto edge:edges){ if(!setv.isSame(edge.u,edge.v)){ setv.join(edge.u,edge.v); result+=edge.w; } } cout&lt;&lt;result;} prim与kruskal对比总结 prim维护的是节点的集合，而 Kruskal 维护的是边的集合。 Prim 算法 时间复杂度为 O(n^2)，其中 n 为节点数量，它的运行效率和图中边树无关，适用稠密图。 Kruskal算法 时间复杂度 为 nlogn，其中n 为边的数量，适用稀疏图。 拓扑排序前置概念 AOV网：用顶点表示活动的网络 AOE网：用边表示活动的网络 适用场景 给出一个 有向图，把这个有向图转成线性的排序 就叫拓扑排序。 拓扑排序也是图论中判断有向无环图的常用方法。 思路 找到入度为0 的节点，加入结果集 将该节点从图中移除 循环以上俩步 代码模板123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;using namespace std;int main(){ int N,M; cin&gt;&gt;N&gt;&gt;M; vector&lt;int&gt; inDegree(N,0); vector&lt;list&lt;int&gt;&gt; graph(N); queue&lt;int&gt; q; vector&lt;int&gt; result; for(int i=0;i&lt;M;i++){ int S,T; cin&gt;&gt;S&gt;&gt;T; graph[S].push_back(T); inDegree[T]++; } for(int i=0;i&lt;N;i++) if(inDegree[i]==0) q.push(i); while(!q.empty()){ int cur=q.front(); q.pop(); result.push_back(cur); for(int i:graph[cur]) if(--inDegree[i]==0) q.push(i); } if(result.size()==N){ for(int i=0;i&lt;N-1;i++) cout&lt;&lt;result[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;result[N-1]; }else cout&lt;&lt;-1&lt;&lt;endl;} 判断是否有环 结果集元素个数 不等于 图中节点个数，我们就可以认定图中一定有 有向环！ 时间复杂度 O(n+e) AOE网络核心定义 Ve(j)：从起点到本节点的最长的路径。意味着事件最早能够发生的时刻。 Vl(j)：不影响工程的如期完工，本节点事件必须发生的时刻。 e(ai)：活动的最早开始时间 e(ai)=Ve(j) l(ai)：活动的最迟开始时间 l(ai)=Vl(k)-dut(j,k) 关键活动：最早开始时间=最迟开始时间的活动 关键路径：从原点到汇点的最长的一条路径，或者全部由关键活动构成的路径 AOE网络关键路径求解 核心步骤：拓扑排序得到拓扑序列；按拓扑序计算Ve（事件最早发生时间）；按逆拓扑序计算Vl（事件最迟发生时间）；计算所有活动的e和l，找出关键活动；关键活动构成的路径即为关键路径。 代码模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;climits&gt;using namespace std;// 边结构体：to=邻接顶点，weight=活动持续时间struct Edge { int to, weight; Edge(int t, int w) : to(t), weight(w) {}};int main() { int N, M; // N=事件数（顶点），M=活动数（边） cin &gt;&gt; N &gt;&gt; M; vector&lt;list&lt;Edge&gt;&gt; graph(N); // 正邻接表 vector&lt;list&lt;Edge&gt;&gt; reverseGraph(N);// 逆邻接表（用于逆拓扑序计算Vl） vector&lt;int&gt; inDegree(N, 0); vector&lt;int&gt; Ve(N, 0); // 事件最早发生时间 vector&lt;int&gt; Vl(N, INT_MAX); // 事件最迟发生时间 vector&lt;int&gt; topoOrder; // 拓扑序列 queue&lt;int&gt; q; // 构建图 for (int i = 0; i &lt; M; i++) { int S, T, W; cin &gt;&gt; S &gt;&gt; T &gt;&gt; W; graph[S].emplace_back(T, W); reverseGraph[T].emplace_back(S, W); inDegree[T]++; } // 步骤1：拓扑排序 for (int i = 0; i &lt; N; i++) { if (inDegree[i] == 0) q.push(i); } while (!q.empty()) { int cur = q.front(); q.pop(); topoOrder.push_back(cur); for (auto&amp; edge : graph[cur]) { if (--inDegree[edge.to] == 0) q.push(edge.to); } } if (topoOrder.size() != N) { cout &lt;&lt; &quot;存在环，无法计算关键路径&quot; &lt;&lt; endl; return 0; } // 步骤2：计算Ve（拓扑序） for (int u : topoOrder) { for (auto&amp; edge : graph[u]) { int v = edge.to; Ve[v] = max(Ve[v], Ve[u] + edge.weight); } } // 步骤3：计算Vl（逆拓扑序） Vl[topoOrder.back()] = Ve[topoOrder.back()]; // 汇点Vl=Ve for (int i = topoOrder.size() - 2; i &gt;= 0; i--) { int u = topoOrder[i]; for (auto&amp; edge : graph[u]) { int v = edge.to; Vl[u] = min(Vl[u], Vl[v] - edge.weight); } } // 步骤4：输出关键活动和工程最短完成时间 cout &lt;&lt; &quot;关键活动（边&lt;u,v&gt;）：&quot; &lt;&lt; endl; for (int u = 0; u &lt; N; u++) { for (auto&amp; edge : graph[u]) { int v = edge.to; int e = Ve[u]; // 活动最早开始时间 int l = Vl[v] - edge.weight; // 活动最迟开始时间 if (e == l) { cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; u &lt;&lt; &quot;,&quot; &lt;&lt; v &lt;&lt; &quot;&gt; （持续时间：&quot; &lt;&lt; edge.weight &lt;&lt; &quot;）&quot; &lt;&lt; endl; } } } cout &lt;&lt; &quot;工程最短完成时间：&quot; &lt;&lt; Ve[topoOrder.back()] &lt;&lt; endl; return 0;} 最短路径dijkstra算法 模板题 朴素版dijkstra三部曲 1、选源点到哪个节点近且该节点未被访问过(源点距离源点最近，距离为0，且未被访问。)2、该最近节点被标记访问过(标记源点访问过)3、更新非访问节点到源点的距离(即更新minDist数组) 限制条件==单源==最短路，即可求一点出发到任意点的最短路径。不能出现==负数权值== 与prim算法的区别对比prim算法的三部曲：第一步，选距离生成树最近节点第二步，最近节点加入生成树第三步，更新非生成树节点到生成树的距离（即更新minDist数组）prim算法支持负数权值 代码模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;int main() { int n, m, p1, p2, val; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; grid(n + 1, vector&lt;int&gt;(n + 1, INT_MAX)); for(int i = 0; i &lt; m; i++){ cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val; grid[p1][p2] = val; } int start = 1; int end = n; // 存储从源点到每个节点的最短距离 std::vector&lt;int&gt; minDist(n + 1, INT_MAX); // 记录顶点是否被访问过 std::vector&lt;bool&gt; visited(n + 1, false); minDist[start] = 0; // 起始点到自身的距离为0 for (int i = 1; i &lt;= n; i++) { // 遍历所有节点 int minVal = INT_MAX; int cur = 1; // 1、选距离源点最近且未访问过的节点 for (int v = 1; v &lt;= n; ++v) { if (!visited[v] &amp;&amp; minDist[v] &lt; minVal) { minVal = minDist[v]; cur = v; } } visited[cur] = true; // 2、标记该节点已被访问 // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组） for (int v = 1; v &lt;= n; v++) { if (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; minDist[cur] + grid[cur][v] &lt; minDist[v]) { minDist[v] = minDist[cur] + grid[cur][v]; } } } if (minDist[end] == INT_MAX) cout &lt;&lt; -1 &lt;&lt; endl; // 不能到达终点 else cout &lt;&lt; minDist[end] &lt;&lt; endl; // 到达终点最短路径} 复杂度 时间复杂度：O(n^2) 空间复杂度：O(n^2) 如何求路径？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;int main() { int n, m, p1, p2, val; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; grid(n + 1, vector&lt;int&gt;(n + 1, INT_MAX)); for(int i = 0; i &lt; m; i++){ cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val; grid[p1][p2] = val; } int start = 1; int end = n; std::vector&lt;int&gt; minDist(n + 1, INT_MAX); std::vector&lt;bool&gt; visited(n + 1, false); minDist[start] = 0; //加上初始化 vector&lt;int&gt; parent(n + 1, -1); for (int i = 1; i &lt;= n; i++) { int minVal = INT_MAX; int cur = 1; for (int v = 1; v &lt;= n; ++v) { if (!visited[v] &amp;&amp; minDist[v] &lt; minVal) { minVal = minDist[v]; cur = v; } } visited[cur] = true; for (int v = 1; v &lt;= n; v++) { if (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; minDist[cur] + grid[cur][v] &lt; minDist[v]) { minDist[v] = minDist[cur] + grid[cur][v]; parent[v] = cur; // 记录边 } } } // 输出最短情况 for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; parent[i] &lt;&lt; &quot;-&gt;&quot; &lt;&lt; i &lt;&lt; endl; }} 打印结果： 1234567-1-&gt;11-&gt;22-&gt;33-&gt;44-&gt;52-&gt;65-&gt;7 堆优化版dijkstra优化方向用最小堆自动排序，时间缩短至logn。用邻接表优化邻接矩阵（适用于稀疏图） 前置知识堆： 一般用stl中的优先队列(priority_queue)实现。自定义堆的排序规则:一般用自定义比较结构体实现 1234567891011struct Node { int val; int weight; };// 自定义比较器：按weight降序（weight大的优先级高）struct CompareNode { bool operator()(const Node&amp; a, const Node&amp; b) { return a.weight &lt; b.weight; // comp(a,b) = a.weight &lt; b.weight }};priority_queue&lt;Node, vector&lt;Node&gt;, CompareNode&gt; pq;pq.push({1, 5}); // apq.push({2, 3}); // b 如何确定优先级？ 要理解「comp(a, b) = true 则 b 优，false 则 a 优」的底层原理，核心要抓住两个关键点：C++ priority_queue 的底层是二叉堆，堆的核心规则是「父节点优先级 ≥ 子节点优先级」；比较器 comp 的设计语义是：判断 a 是否应该被放在 b 的下方（优先级更低） —— 这是 STL 对 “严格弱序” 比较器的标准化设计。 快速验证： 目标：x(weight=3) 优先级 &gt; y(weight=5)；比较器：comp(a,b) = a.weight &gt; b.weight；计算 comp(x,y) = 3&gt;5 → false → 符合预期（x 优先级高）。 代码模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;climits&gt;using namespace std; // 小顶堆class mycomparison {public: bool operator()(const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt;&amp; rhs) { return lhs.second &gt; rhs.second; }};// 定义一个结构体来表示带权重的边struct Edge { int to; // 邻接顶点 int val; // 边的权重 Edge(int t, int w): to(t), val(w) {} // 构造函数};int main() { int n, m, p1, p2, val; cin &gt;&gt; n &gt;&gt; m; vector&lt;list&lt;Edge&gt;&gt; grid(n + 1); for(int i = 0; i &lt; m; i++){ cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val; // p1 指向 p2，权值为 val grid[p1].push_back(Edge(p2, val)); } int start = 1; // 起点 int end = n; // 终点 // 存储从源点到每个节点的最短距离 std::vector&lt;int&gt; minDist(n + 1, INT_MAX); // 记录顶点是否被访问过 std::vector&lt;bool&gt; visited(n + 1, false); // 优先队列中存放 pair&lt;节点，源点到该节点的权值&gt; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, mycomparison&gt; pq; // 初始化队列，源点到源点的距离为0，所以初始为0 pq.push(pair&lt;int, int&gt;(start, 0)); minDist[start] = 0; // 起始点到自身的距离为0 while (!pq.empty()) { // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现） // &lt;节点， 源点到该节点的距离&gt; pair&lt;int, int&gt; cur = pq.top(); pq.pop(); if (visited[cur.first]) continue; // 2. 第二步，该最近节点被标记访问过 visited[cur.first] = true; // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组） for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge // cur指向的节点edge.to，这条边的权值为 edge.val if (!visited[edge.to] &amp;&amp; minDist[cur.first] + edge.val &lt; minDist[edge.to]) { // 更新minDist minDist[edge.to] = minDist[cur.first] + edge.val; pq.push(pair&lt;int, int&gt;(edge.to, minDist[edge.to])); } } } if (minDist[end] == INT_MAX) cout &lt;&lt; -1 &lt;&lt; endl; // 不能到达终点 else cout &lt;&lt; minDist[end] &lt;&lt; endl; // 到达终点最短路径} 复杂度 时间复杂度：O(ElogE) E 为边的数量 空间复杂度：O(N + E) N 为节点的数量 Floy算法核心：动态规划求多源最短路径（对边的权值正负没有要求）思路：最好直接看三维讲解动态规划五部曲： 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 变量定义 grid[i][j][k] = m，表示 节点i 到 节点j 以[1…k] 集合中的一个节点为中间节点的最短距离为m。 递推公式定义（俩种情况）：节点i 到 节点j 的最短路径经过节点k节点i 到 节点j 的最短路径不经过节点k 遍历顺序(和积分类似，以k为基础，遍历ij面，对于每k层的每个ij点，更新其最小值)：从k=0层开始向上递推==更新== 代码模板12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;using namespace std;int main() { int n, m, p1, p2, val; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; grid(n + 1, vector&lt;vector&lt;int&gt;&gt;(n + 1, vector&lt;int&gt;(n + 1, 10005))); // 因为边的最大距离是10^4 for(int i = 0; i &lt; m; i++){ cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val; grid[p1][p2][0] = val; grid[p2][p1][0] = val; // 注意这里是双向图 } // 开始 floyd for (int k = 1; k &lt;= n; k++) { for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { grid[i][j][k] = min(grid[i][j][k-1], grid[i][k][k-1] + grid[k][j][k-1]); } } } // 输出结果 int z, start, end; cin &gt;&gt; z; while (z--) { cin &gt;&gt; start &gt;&gt; end; if (grid[start][end][n] == 10005) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; grid[start][end][n] &lt;&lt; endl; }} 结尾内容及代码有任何错误欢迎留言指正。","link":"/2026/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"}],"tags":[{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"期末复习","slug":"期末复习","link":"/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"}],"categories":[{"name":"Markdown","slug":"Markdown","link":"/categories/Markdown/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"博客搭建教学","slug":"博客搭建教学","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E5%AD%A6/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"pages":[]}
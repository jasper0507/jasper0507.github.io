{"posts":[{"title":"Gin笔记(长期更新)","text":"一. 第一个Gin应用1.完整代码演示123456789101112131415161718192021package mainimport ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)func main() { // 创建默认的Gin引擎 r := gin.Default() // 定义一个GET请求路由 r.GET(&quot;/hello&quot;, func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ &quot;message&quot;: &quot;Hello, Gin!&quot;, }) }) // 启动服务器 r.Run(&quot;:8080&quot;) // 监听并在0.0.0.0:8080上启动服务} 2.代码细致讲解 整体作用这段代码的功能是：当客户端（浏览器、Postman 等工具）向服务器发送 GET 请求，且请求路径为 /hello 时，服务器会执行后面的匿名函数，并返回一个 JSON 格式的响应。 逐部分解析 (1) r.GET(...) r：通常是一个 *gin.Engine 类型的实例（Gin 框架的核心引擎），通过 r := gin.Default() 或 r := gin.New() 创建。它负责管理所有路由、中间件、请求分发等核心功能。 GET：Gin 提供的路由注册方法，用于绑定 HTTP GET 方法 的请求。类似的还有 r.POST()（处理 POST 请求）、r.PUT()、r.DELETE() 等，对应不同的 HTTP 方法。 第一个参数 &quot;/hello&quot;：路由路径，即客户端需要访问的 URL 路径（例如 http://localhost:8080/hello）。 （2）匿名函数 func(c *gin.Context)这是 请求处理函数（也叫 Handler），当客户端访问 /hello 路径时，Gin 会自动调用这个函数来处理请求。 c *gin.Context：这是 Gin 中最核心的参数，它封装了 当前请求的所有信息（如请求参数、Header、Cookie 等）和 响应的所有操作方法（如返回 JSON、HTML、设置状态码等）。可以理解为「连接请求与响应的桥梁」。 （3）c.JSON(...)这是 gin.Context 提供的方法，用于向客户端返回 JSON 格式的响应。 第一个参数 http.StatusOK：HTTP 响应状态码。http.StatusOK 是标准库 net/http 中定义的常量，值为 200，表示「请求成功」。常见的还有 http.StatusNotFound（404，路径不存在）、http.StatusInternalServerError（500，服务器内部错误）等。 第二个参数 gin.H{&quot;message&quot;: &quot;Hello, Gin!&quot;}：要返回的 JSON 数据。 gin.H 是 Gin 提供的一个便捷类型，==本质上是 map[string]interface{} 的别名==，用于快速构建键值对结构（方便序列化为 JSON）。 这里的 {&quot;message&quot;: &quot;Hello, Gin!&quot;} 会被序列化为 JSON 字符串 {&quot;message&quot;:&quot;Hello, Gin!&quot;} 发送给客户端。 二. Gin的核心概念1. Gin提供了多种路由注册方式，对应HTTP的各种方法：123456789101112// GET请求路由router.GET(&quot;/path&quot;, HandlerFunc)// POST请求路由router.POST(&quot;/path&quot;, HandlerFunc// PUT请求路由router.PUT(&quot;/path&quot;, HandlerFunc)// DELETE请求路由router.DELETE(&quot;/path&quot;, HandlerFunc)// 任意HTTP方法router.Any(&quot;/path&quot;, HandlerFunc)// 自定义HTTP方法router.Handle(&quot;OPTIONS&quot;, &quot;/path&quot;, HandlerFunc) 2. 路径参数（Gin支持在路由路径中定义参数，使用:前缀标识）1234router.GET(&quot;/user/:id&quot;, func(c *gin.Context) { id := c.Param(&quot;id&quot;) c.JSON(200, gin.H{&quot;id&quot;: id})}) 当访问 /user/123 时，参数 id 的值将为 “123”。","link":"/2026/01/23/Gin%E7%AC%94%E8%AE%B0-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"},{"title":"Markdown快速上手语法","text":"你希望优化这份 Markdown 教程，核心要求是每个操作先展示可复制的 Markdown 源代码，再展示对应的预览效果，这样能让学习者更直观地对照学习、快速上手。我保持了你原来的整体框架，只优化了每个知识点的展示形式，同时规范了部分格式层级，让教程更清晰易懂。 一、基本语法1. 引用Markdown 源代码1234&gt; 这就是引用！&gt; 这是引用的第二行（换行无需额外操作，直接续写即可）&gt;&gt; 空一行（在引用语法内空行），可以实现引用内的段落分隔 预览效果 这就是引用！这是引用的第二行（换行无需额外操作，直接续写即可） 空一行（在引用语法内空行），可以实现引用内的段落分隔 2. 列表列表分为「无序列表」、「有序列表」、「嵌套列表」，以下分别展示： 2.1 无序列表Markdown 源代码123456789无序列表支持三种标记（+、-、*），效果一致+ 无序列表项 1（+ 标记）+ 无序列表项 2（+ 标记）- 无序列表项 1（- 标记）- 无序列表项 2（- 标记）* 无序列表项 1（* 标记）* 无序列表项 2（* 标记） 预览效果无序列表支持三种标记（+、-、*），效果一致 无序列表项 1（+ 标记） 无序列表项 2（+ 标记） 无序列表项 1（- 标记） 无序列表项 2（- 标记） 无序列表项 1（* 标记） 无序列表项 2（* 标记） 2.2 有序列表Markdown 源代码12341. 有序列表项 12. 有序列表项 23. 有序列表项 3（注：数字仅起标记作用，即使写成 1. 3. 2.，预览仍会按顺序排列） 预览效果 有序列表项 1 有序列表项 2 有序列表项 3（注：数字仅起标记作用，即使写成 1. 3. 2.，预览仍会按顺序排列） 2.3 嵌套列表Markdown 源代码1234567# 嵌套规则：子列表前空 4 个空格（或 1 个制表符）1. 一级有序列表项 1. 二级有序列表项 1. 三级有序列表项2. 另一级一级有序列表项 - 二级无序列表项（+/-/* 均可） + 三级无序列表项 预览效果嵌套规则：子列表前空 4 个空格（或 1 个制表符） 一级有序列表项 二级有序列表项 三级有序列表项 另一级一级有序列表项 二级无序列表项（+/-/* 均可） 三级无序列表项 3. TodoList（任务清单）Markdown 源代码1234- [ ] 未完成任务 a- [x] 已完成任务 b- [ ] 未完成任务 c（注：[ ] 内的空格不可省略，已完成用 [x]（小写x/大写X均可）） 预览效果 未完成任务 a 已完成任务 b 未完成任务 c（注：[ ] 内的空格不可省略，已完成用 [x]（小写x/大写X均可）） 4. 表格Markdown 源代码123456# 表格语法：表头与内容用 | 分隔，对齐方式写在第二行| 左对齐 | 中对齐 | 右对齐 ||:--- |:---: |---: || 内容1 | 内容2 | 内容3 || 下面 | 接着 | 写 |（注：第二行的 - 数量至少 3 个，| 可省略首尾，对齐标记（:）控制对齐方向） 预览效果表格语法：表头与内容用 | 分隔，对齐方式写在第二行 左对齐 中对齐 右对齐 内容1 内容2 内容3 下面 接着 写 （注：第二行的 - 数量至少 3 个， 可省略首尾，对齐标记（:）控制对齐方向） 5. 段落相关格式5.1 换行Markdown 源代码1234567# 方式1：行尾加 2 个及以上空格 + 回车第一行（行尾有2个空格） 第二行# 方式2：两行之间空一行（更推荐，可读性更强）第一行第二行 预览效果方式1：行尾加 2 个及以上空格 + 回车第一行（行尾有2个空格）第二行方式2：两行之间空一行（更推荐，可读性更强）第一行 第二行 5.2 分割线Markdown 源代码1234# 三种常用语法（效果一致，推荐用 --- 或 ***）---***___（下划线，需切换英文输入法） 预览效果三种常用语法（效果一致，推荐用 — 或 ***） 5.3 字体样式Markdown 源代码1234567891011121314151617# 先展示字体样式汇总表格| 字体效果 | Markdown 源代码 | 常用快捷键 ||----------|----------------|------------|| 斜体 | *斜体* 或 _斜体_ | Ctrl+I || 高亮 | ==高亮== | 无（部分编辑器支持） || 粗体 | **粗体** 或 __粗体__ | Ctrl+B || 斜粗体 | ***斜粗体*** 或 ___斜粗体___ | 无（组合快捷键） || 删除线 | ~~删除线~~ | 无（部分编辑器支持 Ctrl+Shift+S） || 下划线 | &lt;u&gt;下划线&lt;/u&gt; | 无（HTML 标签，Markdown 原生不支持） |# 单独展示每个字体效果的实际表现*斜体*==高亮==**粗体*****斜粗体***~~删除线~~&lt;u&gt;下划线&lt;/u&gt; 预览效果先展示字体样式汇总表格 字体效果 Markdown 源代码 常用快捷键 斜体 斜体 或 斜体 Ctrl+I 高亮 ==高亮== 无（部分编辑器支持） 粗体 粗体 或 粗体 Ctrl+B 斜粗体 斜粗体 或 斜粗体 无（组合快捷键） 删除线 删除线 无（部分编辑器支持 Ctrl+Shift+S） 下划线 下划线 无（HTML 标签，Markdown 原生不支持） 单独展示每个字体效果的实际表现斜体==高亮==粗体斜粗体删除线下划线 5.4 脚注Markdown 源代码1234这是一段话[^1]，这里还有一个脚注引用[^2]。[^1]: 这是脚注 1 的具体内容（可以放在文档任意位置，推荐放在文档末尾）[^2]: 这是脚注 2 的具体内容，支持换行和简单格式**（粗体）** 预览效果这是一段话[^1]，这里还有一个脚注引用[^2]。 [^1]: 这是脚注 1 的具体内容（可以放在文档任意位置，推荐放在文档末尾）[^2]: 这是脚注 2 的具体内容，支持换行和简单格式**（粗体）** 6. 代码代码分为「行内代码」和「代码块」，以下分别展示： 6.1 行内代码Markdown 源代码12行内代码用于标注少量代码，语法：`代码内容`，例如：我在 C++ 中常用 `#include &lt;iostream&gt;` 引入输入输出流库 预览效果行内代码用于标注少量代码，语法：代码内容，例如：我在 C++ 中常用 #include &lt;iostream&gt; 引入输入输出流库 6.2 代码块（带语言高亮）Markdown 源代码123456789# 语法：```+编程语言名称 + 回车 + 代码内容 + 回车 + ``````cpp#include &lt;iostream&gt;using namespace std;int main() { cout &lt;&lt; &quot;Hello Markdown!&quot; &lt;&lt; endl; return 0;} 123456789101112#### 预览效果语法：` ```+编程语言名称 + 回车 + 代码内容 + 回车 + ``` ````c++#include &lt;iostream&gt;using namespace std;int main() { cout &lt;&lt; &quot;Hello Markdown!&quot; &lt;&lt; endl; return 0;} 7. 超链接超链接分为「行内式」和「参考式」，以下分别展示： 7.1 行内式超链接Markdown 源代码12# 语法：[链接显示文本](链接地址 &quot;可选：鼠标悬浮提示文本&quot;)这是一个[B站教程链接](https://www.bilibili.com/video/BV1bK4y1i7BY?vd_source=fe146844c3a7d03bc7a83fe89415755d &quot;Markdown 教学视频&quot;) 预览效果语法：链接显示文本这是一个B站教程链接 7.2 参考式超链接（适合大量重复引用同一链接）Markdown 源代码12345# 步骤1：正文中引用参考标记请[点击链接][教程]查看详细内容，再次[引用同一链接][教程]。# 步骤2：定义参考标记（可放在文档任意位置，推荐末尾）[教程]: https://www.bilibili.com/video/BV1bK4y1i7BY?vd_source=fe146844c3a7d03bc7a83fe89415755d &quot;Markdown 教学视频&quot; 预览效果步骤1：正文中引用参考标记请[点击链接][教程]查看详细内容，再次[引用同一链接][教程]。 步骤2：定义参考标记（可放在文档任意位置，推荐末尾）[教程]: https://www.bilibili.com/video/BV1bK4y1i7BY?vd_source=fe146844c3a7d03bc7a83fe89415755d “Markdown 教学视频” 8. 图片Markdown 源代码1234# 基础语法：![图片描述](图片地址 &quot;可选：鼠标悬浮提示文本&quot;)# 带超链接的图片：[![图片替代文本](图片地址)](超链接地址)利用[图床网站](https://imgse.com/)上传图片获取图片地址，示例：[![pV2YO4P.jpg](https://i-blog.csdnimg.cn/img_convert/7902d7710a54639d80e0bd1b2b26b375.jpeg)](https://imgse.com/i/pV2YO4P) 预览效果利用图床网站上传图片获取图片地址，示例： 二、其他操作（进阶）1. 行内显示公式Markdown 源代码12语法：$公式内容$（需编辑器支持 LaTeX 公式渲染）行内公式示例：$f(x)=ax+b$ 预览效果语法：$公式内容$（需编辑器支持 LaTeX 公式渲染）行内公式示例：$f(x)=ax+b$ 2. 块内显示公式（独立公式块）Markdown 源代码1234567语法：$$ + 回车 + 公式内容 + 回车 + $$$$\\begin{Bmatrix}a &amp; b\\\\c &amp; d\\end{Bmatrix}$$ 预览效果语法：$$ + 回车 + 公式内容 + 回车 + $$$$\\begin{Bmatrix}a &amp; b\\c &amp; d\\end{Bmatrix}$$","link":"/2026/01/23/Markdown%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E8%AF%AD%E6%B3%95/"},{"title":"Go语言笔记(长期更新)","text":"Go语言学习笔记一、基础语法1. 自动分号规则Go语言每行后自动加分号。 2. 变量与包的使用要求定义的变量和import的包必须使用。 3. Go语言代码风格正确示例： 12345package mainimport &quot;fmt&quot;func main(){ fmt.Println(&quot;hello,word!&quot;)} 这是正确的 错误示例： 123456package mainimport &quot;fmt&quot;func main(){ fmt.Println(&quot;hello,word!&quot;)} 这是错误的 4. 变量声明的三种方式 指定变量类型，声明后若不赋值，使用默认值（int是0，string是空字符串） 123456package mainimport &quot;fmt&quot;func main(){ var i int fmt.Println(&quot;i=&quot;,i);} 类型推导 123456package mainimport &quot;fmt&quot;func main(){ var i = 10.11 fmt.Println(&quot;i=&quot;,i);} 省略var的声明 123456package mainimport &quot;fmt&quot;func main(){ i :=&quot;hello&quot; fmt.Println(&quot;i=&quot;,i);} 多变量声明 12345var ( n1=100 n2=10.11 n3=&quot;hello&quot;) 5. +号的使用规则 当左右两边都是数值型时，做加法运算 当左右两边都是字符串时，做字符串拼接 6. 数据类型基本介绍 数据类型大类 具体类型 简要基础说明 基本数据类型 布尔型（bool） 仅有true和false两个值，用于条件判断，不支持与整数转换 基本数据类型 整数型（int/uint/int8等） 存储整数，分有符号/无符号、不同位数，int为跨平台默认推荐，byte是uint8别名 基本数据类型 浮点数型（float32/float64） 存储小数，float64为默认类型，存在精度丢失问题，高精度计算需借助第三方库 基本数据类型 字符串型（string） 存储文本，UTF-8编码，天然支持多字节字符，创建后不可修改 基本数据类型 字符型（rune） int32的别名，用于存储Unicode字符（如中文），解决多字节字符存储问题 复合数据类型 数组（array） 固定长度的同类型数据集合，值类型，赋值/传参会拷贝整个数组 复合数据类型 切片（slice） 可变长度的同类型数据集合，引用类型，底层基于数组，日常开发优先使用 复合数据类型 映射（map） 键值对集合，键唯一且无序，引用类型，用于存储关联数据（如用户配置） 复合数据类型 结构体（struct） 自定义复合类型，可封装不同类型的字段，用于构建数据模型（如用户、订单） 复合数据类型 指针（pointer） 存储变量内存地址，引用类型，可修改变量原始值、优化大数据传参性能 复合数据类型 函数（function） 可执行代码块，支持作为变量/参数/返回值，用于封装可复用逻辑 复合数据类型 接口（interface） 定义方法集合，支持多态，无需显式实现，用于代码解耦和抽象化设计 复合数据类型 通道（channel） 协程间通信的管道，引用类型，自带并发安全，用于协程间传递数据 7. 整数类型 类型 有无符号 占用存储空间 表数范围 备注 int8 有 1字节 -128~127 int16 有 2字节 -2^15^~2^15^-1 int32 有 4字节 -2^31^~2^31^-1 int64 有 8字节 -2^63^~2^63^-1 uint8 无 1字节 0~255 uint16 无 2字节 0~2^16^-1 uint32 无 4字节 0~2^32^-1 uint64 无 8字节 0~2^64^-1 int 有 8字节 -2^63^~2^63^-1 uint 无 8字节 0~2^64^-1 rune 有 与int32等价 -2^31^~2^31^-1 等价int32，表示一个Unicode码 byte 无 与uint8等价 0~255 存储字符 8. 小数类型 类型 占用存储空间 表数范围 单精度float32 4字节 -3.403E38~3.403E38 双精度float64 8字节 -1.798E308~1.798E308 9. 字符类型 存储单个字符用byte保存 go语言中没有char类型 go的字符串是由字节组成的，是一段不可变的字符序列 12var str=&quot;hello&quot;str[0]='a' 这是错的 反引号`，以字符串的原生形式输出，包括换行和特殊字符 12345678910111213package mainimport &quot;fmt&quot;func main(){ i:=`package mainimport &quot;fmt&quot;func main(){ var i = 10.11 fmt.Println(&quot;i=&quot;,i);}` fmt.Println(i);} 当一行字符串太长时，需要用到多行字符串时 123str:=&quot;hello &quot;+&quot;word&quot;+&quot;hello &quot;+&quot;word&quot;+&quot;hello &quot; 10. 基础数据类型的相互转换10.1 基本类型间转换12var i int32 = 100var n1 float32 = float32(i) 10.2 转换为string类型 fmt.Sprintf(“%参数”,表达式) 使用strconv包函数 1234567891011var num1 int = 99var num2 float64 = 23.4var b1 bool = truestr1 = strconv.FormatInt(int64(num1),10)str1 = strconv.Itoa(num1)//这里的10表示十进制，想转几进制就写几str2 = strconv.FormatFloat(num2,'f',2,64)//一般用'f'控制输出，如果是'e'就按科学计数法输出。//2指的是保留二位小数//64表示float64str3 = strconv.FormatBool(b1) 10.3 string类型转基本数据类型1234567var str string = &quot;true&quot;var b boolvar num int64b,_ = strconv.ParseBool(str)//这个函数会返回俩个值(value bool,err error),因为不想获取err，使用_忽略str = &quot;11&quot;num,_ = strconv.ParseInt(str,10,64) 11. 运算符特性在go中，a++属于一条单独的语句，不属于运算符，没有++a，只有a++ 12. 流程控制12.1 基本特性 go语言中没有while，{}不能省略 相较于c语言省略了（） 12.2 if语句的使用和注意事项1234if 初始化语句; 条件表达式 { // 执行逻辑}//注意，如果使用else 必须紧跟 if 的大括号，否则会因 Go 的自动分号插入规则导致编译错误。 12.3 for range的使用1234567891011121314// 遍历 mapuser := map[string]string{ &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: &quot;20&quot;, &quot;city&quot;: &quot;北京&quot;,}// 同时获取键和值for key, value := range user { fmt.Printf(&quot;键: %s, 值: %s\\n&quot;, key, value)}// 只需要值（忽略键）for _, value := range user { fmt.Printf(&quot;值: %s\\n&quot;, value)} 12.4 switch case用法（case的值可以是变量） 支持无表达式 1234567891011score := 85switch { // 无表达式case score &gt;= 90: fmt.Println(&quot;优秀&quot;)case score &gt;= 80: fmt.Println(&quot;良好&quot;) // 输出：良好case score &gt;= 60: fmt.Println(&quot;及格&quot;)default: fmt.Println(&quot;不及格&quot;)} 简短变量声明，变量作用域为switch内部 123456switch num := 10; num % 2 { // 声明变量num，判断其除以2的余数case 0: fmt.Println(&quot;偶数&quot;) // 输出：偶数case 1: fmt.Println(&quot;奇数&quot;)} fallthrough 关键字（强制执行下一个 case） 123456789switch 2 {case 1: fmt.Println(&quot;1&quot;)case 2: fmt.Println(&quot;2&quot;) // 输出：2 fallthrough // 强制执行下一个casecase 3: fmt.Println(&quot;3&quot;) // 输出：3（因fallthrough被执行）} 支持对接口变量的动态类型进行判断（需配合 .(type) 语法） 12345678910111213func main() { var x interface{} = &quot;hello&quot; switch v := x.(type) { // 判断x的实际类型 case int: fmt.Printf(&quot;是int类型，值为%d\\n&quot;, v) case string: fmt.Printf(&quot;是string类型，值为%s\\n&quot;, v) // 输出：是string类型，值为hello case bool: fmt.Printf(&quot;是bool类型，值为%t\\n&quot;, v) default: fmt.Println(&quot;未知类型&quot;) }} 12.5 break与标签123456789outerLoop: // 标记外层循环,标签名自定义for i := 0; i &lt; 2; i++ { for j := 0; j &lt; 2; j++ { if i == 1 &amp;&amp; j == 1 { break outerLoop // 跳出outerLoop标记的外层循环 } fmt.Printf(&quot;i=%d, j=%d\\n&quot;, i, j) }} 12.6 continue与标签12345678910outerLoop: // 标记外层循环for i := 0; i &lt; 3; i++ { for j := 0; j &lt; 2; j++ { if i == 1 { // 当i=1时，跳过outerLoop标记的外层循环的当前迭代（即i=1的整个迭代） continue outerLoop } fmt.Printf(&quot;i=%d, j=%d\\n&quot;, i, j) }} 12.7 goto与标签12345678910111213// 多层循环嵌套for i := 0; i &lt; 3; i++ { for j := 0; j &lt; 3; j++ { fmt.Printf(&quot;i=%d, j=%d\\n&quot;, i, j) if i == 1 &amp;&amp; j == 1 { // 满足条件时，跳转到循环外的exit标签 goto exit } }}exit: // 循环外的标签fmt.Println(&quot;跳出所有循环&quot;) 限制: 不能跨函数跳转 不能跳过声明变量 不能跳出当前代码域 关键字 作用范围 跳转行为 适用场景 goto 同一函数内任意标签 无条件跳转到标签处 多层循环退出、统一错误处理 break 标签 标签标记的循环/代码块 终止标签标记的结构，退出执行 跳出外层循环或代码块 continue 标签 标签标记的循环 跳过标签标记的循环的当前迭代 跳过外层循环的当前迭代 二、数组1. 数组定义var 数组变量名 [元素数量]数据类型（var arr [3]int） 2. 数组核心特性数组长度是类型的一部分（var arr [3]int的类型是[3]int） 3. 数组初始化方式 var arr = [3]int{1,2,3} 或 var arr = […]int{1,2,3} arr := [3]int{1,2,3} arr := […]int{0:1, 1:23, 2:34, 3:43, 5:53} 4. 值类型与引用类型区别 值类型：改变变量副本的值的时候，不会改变变量本身的值（数组） 引用类型：改变变量副本的值的时候，会改变变量本身的值（切片） 5. 多维数组123456arr1 := [...][2]string{{&quot;北京&quot;,&quot;上海&quot;},{&quot;广州&quot;,&quot;深圳&quot;}}for _,i := range(arr1){ for _,j := range(i){ fmt.Println(j) }} 三、切片1. 切片本质本质是对底层数组的封装，包含了三个信息：数组的指针，切片的长度和切片的容量 2. 切片声明var arr = []int{1,2,3} （相比数组不用写数组长度类型，自动推导） 声明切片后，初始默认值为nil 3. 切片的创建方式3.1 基于数组的切片12345arr := [5]int {1,2,3,4,5}b := arr[:] //获取数组里的所有值c := arr[1:4] //{2，3，4} 左闭右开d := arr[2:] //{3,4,5}e := arr[:3] //{1，2，3} 3.2 基于切片的切片12a := []int {1,2,3,4}b := a[:] //以下操作同上 3.3 使用make函数构造切片var arr = make([]T, size, cap) 有默认值，不为nil 4. 切片的长度与容量 长度：它所包含元素的个数，通过len(a)获取 容量：从它第一个元素开始数，一直到其底层数组元素末尾的个数，通过cap(a)获取 5. 切片的常用操作5.1 用append()函数为切片动态添加元素每个切片指向一个底层数组，返回值为新切片 添加元素 123s := []int{10, 20}s = append(s, 30, 40, 50)fmt.Println(s) // 输出: [10 20 30 40 50] 合并俩个切片，需要展开符… 1234a := []int{1, 2, 3}b := []int{4, 5, 6}c := append(a, b...) fmt.Println(c) // 输出: [1 2 3 4 5 6] 5.2 copy函数复制切片返回实际复制的元素个数 12345src := []int{10, 20, 30, 40}dst := make([]int, 4) n := copy(dst, src) // 复制src到dstfmt.Println(&quot;复制的元素数：&quot;, n) // 输出：4fmt.Println(&quot;目标切片：&quot;, dst) // 输出：[10 20 30 40] 5.3 删除切片的元素12arr := []int{1,2,3,4}arr = append(arr[:2], arr[3:]...) //删除索引为2的元素 5.4 利用切片改变字符串的字符123456str := &quot;hello golang&quot;s := []byte(str)s[0] = 'H'str1 := &quot;你好！&quot;s1 := []rune(str1)s1[0] = '雷' 6. sort包的使用6.1 基本类型排序123sort.Ints(a []int) //int切片（升序）sort.Float64s(a []float64) //float64切片（升序）sort.Strings(a []string) //string切片（按字典序升序） 6.2 自定义类型排序（预留自定义排序扩展空间，原笔记未提供具体代码） 四、map类型1. map的声明与初始化1.1 声明（零值为 nil，未分配内存，不能直接写入数据）var 变量名 map[KeyType]ValueType 1.2 声明并初始化（两种方式） 方式A：使用 make 函数（推荐，显式指定容量可优化性能）变量名 := make(map[KeyType]ValueType, [可选容量]) 方式B：使用字面量（直接初始化并赋值） 1234变量名 := map[KeyType]ValueType{ key1: value1, key2: value2,} 2. map的核心操作2.1 添加/修改键值对123456789101112131415// 初始化 mapm := make(map[string]int)// a.添加键值对（key 不存在）m[&quot;Alice&quot;] = 95m[&quot;Bob&quot;] = 88fmt.Println(&quot;添加后:&quot;, m) // 输出：map[Alice:95 Bob:88]// b. 修改键值对（key 已存在）m[&quot;Bob&quot;] = 90 // 覆盖 Bob 的旧值 88fmt.Println(&quot;修改后:&quot;, m) // 输出：map[Alice:95 Bob:90]// c. 错误示例：nil map 写入（会 panic）var nilMap map[string]int// nilMap[&quot;Charlie&quot;] = 92 // 运行时错误：assignment to entry in nil map 2.2 获取值与判断键是否存在1234567891011121314m := map[string]int{ &quot;Alice&quot;: 95, &quot;Bob&quot;: 90,}// a. 获取存在的 keyscore1, exists1 := m[&quot;Alice&quot;]// 输出：Alice 的分数：95，key 是否存在：true// b. 获取不存在的 key（value 为 int 零值 0，exists 为 false）score2, exists2 := m[&quot;Charlie&quot;]// c. 只获取 value（忽略 exists，不推荐用于判断 key 是否存在）score3 := m[&quot;Bob&quot;] 2.3 删除键值对12345678910111213141516m := map[string]int{ &quot;Alice&quot;: 95, &quot;Bob&quot;: 90, &quot;Charlie&quot;: 85,}// a. 删除存在的 keydelete(m, &quot;Bob&quot;)// b. 删除不存在的 key（无效果，不报错）delete(m, &quot;Dave&quot;)// 输出：map[Alice:95 Charlie:85]// c. 对 nil map 调用 delete（无效果，不报错）var nilMap map[string]intdelete(nilMap, &quot;Alice&quot;) 2.4 获取map长度a := len(m) 3. map的函数类型定义在 Go 语言中，只要两个函数的参数列表类型（数量、顺序、具体类型）完全相同，且返回值列表类型（数量、顺序、具体类型）也完全相同，那么这两个函数就属于同一函数类型。 五、函数1. 函数定义func 函数名(参数) 返回值{函数体} 2. 函数参数的简写func sum(a int,b int) int{} //可简写为func sum(a,b int) int{} 3. 函数的可变参数在函数参数列表中，通过在参数类型前添加 … 来声明可变参数 1234567891011func 函数名(参数名 ...类型) 返回值类型 {函数体}//可变参数本质为对应类型的切片func sum(num ...int) { fmt.Println(num)}func main() { a := []int{1, 2, 3} sum(a...)//如果直接传入a会因（[]int与函数参数int类型不匹配而报错）} 4. return返回多个值12345678910func calu(a, b int) (int,int) { sum := a + b sub := a - b return sum, sub}func main() { a, b := calu(10, 2) fmt.Println(a, b)} 5. 返回值命名12345678910func calu(a, b int) (sum, sub int) { sum = a + b sub = a - b return}func main() { a, b := calu(10, 2) fmt.Println(a, b)} 细节：命名返回值中，return 操作的是 “返回值载体本身”；非命名返回值中，return 操作的是 “局部变量到临时载体的复制”，返回的是一个副本 6. 自定义函数类型123456789101112type add func(int, int) intfunc add_func(a int, b int) int { return a + b}func main() { var a add a = add_func result := a(1, 2) fmt.Println(result)} 7. 函数作为函数参数（基于自定义函数类型实现，可结合上述自定义函数类型示例扩展） 六、匿名函数1. 匿名函数基本定义123func(参数列表) 返回值类型 { // 函数体} 2. 匿名函数的使用场景2.1 定义后立即调用（自执行）1234567891011121314151617func main() { // 定义匿名函数并立即调用（无参数） func() { fmt.Println(&quot;匿名函数被调用了&quot;) }() // 带参数的匿名函数立即调用 func(name string) { fmt.Printf(&quot;Hello, %s!\\n&quot;, name) }(&quot;Go&quot;) // 带返回值的匿名函数立即调用（用变量接收结果） result := func(a, b int) int { return a + b }(3, 5) fmt.Println(result) } 匿名函数的函数体后紧跟的 () 是函数调用运算符，作用是立即执行该匿名函数。 2.2 赋值给变量（复用匿名函数）1234567891011func main() { // 定义匿名函数并赋值给变量 add := func(a, b int) int { return a + b } fmt.Println(add(2, 3)) // 匿名函数也可作为变量传递 var calc func(int, int) int = add fmt.Println(calc(5, 5)) } 2.3 作为函数参数（回调函数）123456789101112131415161718192021222324// 高阶函数：接收一个函数作为参数func process(nums []int, op func(int) int) []int { result := make([]int, len(nums)) for i, n := range nums { result[i] = op(n) // 调用传入的匿名函数 } return result}func main() { nums := []int{1, 2, 3, 4} // 传递匿名函数作为参数（实现“乘2”逻辑） doubled := process(nums, func(x int) int { return x * 2 }) fmt.Println(doubled) // [2 4 6 8] // 传递另一个匿名函数（实现“平方”逻辑） squared := process(nums, func(x int) int { return x * x }) fmt.Println(squared) // [1 4 9 16]} 2.4 闭包闭包特性： 捕获外部变量：闭包可以访问定义它时所在作用域的变量（无需通过参数传递）。 延长变量生命周期：被捕获的变量不会随外部函数的结束而销毁，而是与闭包绑定，直到闭包本身被销毁。 修改外部变量：闭包对捕获的变量是 “引用访问”，修改闭包内的变量会直接影响外部变量。 示例： 123456789101112131415161718192021// 工厂函数：返回一个匿名函数（闭包）func makeCounter(step int) func() int { count := 0 // 被匿名函数捕获的变量 // 返回匿名函数，每次调用自增count return func() int { count += step return count }}func main() { // 创建步长为1的计数器 counter1 := makeCounter(1) fmt.Println(counter1()) // 1 fmt.Println(counter1()) // 2 // 创建步长为3的计数器（独立状态） counter2 := makeCounter(3) fmt.Println(counter2()) // 3 fmt.Println(counter2()) // 6} count 能实现累加，本质是因为：匿名函数（闭包）通过引用捕获了外部变量 count；被捕获的 count 生命周期被延长，与闭包绑定，不会随外部函数结束而销毁；每次调用闭包时，都是在修改同一个 count 变量，因此会持续累加。 七、type的用法1. 定义自定义类型（全新类型）1234567891011121314// 基于int创建自定义类型MyInt（全新类型）type MyInt int// 基于[]int创建自定义类型IntSlice（全新类型）type IntSlice []int// 基于struct创建自定义类型User（结构体类型）type User struct { Name string Age int}// 基于函数类型创建自定义类型MathFunctype MathFunc func(int) int 八、defer1. defer的核心特性defer语句会将其后面跟随的语句进行延迟处理，在defer归属的函数即将返回时，将延迟处理的语句按defer定义的逆序进行执行（defer 的执行顺序遵循后进先出原则，当函数中执行到 defer 语句时，Go 编译器并不会立即执行 defer 后的函数，而是将该 defer 相关的信息（包括函数地址、参数值等）压入一个专门的 “defer 栈” 中。） 2. defer的参数即时求值defer 后面函数的参数会在 defer 语句定义时立即求值，而不是在执行时求值。 1234i := 10defer fmt.Println(&quot;defer 执行：&quot;, i) // 此时 i=10 已确定i = 20fmt.Println(&quot;当前 i：&quot;, i)//20 九、异常处理（panic,recover,errors）（原笔记未提供具体代码示例，预留异常处理扩展空间） 十、time包1. 基本时间获取123456789101112now := time.Now() // 获取当前时间fmt.Println(&quot;当前时间：&quot;, now)// 提取时间字段fmt.Println(&quot;年：&quot;, now.Year())fmt.Println(&quot;月：&quot;, now.Month()) // 返回 Month 类型（如 January）fmt.Println(&quot;月（数字）：&quot;, int(now.Month()))fmt.Println(&quot;日：&quot;, now.Day())fmt.Println(&quot;时：&quot;, now.Hour())fmt.Println(&quot;分：&quot;, now.Minute())fmt.Println(&quot;秒：&quot;, now.Second())fmt.Println(&quot;纳秒：&quot;, now.Nanosecond()) 2. 时间格式化与解析 Go 的时间格式化比较特殊，必须使用固定的参考时间 2006-01-02 15:04:05（这是 Go 诞生的时间，便于记忆）作为格式模板 12345678func main() { now := time.Now() // 常用格式示例 fmt.Println(now.Format(&quot;2006-01-02&quot;)) // 2023-10-05 fmt.Println(now.Format(&quot;15:04:05&quot;)) // 14:30:25 fmt.Println(now.Format(&quot;2006-01-02 15:04:05&quot;)) // 2023-10-05 14:30:25 fmt.Println(now.Format(&quot;2006年01月02日 15时04分05秒&quot;)) // 2023年10月05日 14时30分25秒} 3. 时间戳时间戳是自 1970-01-01 00:00:00 UTC 以来的秒数或纳秒 1234567891011121314func main() { now := time.Now() // 时间转时间戳（秒） sec := now.Unix() fmt.Println(&quot;秒级时间戳：&quot;, sec) // 时间转时间戳（纳秒） nsec := now.UnixNano() fmt.Println(&quot;纳秒级时间戳：&quot;, nsec) // 时间戳转时间（秒） t := time.Unix(sec, 0) fmt.Println(&quot;从秒级时间戳恢复：&quot;, t)} 4. 解析时间字符串time.Parse(layout, value string) (Time, error) 1234567891011func main() { // 解析 &quot;2023-10-05 14:30:25&quot; 格式的字符串 str := &quot;2023-10-05 14:30:25&quot; t, err := time.Parse(&quot;2006-01-02 15:04:05&quot;, str) if err != nil { fmt.Println(&quot;解析失败：&quot;, err) return } fmt.Println(&quot;解析后的时间：&quot;, t) fmt.Println(&quot;小时：&quot;, t.Hour()) // 14} 5. 时间间隔123456789101112131415161718func main() { now := time.Now() // 1小时后 later := now.Add(1 * time.Hour) fmt.Println(&quot;1小时后：&quot;, later) // 30分钟前 earlier := now.Add(-30 * time.Minute) fmt.Println(&quot;30分钟前：&quot;, earlier) // 计算两个时间的间隔 diff := later.Sub(earlier) fmt.Println(&quot;间隔：&quot;, diff) // 1h30m0s fmt.Println(&quot;间隔（分钟）：&quot;, diff.Minutes()) // 90 // 时间比较 fmt.Println(&quot;now 在 later 之前吗？&quot;, now.Before(later)) // true} 6. 睡眠与计时：Sleep() 和 Since() time.Sleep(d Duration)：让当前 goroutine 暂停指定时间。time.Since(t Time)：计算从 t 到现在的间隔（等价于time.Now().Sub(t)），常用于计时。 12345678910111213func main() { // 睡眠1秒 fmt.Println(&quot;开始睡眠...&quot;) time.Sleep(1 * time.Second) fmt.Println(&quot;睡眠结束&quot;) // 计时：统计代码执行耗时 start := time.Now() // 模拟耗时操作 for i := 0; i &lt; 100000000; i++ {} elapsed := time.Since(start) // 等价于 time.Now().Sub(start) fmt.Printf(&quot;操作耗时：%v\\n&quot;, elapsed) // 如 12ms} 7. 定时器：time.Ticker 和 time.After()用于周期性执行任务或延迟执行任务 123456789101112131415func main() { // 创建一个每秒触发一次的定时器 ticker := time.NewTicker(1 * time.Second) defer ticker.Stop() // 程序结束时停止定时器 // 执行5次后退出 count := 0 for t := range ticker.C { count++ fmt.Printf(&quot;第%d次触发：%v\\n&quot;, count, t.Format(&quot;15:04:05&quot;)) if count &gt;= 5 { break } }} 十一、指针，make与new1. Go指针特性Go中，禁止一切指针运算，自动进行内存管理 2. new与make的核心区别2.1 返回类型 new(T)：返回指向类型 T 的指针（*T），即分配的内存地址。 make(T, args)：返回类型 T 本身（非指针），因为这三种引用类型（slice/map/chan）本身就隐式包含了指针（指向底层数据结构）。 2.2 初始化行为 new(T)：仅做两件事：1、为类型 T 分配一块内存；2、将内存初始化为 T 的零值（如 int 零值为 0，string 零值为 “”，结构体零值为所有字段零值）。它不会对内存做额外的 “初始化操作”（比如不会初始化切片的底层数组、map 的哈希表等）。 make(T, args)：不仅分配内存，还会初始化该引用类型的内部数据结构（这是它仅用于 slice/map/chan 的原因）： 对 slice：初始化底层数组，并设置长度（len）和容量（cap）； 对 map：初始化哈希表结构，使其可以直接存储键值对； 对 chan：初始化通道的缓冲区等内部结构，使其可以直接收发数据。 十二、结构体1. 结构体初始化方式 初始化方式 语法示例 变量类型 适用场景 零值初始化 var p Person Person 需默认零值，后续手动赋值 键值对初始化&lt;值类型&gt; p:=Person{Name: &quot;Alice&quot;} Person 需指定部分/全部字段，值类型 键值对初始化&lt;指针类型&gt; p:=&amp;Person{Name: &quot;Bob&quot;} *Person 需指针类型，避免值拷贝 位置参数初始化 p:=Person{&quot;Charlie&quot;, 18} Person 字段少且顺序固定的简单结构体 new 函数初始化 p:=new(Person) *Person 需指针类型，先零值后赋值 嵌套结构体初始化 s:=Student{Info: Person{...}} 外层结构体类型 包含嵌套字段的结构体 2. 结构体字段访问控制字段名首字母大写（如 Name）时，该字段是导出字段，可被其他包访问；首字母小写（如 age）时，是未导出字段，仅能在当前包内访问。 3. 为结构体定义方法123func (接收者变量 接收者类型) 方法名(参数列表) (返回值列表) { // 方法体（可通过接收者访问结构体字段）} 十三、json转换1. 结构体与JSON的相互转换12345678910111213141516171819202122package mainimport ( &quot;encoding/json&quot; &quot;fmt&quot;)type student struct { Name string Age int}func main() { s := []student{ {&quot;Alice&quot;, 20}, {&quot;Bob&quot;, 30}, } fmt.Println(s)//输出：[{Alice 20} {Bob 30}] a, _ := json.Marshal(s)//返回[]byte类型和error fmt.Println(string(a))//输出：[{&quot;Name&quot;:&quot;Alice&quot;,&quot;Age&quot;:20},{&quot;Name&quot;:&quot;Bob&quot;,&quot;Age&quot;:30}] var b []student _ = json.Unmarshal(a, &amp;b)//a为[]byte类型，要把b的地址传入，返回error fmt.Println(b)//输出：[{Alice 20} {Bob 30}]} 2. 结构体标签（JSON字段重命名）123456789101112type student struct { Name string `json:&quot;name&quot;` Age int `json:&quot;age&quot;`}func main() { s := []student{ {&quot;Alice&quot;, 20}, {&quot;Bob&quot;, 30}, } a, _ := json.Marshal(s) //返回[]byte类型和error fmt.Println(string(a)) //输出：[{&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:20},{&quot;name&quot;:&quot;Bob&quot;,&quot;age&quot;:30}]} 十四、接口1. 接口的核心概念接口是一种抽象数据类型，是一组函数的集合，不能包含任何变量。在Golang中，接口中的所有方法都没有方法体，接口定义了一个对象的行为规范，只定义规范不实现，体现了多态和高内聚低耦合的思想，接口变量存储的是 “类型信息 + 值” 的抽象组合。 2. 接口定义12345type 接口名 interface { 方法名1(参数列表) 返回值列表 方法名2(参数列表) 返回值列表 // ... 更多方法} 3. 接口使用示例12345678910111213141516171819202122232425262728293031323334package mainimport &quot;fmt&quot;type Usber interface { GetName() string}type phone struct { Name string}func (p phone) GetName() string { return p.Name}type computer struct { Name string}func (c computer) GetName() string { return c.Name}func check_usb(usb Usber) { fmt.Println(usb.GetName(), &quot;check_usb&quot;)}func main() { p := phone{&quot;华为&quot;} c := computer{&quot;拯救者&quot;} check_usb(p) check_usb(c) var usb Usber usb = p//p实现接口 fmt.Println(usb.GetName())} 4. 值接受者和指针接受者的区别 方法接收者类型 实现接口的类型（可赋值给接口变量） 原理 值接收者(func(s T) Method()) 结构体的值类型(T)和指针类型(*T)都实现接口 指针类型（*T）可以自动解引用为值类型（T），因此能调用值接收者的方法 指针接收者(func (s *T) Method()) 只有结构体的指针类型（*T）实现接口，值类型（T）不实现 值类型（T）无法自动转为指针类型（*T），因此不能调用指针接收者的方法 5. 空接口5.1 空接口定义1234// 空接口的定义（没有任何方法）type EmptyInterface interface{}// 更常用的简写形式（直接使用 interface{}）var any interface{} 5.2 空接口用法 空接口的用法主要围绕 “存储任意类型” 和 “传递任意类型” 作为变量存储任意类型的值 12345678910111213var any interface{} // 声明空接口变量// 存储基本类型any = 100 // 存储intfmt.Printf(&quot;类型: %T, 值: %v\\n&quot;, any, any) // 输出：类型: int, 值: 100any = &quot;hello&quot; // 存储stringfmt.Printf(&quot;类型: %T, 值: %v\\n&quot;, any, any) // 输出：类型: string, 值: hello// 存储复合类型any = []int{1, 2, 3} // 存储切片fmt.Printf(&quot;类型: %T, 值: %v\\n&quot;, any, any) // 输出：类型: []int, 值: [1 2 3]// 存储结构体type Person struct{ Name string }any = Person{Name: &quot;张三&quot;}fmt.Printf(&quot;类型: %T, 值: %v\\n&quot;, any, any) // 输出：类型: main.Person, 值: {张三} 作为函数参数接收任意类型（预留函数参数示例扩展空间） 作为返回值返回任意类型（预留返回值示例扩展空间） 作为容器存储多种类型的元素 123456789101112// 空接口切片：可存储任意类型的元素data := []interface{}{ &quot;苹果&quot;, // string 3.14, // float64 true, // bool []int{1, 2}, // 切片 map[string]int{&quot;a&quot;: 1}, // 映射}// 遍历并打印元素类型和值for i, v := range data { fmt.Printf(&quot;索引%d: 类型=%T, 值=%v\\n&quot;, i, v, v)} 类型断言 a. value, ok := 空接口变量.(目标类型) 若转换成功，value 是具体类型的值，ok 为 true；若转换失败，value 是目标类型的零值，ok 为 false（避免直接转换导致 panic）。 12345678910111213var any interface{} = &quot;hello&quot;// 安全的类型断言（判断是否为string）if s, ok := any.(string); ok { fmt.Println(&quot;是字符串:&quot;, s) // 输出：是字符串: hello} else { fmt.Println(&quot;不是字符串&quot;)}// 若尝试转换为错误类型（如int）if i, ok := any.(int); ok { fmt.Println(&quot;是整数:&quot;, i)} else { fmt.Println(&quot;不是整数&quot;) // 输出：不是整数} b. x.(type)，只能结合switch语句使用 1234567891011121314151617func checkType(v interface{}) { switch v.(type) { // 类型分支语法：v.(type) case int: fmt.Println(&quot;这是int类型&quot;) case string: fmt.Println(&quot;这是string类型&quot;) case []int: fmt.Println(&quot;这是[]int类型&quot;) default: fmt.Println(&quot;未知类型&quot;) }}func main() { checkType(100) // 输出：这是int类型 checkType(&quot;hello&quot;) // 输出：这是string类型 checkType([]int{1,2}) // 输出：这是[]int类型} 十五、goroutine1. goroutine启动语法用go关键字启动 goroutine 12345678910111213// 定义一个要在goroutine中执行的函数func sayHello(name string) { for i := 0; i &lt; 3; i++ { fmt.Printf(&quot;Hello, %s! 第%d次\\n&quot;, name, i+1) time.Sleep(100 * time.Millisecond) // 模拟耗时操作 }}func main() { // 启动一个goroutine执行sayHello(&quot;goroutine&quot;) go sayHello(&quot;goroutine&quot;) // 主goroutine执行sayHello(&quot;main&quot;) sayHello(&quot;main&quot;)} 2. 等待goroutine完成：使用sync.WaitGroup1234567891011121314151617// 接收WaitGroup指针，避免值拷贝func task(id int, wg *sync.WaitGroup) { defer wg.Done() // 任务完成后，通知WaitGroup计数器减1 fmt.Printf(&quot;任务%d开始\\n&quot;, id) time.Sleep(500 * time.Millisecond) // 模拟任务耗时 fmt.Printf(&quot;任务%d完成\\n&quot;, id)}func main() { var wg sync.WaitGroup // 启动5个goroutine for i := 1; i &lt;= 5; i++ { wg.Add(1) // 每启动一个goroutine，计数器加1 go task(i, &amp;wg) } wg.Wait() // 阻塞主goroutine，直到计数器减为0（所有任务完成） fmt.Println(&quot;所有任务执行完毕，程序退出&quot;)} 十六、channel(引用类型)1. channel定义12ch := make(chan 数据类型) //无缓冲channel（同步channel）ch := make(chan 数据类型, 缓冲区大小) //有缓冲channel（异步channel） 2. channel使用2.1 发送数据（ch&lt;-数据）1234ch := make(chan int)go func() { ch &lt;- 100 // 向channel发送100}() 2.2 接收数据（&lt;-ch 或 value, ok &lt;- ch）1234567891011121314151617181920212223ch := make(chan int, 1)ch &lt;- 100// a.基本接收v1 := &lt;-chfmt.Println(v1) // 输出：100// b.带状态接收（channel已空，此时关闭）close(ch)v2, ok := &lt;-chfmt.Println(v2, ok) // 输出：0 false（0是int的零值，ok为false表示channel已关闭）// for range 接收 channelch := make(chan int, 3)ch &lt;- 1ch &lt;- 2ch &lt;- 3close(ch) // 循环接收所有数据for v := range ch { fmt.Println(v) // 依次输出1、2、3} 2.3 单向channel（限制操作方向）123456789101112131415161718// 只发送channel作为参数（函数内只能向ch发送数据）func sender(ch chan&lt;- int) { ch &lt;- 100 // &lt;-ch // 编译错误：不能从只发送channel接收}// 只接收channel作为参数（函数内只能从ch接收数据）func receiver(ch &lt;-chan int) { fmt.Println(&lt;-ch) // ch &lt;- 200 // 编译错误：不能向只接收channel发送}func main() { ch := make(chan int) go sender(ch) // 普通channel可隐式转换为单向channel receiver(ch) close(ch)} 十七、select1. select基本用法12345678910select {case &lt;-ch1: // 取出通道ch1的数据 // 处理逻辑case ch2 &lt;- data: // 向通道ch2发送数据 // 处理逻辑case &lt;-ch3: // 其他通道操作 // 处理逻辑default: // 可选，所有case都无法执行时执行 // 避免阻塞的逻辑} 2. select适用场景2.1 同时处理多个通道的并发事件12345678910func handleEvents(reqChan chan Request, notifyChan chan Notify) { for { select { case req := &lt;-reqChan: // 处理用户请求 processRequest(req) case notify := &lt;-notifyChan: // 处理系统通知 processNotify(notify) } }} 2.2 协调多个通道的同步12345678910111213141516171819func main() { c1 := make(chan int, 10) c2 := make(chan int, 10) for i := 1; i &lt; 10; i++ { c1 &lt;- i c2 &lt;- i } for { select { case v := &lt;-c1: // 接收一次，保存到变量v fmt.Println(&quot;从c1传出&quot;, v) case v := &lt;-c2: // 接收一次，保存到变量v fmt.Println(&quot;从c2传出&quot;, v) default: fmt.Println(&quot;执行结束&quot;) return } }} 十八、互斥锁（Mutex）1. 互斥锁使用案例1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;sync&quot;)var ( count int // 共享资源：计数器 mu sync.Mutex // 互斥锁，保护count wg sync.WaitGroup // 用于等待所有协程完成)// 对计数器执行累加操作func increment() { defer wg.Done() // 协程完成后通知WaitGroup mu.Lock() // 加锁：独占访问count count++ // 操作共享资源 mu.Unlock() // 解锁：允许其他协程访问}func main() { wg.Add(1000) // 注册1000个协程 // 启动1000个协程同时累加 for i := 0; i &lt; 1000; i++ { go increment() } wg.Wait() // 等待所有协程完成 fmt.Println(&quot;最终计数：&quot;, count) // 输出：1000（正确）} 2. 读写锁：sync.RWMutexGo 语言通过 sync.RWMutex 实现读写锁，核心方法如下: 方法 作用 适用场景 RLock() 获取读锁(多个协程可同时获取) 读取共享资源时 RUnlock() 释放读锁（与 RLock() 配对使用） 读操作完成后 Lock() 获取写锁（仅一个协程可获取） 修改共享资源时 Unlock() 释放写锁(与 Lock() 配对使用) 写操作完成后 2.1 未使用读锁的问题（脏读示例）123456789101112131415161718192021222324252627282930313233343536373839// 共享资源：订单信息（金额和状态）type Order struct { Amount int // 金额 Status string // 状态：&quot;未支付&quot;/&quot;已支付&quot;}var ( order = Order{Amount: 100, Status: &quot;未支付&quot;} rwMu sync.RWMutex // 读写锁 wg sync.WaitGroup)// 读操作：不使用读锁（直接读取）func readOrder(id int) { defer wg.Done() // 不获取读锁，直接访问共享资源 time.Sleep(10 * time.Millisecond) // 模拟读耗时 fmt.Printf(&quot;读协程%d: 金额=%d, 状态=%s\\n&quot;, id, order.Amount, order.Status)}// 写操作：使用写锁保护（正确加锁）func payOrder() { defer wg.Done() rwMu.Lock() // 获取写锁（阻止其他写操作） defer rwMu.Unlock() // 释放写锁 // 分步更新订单（先改金额，再改状态，模拟实际业务的多步操作） order.Amount = 0 // 金额清零（支付完成） time.Sleep(50 * time.Millisecond) // 模拟中间处理耗时 order.Status = &quot;已支付&quot; // 更新状态 fmt.Println(&quot;写协程：支付完成，金额=0，状态=已支付&quot;)}func main() { // 启动5个读协程（无读锁） wg.Add(5) for i := 1; i &lt;= 5; i++ { go readOrder(i) } // 启动1个写协程（用写锁） wg.Add(1) go payOrder() wg.Wait()} 可能的输出（存在脏读）：读协程1: 金额=100, 状态=未支付 // 写操作前正常读取读协程2: 金额=0, 状态=未支付 // 脏读（金额已改，状态未改）读协程3: 金额=0, 状态=未支付 // 脏读写协程：支付完成，金额=0，状态=已支付读协程4: 金额=0, 状态=已支付 // 写操作后正常读取读协程5: 金额=0, 状态=已支付 十九、反射1. 获取类型信息（reflect.Type）12345678910111213141516171819202122232425262728type User struct { Name string `json:&quot;name&quot;` Age int `json:&quot;age&quot;`}func (u User) Hello() string { return &quot;hello, &quot; + u.Name}func main() { u := User{Name: &quot;张三&quot;, Age: 20} t := reflect.TypeOf(u) // 获取u的类型信息 // 1. 基本类型信息 fmt.Println(&quot;类型名称:&quot;, t.Name()) // 输出：User（结构体名称） fmt.Println(&quot;类型种类:&quot;, t.Kind()) // 输出：struct（类型的种类，如struct、int、slice等） // 2. 结构体字段信息（需先判断Kind为struct） if t.Kind() == reflect.Struct { for i := 0; i &lt; t.NumField(); i++ { field := t.Field(i) fmt.Printf(&quot;字段名: %s, 类型: %s, 标签: %s\\n&quot;, field.Name, // 字段名称 field.Type, // 字段类型 field.Tag) // 字段标签（如json标签） } } // 3. 方法信息 fmt.Println(&quot;方法数量:&quot;, t.NumMethod()) // 输出：1（User有一个Hello方法） method := t.Method(0) fmt.Println(&quot;方法名:&quot;, method.Name) // 输出：Hello} 2. 获取值信息（reflect.Value）12345678910111213141516171819202122func main() { num := 100 v := reflect.ValueOf(num) // 获取num的值信息 // 1. 基本值访问 fmt.Println(&quot;值:&quot;, v.Int()) // 输出：100（Int()适用于int类型，类似有Float()、String()等） fmt.Println(&quot;是否可设置:&quot;, v.CanSet()) // 输出：false（因为v是num的副本，不是指针） // 2. 修改值（需通过指针获取可设置的Value） numPtr := &amp;num vPtr := reflect.ValueOf(numPtr).Elem() // Elem()获取指针指向的元素 fmt.Println(&quot;指针元素是否可设置:&quot;, vPtr.CanSet()) // 输出：true vPtr.SetInt(200) // 修改值 fmt.Println(&quot;修改后num:&quot;, num) // 输出：200 // 3. 调用方法（以User为例） u := User{Name: &quot;张三&quot;, Age: 20} vUser := reflect.ValueOf(u) method := vUser.MethodByName(&quot;Hello&quot;) // 通过名称获取方法 if method.IsValid() { // 调用无参方法（参数用空切片） result := method.Call([]reflect.Value{}) fmt.Println(&quot;方法返回值:&quot;, result[0].String()) // 输出：hello, 张三 }} 3. 类型断言与反射结合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354type User struct { Name string Age int}// 处理任意类型的变量（结合反射和类型断言）func processData(data interface{}) { // 第一步：用反射获取类型和值的基本信息 t := reflect.TypeOf(data) v := reflect.ValueOf(data) fmt.Printf(&quot;反射分析：类型=%s，种类=%s\\n&quot;, t, t.Kind()) // 第二步：根据反射的Kind，用类型断言处理具体类型 switch t.Kind() { case reflect.Int: // 类型断言：转换为int if num, ok := data.(int); ok { fmt.Printf(&quot;处理int：%d + 10 = %d\\n&quot;, num, num+10) } case reflect.String: // 类型断言：转换为string if str, ok := data.(string); ok { fmt.Printf(&quot;处理string：长度=%d，内容=%s\\n&quot;, len(str), str) } case reflect.Struct: // 反射：获取结构体字段信息 fmt.Println(&quot;结构体字段：&quot;) for i := 0; i &lt; t.NumField(); i++ { fmt.Printf(&quot; 字段名：%s，类型：%s\\n&quot;, t.Field(i).Name, t.Field(i).Type) } // 类型断言：转换为具体结构体（如User） if user, ok := data.(User); ok { fmt.Printf(&quot;处理User：%s今年%d岁\\n&quot;, user.Name, user.Age) } case reflect.Slice: // 反射：获取切片元素类型 elemType := t.Elem() fmt.Printf(&quot;切片元素类型：%s\\n&quot;, elemType) // 类型断言：转换为[]int（假设切片可能是[]int） if nums, ok := data.([]int); ok { sum := 0 for _, n := range nums { sum += n } fmt.Printf(&quot;处理[]int：总和=%d\\n&quot;, sum) } default: fmt.Println(&quot;不支持的类型&quot;) }}func main() { processData(100) // 处理int processData(&quot;hello&quot;) // 处理string processData(User{Name: &quot;张三&quot;, Age: 20}) // 处理结构体 processData([]int{1, 2, 3}) // 处理切片}","link":"/2026/01/23/Go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"},{"title":"git新手入门参考","text":"Git 零基础学习笔记目录 Git 安装配置详细教程 前置知识：Git常用Linux命令 Git 核心理论 Git 基础操作命令 Git 分支操作 参考资料 1. Git 安装与配置安装配置参考文档 Git 安装配置详细教程 2. 前置知识：Git常用Linux命令Git操作依赖Linux终端命令，以下是高频使用的命令分类整理： 2.1 目录操作命令 命令 功能描述 基本语法 示例 pwd 显示当前工作目录的绝对路径 pwd pwd → 输出：/home/user/git-learn cd 切换工作目录 cd [目录路径] 1. cd ~ → 回到当前用户主目录2. cd .. → 回到上级目录3. cd /home/user → 切换到指定绝对路径 ls 列出目录下的文件和子目录 ls [选项] [目录] 1. ls → 简单列出文件2. ls -l → 详细列表（权限、大小、时间等）3. ls -a → 显示隐藏文件（以.开头的文件，如.git） mkdir 创建新目录 mkdir [选项] 目录名 1. mkdir my-blog → 创建单级目录2. mkdir -p dir1/dir2/dir3 → 递归创建多级目录 rmdir 删除空目录 rmdir [选项] 目录名 rmdir empty-dir → 删除空目录（非空目录需用rm -r） 2.2 文件操作命令 命令 功能描述 基本语法 示例 touch 创建空文件或更新文件的时间戳 touch 文件名 touch README.md → 创建空的README文件 cat 查看文件内容（适合小文件） cat [选项] 文件名 1. cat README.md → 输出文件全部内容2. cat file1.txt file2.txt &gt; file3.txt → 合并两个文件到file3 cp 复制文件或目录 cp [选项] 源路径 目标路径 1. cp README.md docs/ → 复制文件到docs目录2. cp -r dir1 dir2 → 递归复制整个目录 mv 移动/重命名文件或目录 mv [选项] 源路径 目标路径 1. mv old.txt new.txt → 重命名文件2. mv new.txt docs/ → 移动文件到docs目录 rm 删除文件或目录（谨慎使用） rm [选项] 路径 1. rm test.txt → 删除单个文件2. rm -r dir1 → 递归删除目录及内容3. rm -rf dir1 → 强制删除（忽略提示，慎用） tail 查看文件尾部内容（常用于日志） tail [选项] 文件名 1. tail -n 10 README.md → 查看最后10行2. tail -f app.log → 实时监控文件变化（按Ctrl+C退出） 2.3 权限管理命令Git仓库的文件权限会影响提交和拉取，核心命令如下： 命令 功能描述 基本语法 示例 chmod 修改文件/目录的权限 chmod [权限值/符号] 路径 1. chmod 755 script.sh → 所有者读写执行，其他用户读执行2. chmod +x script.sh → 给所有用户添加执行权限 chown 修改文件/目录的所有者和所属组 chown [选项] 所有者:所属组 路径 chown user:user-group my-file.txt → 修改文件所有者为user，组为user-group 2.4 查找与搜索命令在Git仓库中搜索内容/文件时高频使用： 命令 功能描述 基本语法 示例 find 按路径/名称/类型查找文件 find [搜索路径] [条件] 1. find . -name &quot;*.md&quot; → 在当前目录下查找所有md文件2. find /home -type d -name &quot;git*&quot; → 查找所有以git开头的目录 grep 在文件中搜索指定字符串 grep [选项] 关键词 文件名 1. grep &quot;git&quot; README.md → 在文件中搜索git关键词2. grep -r &quot;hello&quot; ./ → 递归搜索当前目录下所有文件中的hello diff 对比两个文件的内容差异 diff [选项] 文件1 文件2 diff old.txt new.txt → 显示两个文件的差异（和git diff原理类似） 2.5 压缩与解压命令Git备份/下载资源时常用： 命令 功能描述 基本语法 示例 tar 打包/解压文件（最常用） tar [选项] 压缩包名 源文件/目录 1. tar -zcvf my-git.tar.gz ./ → 打包并压缩当前目录2. tar -zxvf my-git.tar.gz → 解压压缩包到当前目录 2.6 Git协作相关命令用于和远程Git仓库（GitHub/Gitee）交互： 命令 功能描述 基本语法 示例 ssh 连接远程服务器（克隆私有仓库时用） ssh [用户名]@[服务器地址] ssh git@github.com → 测试与GitHub的SSH连接 scp 跨机器传输文件 scp [选项] 源文件 目标地址 scp local-file.txt user@server:/home/user/ → 本地文件传到远程服务器 2.7 其他常用命令 命令 功能描述 基本语法 示例 echo 输出内容到终端或文件 echo [内容] 1. echo &quot;Hello Git&quot; → 终端输出字符串2. echo &quot;test&quot; &gt; test.txt → 写入内容到文件（覆盖原有内容） man 查看命令的官方手册（新手必备） man 命令名 man git → 查看git的详细帮助文档man ls → 查看ls命令的所有选项 clear 清空终端屏幕 clear clear → 一键清空当前终端内容 3. Git 核心理论3.1 Git 四个工作区域 工作区（Working Directory）：即本地电脑中可见的文件目录，是日常编写代码、修改文件的区域。工作区的文件状态分为“未跟踪”和“已跟踪”，未跟踪文件是指从未被Git管理过的文件。 暂存区（Stage/Index）：位于.git目录下的index文件中，用于临时存储工作区中已修改并准备提交的文件。暂存区相当于“缓冲区”，可将多个修改分批暂存，再一次性提交到本地仓库，便于灵活管理提交内容。 本地仓库（Local Repository）：即.git隐藏目录，包含了所有版本的提交记录、分支信息等核心数据，是Git版本控制的核心。提交到本地仓库的文件会形成历史版本，可随时回退到任意版本。 远程仓库（Remote Repository）：位于服务器上的仓库（如GitHub、Gitee），用于多人协作共享代码。本地仓库可与远程仓库同步，实现代码推送（push）和拉取（pull），完成协作开发。 流转关系：工作区修改 → git add 到暂存区 → git commit 到本地仓库 → git push 到远程仓库；反之，远程仓库代码可通过 git pull 拉取到本地仓库，再同步到工作区。 3.2 Git 文件的四种状态 未跟踪（Untracked）：文件在工作区，但从未执行过git add命令，Git不管理该文件。执行git add后，状态变为“已暂存”。 已暂存（Staged）：文件已存入暂存区，等待提交到本地仓库。执行git commit后，状态变为“已提交”；若修改已暂存的文件，会同时存在“已暂存”和“已修改”状态，需重新执行git add更新暂存区。 已提交（Committed）：文件已提交到本地仓库，形成历史版本。此时文件在本地仓库中是稳定的，可通过git reset回退版本，或通过git push推送到远程仓库。 已修改（Modified）：文件在工作区被修改过，但尚未暂存。执行git add可将其转为“已暂存”状态；执行git checkout – 文件名可丢弃修改，回到“已提交”或“已暂存”状态。 可通过git status命令随时查看文件当前状态，明确下一步操作方向。 4. Git 基础操作命令4.1 仓库初始化与克隆 命令 功能描述 示例 git init 初始化本地Git仓库 git init → 在当前目录创建.git隐藏目录 git clone [url] 克隆远程仓库到本地 git clone https://github.com/username/repo.git → 克隆远程仓库 4.2 文件状态与修改查看 命令 功能描述 示例 git status [文件] 查看文件/所有文件的状态 1. git status test.txt → 查看指定文件状态2. git status → 查看所有文件状态 git diff [文件] 查看文件的具体修改内容 git diff test.txt → 查看test.txt的修改内容 4.3 暂存与提交 命令 功能描述 示例 git add [文件] 添加指定文件到暂存区 git add test.txt → 添加单个文件 git add . 添加所有修改的文件到暂存区 git add . → 批量添加所有文件 git commit -m &quot;提交信息&quot; 提交暂存区内容到本地仓库 git commit -m &quot;新增test.txt文件&quot; → 提交并添加描述 4.4 版本日志与回退 命令 功能描述 示例 git log 显示从近到远的提交日志（完整信息） git log → 查看所有提交记录 git log --pretty=oneline 精简显示提交日志（仅版本号+描述） git log --pretty=oneline → 简化日志输出 git reflog 显示所有操作的命令日志（含回退记录） git reflog → 查看所有Git操作记录 git reset --hard HEAD^ 回退到上一个版本（已提交状态） git reset --hard HEAD^ → 彻底回退到上个版本 git reset --soft HEAD^ 回退到上一个版本（未提交状态） git reset --soft HEAD^ → 保留修改，回到未提交状态 git reset --mixed HEAD^ 回退到上一个版本（已暂存未提交） git reset --mixed HEAD^ → 回到暂存后未提交状态 git reset --hard [版本号] 回退到指定版本 git reset --hard 1094a → 回退到版本号为1094a的版本 备注：HEAD表示当前版本，HEAD^=上一版本，HEAD~100=往上100个版本 4.5 撤销修改与删除文件 命令 功能描述 适用场景 git checkout -- [文件] 丢弃工作区的修改 1. 文件仅在工作区修改，未暂存 → 回到版本库状态2. 文件已暂存后又修改 → 回到暂存后的状态 git reset HEAD [文件] 撤销暂存区的修改（放回工作区） 文件已添加到暂存区，想撤销暂存 git rm [文件] 删除版本库中的文件 git rm test.txt &amp;&amp; git commit -m &quot;remove test.txt&quot; → 删除文件并提交 撤销修改场景总结： 场景1：仅改乱工作区 → git checkout -- 文件 场景2：改乱工作区+已暂存 → 先git reset HEAD 文件，再执行场景1 场景3：已提交错误版本 → 用git reset --hard回退（未推送到远程时可用） 4.6 远程仓库交互 命令 功能描述 示例 git remote add origin [远程地址] 关联远程仓库（origin为默认名称） git remote add origin git@github.com:username/repo.git git push -u origin main 第一次推送main分支到远程（-u绑定关联） git push -u origin main → 推送本地main分支到远程 git push origin main 后续推送本地修改到远程main分支 git push origin main → 日常推送更新 git remote -v 查看已关联的远程仓库信息 git remote -v → 显示远程仓库的fetch/push地址 git remote rm origin 删除已关联的远程仓库 git remote rm origin → 解除和远程仓库的关联 5. Git 分支操作5.1 分支基础命令 命令 功能描述 示例 git branch 查看所有本地分支（*标记当前分支） git branch → 列出所有分支 git branch [分支名] 创建新分支 git branch test → 创建test分支 git checkout [分支名] 切换分支（旧语法） git checkout test → 切换到test分支 git switch [分支名] 切换分支（新语法，推荐） git switch test → 切换到test分支 git checkout -b [分支名] 创建+切换分支（旧语法） git checkout -b test → 创建并切换到test分支 git switch -c [分支名] 创建+切换分支（新语法，推荐） git switch -c test → 创建并切换到test分支 git merge [分支名] 合并指定分支到当前分支 git merge test → 把test分支合并到当前分支 git branch -d [分支名] 删除本地分支（需先切换到其他分支） git branch -d test → 删除test分支 git log --graph 查看分支合并的图形化日志 git log --graph → 可视化分支合并历史 5.2 分支冲突处理当不同分支修改同一文件导致合并冲突时： Git会标记冲突文件的冲突位置 手动编辑文件，删除冲突标记并调整代码逻辑 保存后执行git add [冲突文件] → git commit -m &quot;解决分支冲突&quot; 完成合并 6. 参考资料 Git 速查表（Cheat Sheet） 廖雪峰 Git 教程（零基础入门）","link":"/2026/01/23/git%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E5%8F%82%E8%80%83/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2026/01/21/hello-world/"},{"title":"如何新增博客内容？","text":"本文详细介绍基于Icarus主题的Hexo博客新增文章全流程，涵盖从文章创建、编辑、本地预览到最终部署的所有操作，同时适配Icarus主题专属功能（目录、评论、代码高亮等）。 一、 核心操作流程（从创建到部署）步骤1：终端创建文章/草稿在Hexo博客根目录打开终端，执行对应命令创建文章，生成的文件会自动存入指定目录，Icarus主题可正常渲染。 1.1 创建正式文章（推荐）1234# 完整命令hexo new &quot;你的博客文章标题&quot;# 简写命令（更高效，推荐使用）hexo n &quot;Hexo Icarus 主题新增文章教程&quot; 1.2 创建草稿（先撰写后发布）如果暂不想公开，可先创建草稿进行编辑： 123456# 创建草稿（生成到 source/_drafts/ 目录）hexo new draft &quot;草稿标题&quot;# 预览草稿（需添加 -d 参数）hexo s -d# 发布草稿（自动移动到 source/_posts/ 目录，转为正式文章）hexo publish &quot;草稿标题&quot; 1.3 关键注意点 文章标题含空格时，必须用英文引号括起来。 文件名建议使用英文/拼音，避免出现渲染异常。 若开启post_asset_folder: true（Hexo根目录_config.yml），创建文章时会生成同名文件夹，用于存放文章配图，方便管理。 步骤2：编辑Markdown文章文件打开source/_posts/目录下生成的.md文件，按照「Front-Matter配置 + Markdown正文」的结构进行编辑。 2.1 必配Front-Matter（Icarus主题兼容）这是文章的配置头部，决定Icarus主题的渲染效果，核心配置如下： 1234567891011121314151617---# 文章核心信息title: Hexo Icarus 主题新增文章教程 # 文章标题date: 2026-01-22 22:00:00 # 发布日期（自动生成，可手动修改）updated: 2026-01-22 23:30:00 # 更新日期（可选，不同与date时会显示在文章底部）categories: # 多级分类（对应侧边栏Categories widget） - Hexo教程(父类) - Icarus主题(子类)tags: # 文章标签（对应侧边栏Tags widget，最多显示10个） - Hexo - Icarus - 博客搭建# Icarus主题专属配置excerpt: 这是一篇基于Icarus主题的Hexo新增文章教程，包含评论、目录等功能适配。 # 列表页显示的摘要toc: true # 开启左侧自动生成目录（对应toc widget）comments: true # 开启底部Gitalk评论框（关闭则不显示）--- 2.2 Front-Matter关键说明 toc: true：配合你配置的左侧TOC部件，自动生成1-3级标题目录，支持跳转。 comments: true：触发已配置的Gitalk评论框，无需额外修改，部署后即可显示。 代码高亮：无需额外配置，Icarus已预设atom-one-light主题，正文代码块会自动高亮并附带复制按钮。 2.3 编写Markdown正文（Icarus自动渲染）Front-Matter下方使用标准Markdown语法编写正文即可，Icarus会自动渲染以下特色功能： 代码块：自动高亮、带复制按钮、默认展开（配置fold: unfolded）。 图片：推荐放入文章同名文件夹，引用格式![图片描述](文章标题/图片名.webp)。 阅读时间：自动计算并显示在文章标题下方（配置readtime: true）。 更新时间：updated与date不同时，自动显示在文章底部（配置update_time: auto）。 2.4 正文示例（可直接复制测试）12345## 一、核心创建命令回顾创建正式文章的核心终端命令：```bash# 简写命令，高效创建hexo n &quot;你的文章标题&quot; 二、Icarus主题功能验证要点 左侧是否自动生成TOC目录（依赖toc: true配置）。 代码块是否有原子白高亮效果，且右侧带有复制按钮。 文章底部是否显示Gitalk评论框（需登录GitHub账号）。 三、图片引用示例（推荐方式）开启post_asset_folder: true后，图片引用格式如下：![Icarus主题LOGO](新增文章教程/icarus-logo.png) 12345678## 步骤3：本地预览（验证功能是否生效）编辑完成后，先进行本地预览，避免部署后出现问题，优先排查功能异常。### 3.1 启动本地预览服务器```bash# 清除旧缓存 + 启动本地服务器（默认端口4000）hexo clean &amp;&amp; hexo s 3.2 验证核心功能在浏览器访问http://localhost:4000，逐一检查以下内容： 新文章是否出现在首页、对应分类页、对应标签页中。 文章左侧TOC目录是否正常显示，且跳转功能可用。 代码块是否高亮，复制按钮是否可以正常使用。 文章底部Gitalk评论框是否显示（即使提示“未找到相关Issue”，也说明配置正常）。 步骤4：生成静态文件并一键部署本地预览无误后，执行命令发布到GitHub Pages，完成博客更新。 4.1 部署终端命令12# 清除缓存 → 生成静态文件 → 部署到GitHub Pageshexo clean &amp;&amp; hexo g -d 4.2 部署注意点 GitHub Pages存在1-3分钟延迟，部署后无需立即刷新，等待片刻再访问。 Gitalk评论框首次使用时，需登录GitHub账号，点击“初始化评论”自动创建对应Issue，之后即可正常评论。 二、 Icarus主题专属注意事项1. Gitalk评论功能生效补充 确保公开仓库repo: blog-comments已创建完成。 确保client_id和client_secret与GitHub OAuth App信息一致。 若评论框报错，检查proxy地址（你配置的https://gh-proxy.com/可解决国内访问问题）是否可用。 2. 图片路径优化建议 优先开启post_asset_folder: true，图片放入文章同名文件夹，引用更便捷且无加载异常。 图片名避免使用中文，建议采用「英文/拼音+连字符」命名（如icarus-logo.webp）。 3. 侧边栏Widget自动同步 左侧侧边栏（分类、目录、友情链接）、右侧侧边栏（最新文章、归档、标签）会自动同步新文章的categories和tags，无需手动修改配置。 4. 数学公式支持 已开启mathjax: true，文章中可直接使用MathJax语法插入数学公式（如$E=mc^2$），Icarus会自动渲染。 三、 总结 核心流程：hexo n &quot;标题&quot; → 编辑Markdown（适配Front-Matter） → hexo clean &amp;&amp; hexo s预览 → hexo clean &amp;&amp; hexo g -d部署。 关键适配：Front-Matter中开启toc: true和comments: true，对应Icarus主题的目录和Gitalk评论功能。 避坑要点：本地预览优先于部署，可提前验证所有功能，减少返工成本。","link":"/2026/01/22/%E5%A6%82%E4%BD%95%E6%96%B0%E5%A2%9E%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%EF%BC%9F/"},{"title":"零基础利用Github、Hexo搭建个人博客(超详细版)","text":"一、需求描述希望搭建一个属于自己的个人博客平台，用于分享 Markdown 格式的技术教程、学习笔记，同时支持自身在线查阅；但受限于零服务器资源、零建站经验，不想投入成本购买服务器，也不愿花费大量时间研究复杂的建站技术；需要一份从环境配置、主题定制，到内容发布、部署上线的超详细分步指南，确保按步骤操作就能完成博客搭建。免费托管需求可通过 GitHub 平台实现，Markdown 内容快速生成静态博客的需求可通过 Hexo 框架满足，两者结合即可打造一套零成本、易维护的个人博客系统。 二、准备工作2.1 安装Git参考超详细Git安装指南一步一步跟着做即可。 附赠Git快速上手教程 Git新手入门参考 Git教程-廖雪峰的官方网站(强推) B站狂神说建议：主看Git教程-廖雪峰的官方网站，遇到不理解的地方参考B站狂神说，想快速上手看Git新手入门参考。 2.2 安装Node.js参考超详细Node.js安装指南一步一步跟着做即可。 2.3 安装Hexo2.3.1 安装npm按正常步骤已经安装完毕，如不放心可执行以下命令查看： 123输入命令node -v # 若输出v20.x.x，说明Node.js安装成功。输入命令npm -v # 若输出对应版本号，说明npm包管理工具同步安装成功。 2.3.2 安装Hexo12345#1-使用npm下载安装Hexonpm install hexo-cli -g #2-查看hexo版本信息(显示对应的版本信息则表示安装成功)hexo -v 2.4 创建Hexo项目1234567891011121314151617181920212223#1-进入指定路径(博客内容放置的目录下)cd D:\\MyBlog #2-创建一个Hexo新项目hexo init ckblogs #3-进入该内容目录中cd ckblogs #4-安装Hexo项目核心依赖内容（必须步骤，保证项目正常运行）npm install #5-安装Hexo部署到GitHub专用依赖包（后续部署必须，提前安装）npm install hexo-deployer-git --save #6-启动Hexo项目（按下【Ctrl+C】停止服务）hexo server# 备选：如果4000端口被占用，可指定其他端口启动，例如4001端口# hexo server -p 4001#7-在浏览器输入【localhost:4000】访问到项目页面（表示项目安装配置完成）http://localhost:4000/ 三、主题配置3.1安装主题到Hexo主题官网(或在Github上搜索)挑选自己喜欢的主题(下面我将以ICARUS主题为例，其他主题同理) 这里推荐一些简约主题：NEXT、Fluid、Aurora 在Hexo主题官网挑选喜欢的主题后，可点击**’Visit preview site’**体验主题。一般原作者会在此处写下安装及配置教程 寻找主题配置教程示例 寻找主题安装教程示例 按照主题内置教程安装好后，执行以下命令： 1234567891011121314#1-进入创建好的blog项目中cd D:\\MyBlog\\ckblogs#2-安装blog项目所需的依赖内容(如已安装请忽略)npm install #3-清除缓存hexo clean #4-编译hexo g #5-启动服务hexo s 注意：所有的命令操作都是在Hexo根目录下进行的 安装好主题后，一般情况下可以在”D:\\MyBlog\\ckblogs\\themes”目录下找到，但是有些特殊的主题会安装到”D:\\MyBlog\\ckblogs\\node_modules”目录下(如ICARUS)。此时可以在本地预览效果。 3.2 主题个性化配置可在_config.yml文件(在主题目录下，不是Hexo根目录下的文件！)中自行编辑配置。 有些特殊主题下该文件的名字可以不同，不过大同小异。可根据主题提供的教程文档进行配置 配置_config.yml时的一些坑： 版本号一般不用改 换logo及头像的图片时要注意路径问题及图片格式、尺寸 有些导航栏的页面需要你自己填写。(如About导航栏，你可以这么配置：About: [你的Github主页链接或其他链接]) 一些插件最好用国内的，以免网速慢或日后出问题麻烦 有不懂的地方一定要参考教程文档或问AI，不要自己乱改，出bug很麻烦。 配置好主题后先到本地预览效果。可以在网页中打开开发者工具（快捷键：ctrl+shift+i）查看是否有报错，有些报错可能是浏览器自身扩展引发的，可以忽略。 推荐好用的图床网站点击跳转，不要上传二维码等隐私图片（bz曾上传了微信二维码，过一段时间链接自动失效了），不要上传违法图片。也可以使用github或gitee等仓库托管图片，不过要注意防盗链的问题！ 以上都是bz血与泪的教训[哭] 3.3 启用主题俩种方式：一 手动修改打开Hexo根目录下的_config.yml文件并编辑，找到文件中的theme: landscape（Hexo 默认主题），将其修改为theme: [你的主题] 注意：这里的主题名必须和主题文件夹名称一致，大小写敏感） 四、将Hexo项目部署到Github上4.1 将本机配置为免密登录GitHub这步在安装Git中应该操作完成。没有配置好的可以问下AI或重新看下教程。验证方法： 123ssh -T git@github.com# 回车后如果出现 GitHub 用户名相关提示，即表示配置成功# 首次验证会提示Are you sure you want to continue connecting (yes/no)?，输入yes回车即可 4.2 将本地生成的SSH公钥内容复制到Github中按正常步骤也已操作完毕。 操作步骤：1、 登录你的 GitHub 账号（ID：jasper0507），点击页面右上角的头像图标2、 在弹出的下拉菜单中，点击进入【Settings】（设置）页面3、 在左侧菜单栏中，找到并点击【SSH and GPG keys】选项4、 点击页面右上角的【New SSH key】按钮，进入 SSH 密钥添加界面5、填写密钥配置项：【Title】：自定义填写（可填如hexo-blog-deploy等标识性名称，无特殊要求）【Key type】：选择【Authentication key】（身份验证密钥）【Key】：打开本地生成的 SSH 密钥对中后缀为.pub的公钥文件，全选文件内的所有内容，粘贴到输入框中6、点击页面底部的【Add SSH key】按钮，完成公钥的添加操作 4.3 在Github上创建所属博客的仓库操作步骤 登录 GitHub 账号后，点击页面右上角的加号图标【+】 在弹出的下拉菜单中，点击【New repository】选项，进入仓库创建页面 根据自身需求填写仓库名称（[你的github用户名].github.io），选择公开(私有仓库无法搭建博客)，其他配置可默认 点击页面底部的【Create repository】按钮，完成 GitHub 仓库的创建 仓库创建成功后，在当前仓库界面的右侧区域，找到并点击【code】按钮 在展开的选项中，切换到【local】标签页 选择【ssh】选项，点击右侧的复制图标，即可获取该仓库的 SSH 链接 4.4 配置文件打开编辑Hexo根目录下_config.yml文件添加并编辑以下配置 123456deploy: type: 'git' repo: git@github.com:自己在github上的用户名称/仓库名称.git branch: main name: 自己在github上的用户名称 email: 自己在github上的用户对应的邮箱 4.5 部署项目1234567891011121314#1-进入本地的blog项目cd ckblogs#2-安装部署项目到github所需的包npm install hexo-deployer-git --save #3--清除缓存hexo clean #4-编译blog项目hexo g #5-部署blog项目到github上hexo d 看到”INFO Deploy done: git”就代表部署成功了，可到github仓库中查看(可能有延迟)。 五、打开博客网站查看效果至此，你的个人博客网站已经部署成功了！在浏览器中输入[你的github用户名].github.io即可进入你的专属博客。仍需测试博客的功能等是否一切正常，如果异常可以翻阅教程文档或询问ai后修改主题文件相关代码。修改后需执行以下命令： 1234567# 首先在本地预览，测试效果hexo clean #清理缓存hexo s #启动本地服务，可访问`http://localhost:4000/`# 确认无误后再上传hexo clean &amp;&amp; hexo g -d #一键部署 注意：修改后可能因为延迟等原因无法立即在网页上看到效果，可以等几分钟或者启动科学上网刷新网页. 六、新增博客内容可参考如何新增博客内容？，有详细教程。 七、 结语本文章结合了bz自己在搭建过程中的经验教训以及好的教学文档。如发现文章有任何错误欢迎留言或评论。谢谢大家！","link":"/2026/01/23/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%A9%E7%94%A8Github%E3%80%81Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E8%B6%85%E8%AF%A6%E7%BB%86%E7%89%88/"},{"title":"数据结构与算法(长期更新)","text":"栈与队列逆波兰表达式中缀表达式转化为后缀表达式转换规则（调度场算法）： 操作数直接输出。 运算符根据优先级处理，优先级高的先输出，同优先级左结合。 左括号 ( 入栈；遇到右括号 ) 时，弹出栈内运算符直到遇到左括号。 扫描完毕后，将栈中剩余运算符依次弹出。 举例原始表达式：a/b+(c*d-e*f)/g 扫描字符 动作 输出 栈（底→顶） a 输出 a a 空 / 入栈 / a / b 输出 b a b / + 弹出/输出，入栈+ a b / + ( 入栈 ( a b / + ( c 输出 c a b / c + ( * 入栈 * a b / c + ( * d 输出 d a b / c d + ( * - 弹出*输出，入栈- a b / c d * + ( - e 输出 e a b / c d * e + ( - * 入栈 * a b / c d * e + ( - * f 输出 f a b / c d * e f + ( - * ) 弹出*、-输出，弹出( a b / c d * e f * - + / 入栈 / a b / c d * e f * - + / g 输出 g a b / c d * e f * - g + / 结束 弹出/、+输出 a b / c d * e f * - g / + 空 最终后缀表达式：ab/cd*ef*-g/+ 后缀表达式求值算法步骤 从左到右扫描后缀表达式 遇到操作数 → 压入操作数栈 遇到运算符 → 弹出两个操作数（先右后左），计算结果压回栈中 扫描结束，栈顶即为表达式值 补充：先弹出的操作数对应运算符右侧的操作数，后弹出的对应运算符左侧的操作数。 举例设：a=8, b=2, c=3, d=4, e=5, f=6, g=2后缀表达式：ab/cd*ef*-g/+ 步骤 扫描字符 操作 操作数栈（底→顶） 1 a 压入 8 8 2 b 压入 2 8, 2 3 / 8÷2=4 4 4 c 压入 3 4, 3 5 d 压入 4 4, 3, 4 6 * 3×4=12 4, 12 7 e 压入 5 4, 12, 5 8 f 压入 6 4, 12, 5, 6 9 * 5×6=30 4, 12, 30 10 - 12-30=-18 4, -18 11 g 压入 2 4, -18, 2 12 / -18÷2=-9 4, -9 13 + 4+(-9)=-5 -5 结果：-5 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 运算符优先级int precedence(char op) { if (op == '+' || op == '-') return 1; if (op == '*' || op == '/') return 2; return 0;}// 中缀转后缀string infixToPostfix(const string&amp; infix) { stack&lt;char&gt; st; string postfix = &quot;&quot;; for (char ch : infix) { // 如果是操作数（字母或数字） if (isalnum(ch)) { postfix += ch; postfix += ' '; // 用空格分隔 } // 如果是左括号 else if (ch == '(') { st.push(ch); } // 如果是右括号 else if (ch == ')') { while (!st.empty() &amp;&amp; st.top() != '(') { postfix += st.top(); postfix += ' '; st.pop(); } st.pop(); // 弹出 '(' } // 如果是运算符 else if (ch == '+' || ch == '-' || ch == '*' || ch == '/') { while (!st.empty() &amp;&amp; precedence(st.top()) &gt;= precedence(ch)) { postfix += st.top(); postfix += ' '; st.pop(); } st.push(ch); } } // 弹出栈中剩余运算符 while (!st.empty()) { postfix += st.top(); postfix += ' '; st.pop(); } return postfix;}// 后缀表达式求值double evaluatePostfix(const string&amp; postfix, map&lt;char, double&gt;&amp; values) { stack&lt;double&gt; st; for (int i = 0; i &lt; postfix.length(); i++) { char ch = postfix[i]; // 跳过空格 if (ch == ' ') continue; // 如果是操作数 if (isalpha(ch)) { st.push(values[ch]); } // 如果是数字（多位数处理） else if (isdigit(ch)) { double num = 0; while (i &lt; postfix.length() &amp;&amp; isdigit(postfix[i])) { num = num * 10 + (postfix[i] - '0'); i++; } i--; // 回退一格 st.push(num); } // 如果是运算符 else { double b = st.top(); st.pop(); double a = st.top(); st.pop(); switch (ch) { case '+': st.push(a + b); break; case '-': st.push(a - b); break; case '*': st.push(a * b); break; case '/': st.push(a / b); break; } } } return st.top();} 字符串KMP算法关键定义前缀表（next数组）定义记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。 前缀：不包含最后一个字符的所有以第一个字符开头的连续子串。 后缀：不包含第一个字符的所有以最后一个字符结尾的连续子串。 举例 0 1 2 3 4 5 6 7 8 9 10 11 12 a a b a a b s a a b a a a 0 1 0 1 2 3 0 1 2 3 4 5 2 作用前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。 代码实现123456789101112131415161718192021222324252627282930void getNext(int* next, const string&amp; s) { int j = 0; next[0] = 0; for(int i = 1; i &lt; s.size(); i++) { while (j &gt; 0 &amp;&amp; s[i] != s[j]) { // j要保证大于0，因为下面有取j-1作为数组下标的操作 j = next[j - 1]; // 注意这里，是要找前一位的对应的回退位置了 } if (s[i] == s[j]) { j++; } next[i] = j; }}// j指向前缀末尾位置，i指向后缀末尾位置// j还代表着当前i之前（包括i）子串的最长相等前后缀的长度。// 主要聚焦于i指针，代表当前遍历到的子串的最后一个位置int strStr(string haystack, string needle) { if(needle.size()==0) return 0; vector&lt;int&gt; next(needle.size()); getNext(next,needle); int j=0; for(int i=0;i&lt;haystack.size();i++){ while(j&gt;0&amp;&amp;haystack[i]!=needle[j]) j=next[j-1]; if(haystack[i]==needle[j]) j++; if(j==needle.size()) return i-j+ 1; } return -1;}// i为当前遍历到的haystack字符串的位置// j为当前遍历到的needle字符串的位置 时间复杂度: O(n + m) 空间复杂度: O(m) 二叉树理论基础遍历方式DFS递归遍历递归三部曲 确定递归函数的参数和返回值确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 确定单层递归的逻辑确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。递归函数中，什么时候需要返回值？如果需要搜索整棵二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。 前序遍历123456void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 } 中序遍历123456void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; traversal(cur-&gt;left, vec); // 左 vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;right, vec); // 右} 后序遍历123456void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 vec.push_back(cur-&gt;val); // 中} 迭代遍历前序遍历1234567891011121314vector&lt;int&gt; preorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); // 中 st.pop(); result.push_back(node-&gt;val); if (node-&gt;right) st.push(node-&gt;right); // 右（空节点不入栈） if (node-&gt;left) st.push(node-&gt;left); // 左（空节点不入栈） } return result; } 后序遍历123456789101112131415vector&lt;int&gt; postorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); st.pop(); result.push_back(node-&gt;val); if (node-&gt;left) st.push(node-&gt;left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈） if (node-&gt;right) st.push(node-&gt;right); // 空节点不入栈 } reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了 return result; } 中序遍历1234567891011121314151617vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; TreeNode* cur = root; while (cur != NULL || !st.empty()) { if (cur != NULL) { // 指针来访问节点，访问到最底层 st.push(cur); // 将访问的节点放进栈 cur = cur-&gt;left; // 左 } else { cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据） st.pop(); result.push_back(cur-&gt;val); // 中 cur = cur-&gt;right; // 右 } } return result; } 统一迭代法BFS(层序遍历)12345678910111213141516171819vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { queue&lt;TreeNode*&gt; que; if (root != NULL) que.push(root); vector&lt;vector&lt;int&gt;&gt; result; while (!que.empty()) { int size = que.size(); vector&lt;int&gt; vec; // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的 for (int i = 0; i &lt; size; i++) { TreeNode* node = que.front(); que.pop(); vec.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); } result.push_back(vec); } return result; } 应用 对称二叉树（双指针遍历） 另一棵树的子树 二叉树的最大深度 二叉树的最小深度 二叉树的最近公共祖先（空节点做标记） 二叉搜索树验证二叉搜索树 关键点：中序遍历下，输出的二叉搜索树节点的数值是升序序列。 看到题目中出现二叉搜索树，首先想到该特性。 二叉搜索树的插入123456TreeNode* insertIntoBST(TreeNode* root, int val) { if(!root) return new TreeNode(val); if(root-&gt;val&gt;val) root-&gt;left=insertIntoBST(root-&gt;left,val); if(root-&gt;val&lt;val) root-&gt;right=insertIntoBST(root-&gt;right,val); return root;} 二叉搜索树的删除1234567891011121314151617181920212223242526272829303132333435363738394041TreeNode* deleteNode(TreeNode* root, int key) { if (root == nullptr) return root; // 第一种情况：没找到删除的节点，遍历到空节点直接返回了 if (root-&gt;val == key) { // 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点 if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) { ///! 内存释放 delete root; return nullptr; } // 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点 else if (root-&gt;left == nullptr) { auto retNode = root-&gt;right; ///! 内存释放 delete root; return retNode; } // 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点 else if (root-&gt;right == nullptr) { auto retNode = root-&gt;left; ///! 内存释放 delete root; return retNode; } // 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置 // 并返回删除节点右孩子为新的根节点。 else { TreeNode* cur = root-&gt;right; // 找右子树最左面的节点 while(cur-&gt;left != nullptr) { cur = cur-&gt;left; } cur-&gt;left = root-&gt;left; // 把要删除的节点（root）左子树放在cur的左孩子的位置 TreeNode* tmp = root; // 把root节点保存一下，下面来删除 root = root-&gt;right; // 返回旧root的右孩子作为新root delete tmp; // 释放节点内存（这里不写也可以，但C++最好手动释放一下吧） return root; } } if (root-&gt;val &gt; key) root-&gt;left = deleteNode(root-&gt;left, key); if (root-&gt;val &lt; key) root-&gt;right = deleteNode(root-&gt;right, key); return root;} 平衡二叉树（AVL树）理论理解代码模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std;struct AVLNode { int val; AVLNode* left; AVLNode* right; int height; // 节点高度（叶子节点高度=1，空节点高度=0） AVLNode(int x) : val(x), left(nullptr), right(nullptr), height(1) {}};// 1. 获取节点高度（空节点高度为0）int getHeight(AVLNode* node) { if (node == nullptr) return 0; return node-&gt;height;}// 2. 更新节点高度：当前节点高度 = 左右子树高度的最大值 + 1void updateHeight(AVLNode* node) { node-&gt;height = max(getHeight(node-&gt;left), getHeight(node-&gt;right)) + 1;}// 3. 计算平衡因子：平衡因子 = 左子树高度 - 右子树高度// 平衡因子绝对值&gt;1 时，节点失衡int getBalanceFactor(AVLNode* node) { if (node == nullptr) return 0; return getHeight(node-&gt;left) - getHeight(node-&gt;right);}// ===================== 旋转操作（核心） =====================/** * 右旋转（处理LL型失衡） * 失衡场景：节点的平衡因子&gt;1，且左孩子的平衡因子≥0 * 旋转逻辑： * y x * / \\ / \\ * x T3 右旋转 (y) z y * / \\ -------&gt; / \\ / \\ * z T2 T1 T4 T2 T3 * / \\ * T1 T4 */AVLNode* rightRotate(AVLNode* y) { AVLNode* x = y-&gt;left; // x是y的左孩子 AVLNode* T2 = x-&gt;right; // T2是x的右子树 // 执行旋转 x-&gt;right = y; y-&gt;left = T2; // 更新高度（先更子节点y，再更父节点x） updateHeight(y); updateHeight(x); return x; // 返回旋转后的新根节点x}/** * 左旋转（处理RR型失衡） * 失衡场景：节点的平衡因子&lt;-1，且右孩子的平衡因子≤0 * 旋转逻辑： * y x * / \\ / \\ * T1 x 左旋转 (y) y z * / \\ -------&gt; / \\ / \\ * T2 z T1 T2 T3 T4 * / \\ * T3 T4 */AVLNode* leftRotate(AVLNode* y) { AVLNode* x = y-&gt;right; // x是y的右孩子 AVLNode* T2 = x-&gt;left; // T2是x的左子树 // 执行旋转 x-&gt;left = y; y-&gt;right = T2; // 更新高度 updateHeight(y); updateHeight(x); return x; // 返回旋转后的新根节点x}// ===================== 插入操作 =====================/** * 递归插入节点（核心逻辑） * 步骤： * 1. 普通二叉搜索树的插入 * 2. 更新当前节点高度 * 3. 计算平衡因子，判断是否失衡 * 4. 失衡则根据类型旋转恢复平衡 */AVLNode* insert(AVLNode* root, int val) { // 第一步：普通BST插入 if (root == nullptr) { return new AVLNode(val); // 空节点，创建新节点 } if (val &lt; root-&gt;val) { root-&gt;left = insert(root-&gt;left, val); // 插入左子树 } else if (val &gt; root-&gt;val) { root-&gt;right = insert(root-&gt;right, val); // 插入右子树 } else { return root; // 不允许重复值，直接返回 } // 第二步：更新当前节点的高度 updateHeight(root); // 第三步：计算平衡因子，检查是否失衡 int balance = getBalanceFactor(root); // 第四步：处理4种失衡情况 // 1. LL型：平衡因子&gt;1，左孩子平衡因子≥0 → 右旋转 if (balance &gt; 1 &amp;&amp; getBalanceFactor(root-&gt;left) &gt;= 0) { return rightRotate(root); } // 2. RR型：平衡因子&lt;-1，右孩子平衡因子≤0 → 左旋转 if (balance &lt; -1 &amp;&amp; getBalanceFactor(root-&gt;right) &lt;= 0) { return leftRotate(root); } // 3. LR型：平衡因子&gt;1，左孩子平衡因子&lt;0 → 先左旋左孩子，再右旋当前节点 if (balance &gt; 1 &amp;&amp; getBalanceFactor(root-&gt;left) &lt; 0) { root-&gt;left = leftRotate(root-&gt;left); return rightRotate(root); } // 4. RL型：平衡因子&lt;-1，右孩子平衡因子&gt;0 → 先右旋右孩子，再左旋当前节点 if (balance &lt; -1 &amp;&amp; getBalanceFactor(root-&gt;right) &gt; 0) { root-&gt;right = rightRotate(root-&gt;right); return leftRotate(root); } // 未失衡，返回原根节点 return root;} 哈夫曼树定义哈夫曼树（也叫最优二叉树）：对于一组带有确定权值的叶子节点，构造的二叉树中带权路径长度（WPL）最小的二叉树。 构建思路反复合并最小权值的两棵树，直到只剩一棵 12345678910111213141516171819202122232425struct Compare{ bool operator()(HuffmanNode* a,HuffmanNode* b){ return a-&gt;weight&gt;b-&gt;weight; }};HuffmanNode* buildHuffmanTree(const vector&lt;int&gt; &amp;weights){ priority_queue&lt;HuffmanNode*,vector&lt;HuffmanNode*&gt;,Compare&gt; minHeap; for(int weight:weights) minHeap.push(new HuffmanNode(weight)); while(minHeap.size()&gt;1){ HuffmanNode* left=minHeap.top(); minHeap.pop(); HuffmanNode* right=minHeap.top(); minHeap.pop(); HuffmanNode* parent= new HuffmanNode(left-&gt;weight+right-&gt;weight); parent-&gt;left=left; parent-&gt;right=right; minHeap.push(parent); } return minHeap.top();}int calculateWPL(HuffmanNode* root,int depth){ if(!root) return 0; if(!root-&gt;left&amp;&amp;!root-&gt;right) return root-&gt;weight*depth; return calculateWPL(root-&gt;left,depth+1)+calculateWPL(root-&gt;right,depth+1);} 哈夫曼编码左分支标记为 0，右分支标记为 1 m阶B-树性质 阶数约束：每个节点最多有 m 个子节点。 关键字数量范围：非根节点（无论叶子或非叶子）：关键字数 k 满足 ⌈m/2⌉ - 1 ≤ k ≤ m - 1；根节点：若为非叶子节点，1 ≤ k ≤ m - 1；若为树中唯一节点（叶子），k 可为 0 或 1。子节点与关键字数量关系：节点的子节点数 = 关键字数 + 1。 有序性与范围约束：单个节点内的关键字严格升序排列；子树关键字范围由父节点关键字划分，左子树关键字小于对应父关键字，右子树关键字大于对应父关键字。 平衡性质：所有叶子节点都位于同一层。 动态维护性质：插入时节点关键字数超上限则触发分裂，删除时节点关键字数低于下限则触发借关键字或合并，操作后仍保持所有核心性质。 区别 B - 树：关键字分布在所有节点，叶子节点和非叶子节点都存数据； B + 树：仅叶子节点存数据，非叶子节点只存索引，叶子节点通过链表相连（更适合范围查询）； 查找查找方法评价指标 平均查找长度(ASL)：查找过程中主要操作是关键字的比较，查找过程中关键字的平均比较次数（平均查找长度）作为衡量一个查找算法效率高低的标准。 ASL=Pi*Ci(累加) Pi为查找第i个元素的概率 Ci为找到第i个元素所需的关键字与给定值的比较次数 查找方法分类 顺序表和链表的查找 哈希表的查找 索引查找表的查找 二分查找代码模板1234567891011121314151617181920// 关键：确定好循环不变量的定义。确定好if()括号内判断的逻辑。class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int left = 0; int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right] while (left &lt;= right) { // 当left==right，区间[left, right]依然有效，所以用 &lt;= int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2 if (nums[middle] &gt; target) { right = middle - 1; // target 在左区间，所以[left, middle - 1] } else if (nums[middle] &lt; target) { left = middle + 1; // target 在右区间，所以[middle + 1, right] } else { // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 } } // 未找到目标值 return -1; }}; 时间复杂度：O(log n) 空间复杂度：O(1) 经典题 跳石头 哈希表理论基础排序排序算法的稳定性 在待排序序列中，若存在两个或多个关键字相等的元素，排序后它们的相对顺序与排序前保持一致，则称该排序算法是「稳定的」；反之则为「不稳定的」。 衡量排序方法的标准 平均比较次数 平均移动 平均辅助存储空间 稳定性 插入排序直接插入排序基本思想将数组划分为已排序（初始仅首个元素）和未排序区间，依次取出未排序区间的元素，向前插入到已排序区间的合适位置（保证已排序区间始终有序），直至所有元素插入完成。 代码模板12345678910111213141516171819202122void insertionSort(std::vector&lt;T&gt;&amp; arr) { // 空数组或单元素数组无需排序 if (arr.size() &lt;= 1) return; // 已排序区间初始为 [0]，未排序区间从 i=1 开始遍历 for (int i = 1; i &lt; arr.size(); ++i) { // 保存当前待插入的元素（避免移动过程中被覆盖） T temp = arr[i]; // j 指向已排序区间的最后一个元素，向前遍历找插入位置 int j = i - 1; // 向前比较：若已排序元素 &gt; 待插入元素，则后移（腾出插入位置） // 相等元素不移动 → 保证稳定性 while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) { arr[j + 1] = arr[j]; // 元素后移 --j; // 继续向前找 } // 找到插入位置（j+1），放入待插入元素 arr[j + 1] = temp; }} 时间复杂度：O (n²) 稳定排序 举例 以数组 [5, 2, 9, 3, 7] 为例，直接插入排序过程如下（已排序区间用「」标注，未排序区间用 () 标注）：初始状态：「5」，(2, 9, 3, 7)取未排序首元素 2，插入「5」的合适位置 → 「2, 5」，(9, 3, 7)取 9，插入「2, 5」末尾（9&gt;5）→ 「2, 5, 9」，(3, 7)取 3，向前比较：5&gt;3 则后移，2≤3 则插入 → 「2, 3, 5, 9」，(7)取 7，向前比较：9&gt;7 则后移，5≤7 则插入 → 「2, 3, 5, 7, 9」（完成）。 希尔排序基本思想希尔排序基本思想：作为直接插入排序的改进算法，先按递减的增量（步长）将数组划分为若干个子序列，对每个子序列分别执行直接插入排序；逐步缩小增量直至为 1，最后对整个数组执行一次直接插入排序（此时数组已基本有序，大幅降低插入排序的时间开销）。 代码模板123456789101112131415161718192021222324252627282930template &lt;typename T&gt;void insertionSortWithGap(std::vector&lt;T&gt;&amp; arr, int gap) { int n = arr.size(); if (n &lt;= 1) return; // 逻辑和普通插入排序完全一致，仅将“1”改为“gap” for (int i = gap; i &lt; n; ++i) { T temp = arr[i]; // 保存待插入元素 int j = i-gap; // 已排序序列最后一个元素 // 向前遍历子序列（步长gap），找到插入位置 while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) { arr[j + gap] = arr[j]; // 元素后移（步长gap） j -= gap; } arr[j + gap] = temp; // 插入到合适位置 }}// 希尔排序template &lt;typename T&gt;void shellSort(std::vector&lt;T&gt;&amp; arr) { int n = arr.size(); if (n &lt;= 1) return; // 外层仅控制步长（增量），核心排序逻辑复用插入排序 for (int gap = n / 2; gap &gt; 0; gap /= 2) { std::cout &lt;&lt; &quot;当前步长gap=&quot; &lt;&lt; gap &lt;&lt; &quot;，调用带步长的插入排序&quot; &lt;&lt; std::endl; insertionSortWithGap(arr, gap); // 复用插入排序处理当前步长的子序列 }} 时间复杂度：O (n log n) ~ O (n²) 之间 不稳定排序 举例 数组：[8,5,9,1,7,2,6,4]选短数组 + 简单间隔（8→4→2→1）初始状态数组：[8, 5, 9, 1, 7, 2, 6, 4]数组长度 n=8，初始间隔（gap）=8/2=4第一步：gap=4（大间隔分组粗排）分组规则：索引差 4 为一组，共 4 组组 1（索引 0、4）：8、7 → 插入排序后：7、8组 2（索引 1、5）：5、2 → 插入排序后：2、5组 3（索引 2、6）：9、6 → 插入排序后：6、9组 4（索引 3、7）：1、4 → 插入排序后：1、4排序后数组：[7, 2, 6, 1, 8, 5, 9, 4]（从完全乱序→初步有序）第二步：gap=2（缩小间隔再粗排）分组规则：索引差 2 为一组，共 2 组组 1（索引 0、2、4、6）：7、6、8、9 → 插入排序后：6、7、8、9组 2（索引 1、3、5、7）：2、1、5、4 → 插入排序后：1、2、4、5排序后数组：[6, 1, 7, 2, 8, 4, 9, 5]（更接近有序，仅需微调）第三步：gap=1（间隔 1 = 普通插入排序）此时数组[6,1,7,2,8,4,9,5]已基本有序，插入排序仅需少量调整：1 插到 6 前 → [1,6,7,2,8,4,9,5]2 插到 6 前 → [1,2,6,7,8,4,9,5]4 插到 6 前 → [1,2,4,6,7,8,9,5]5 插到 9 前 → 最终：[1,2,4,5,6,7,8,9] 交换排序冒泡排序基本思想 俩俩比较待排序对象的关键字 代码模板1234567891011121314151617void bubbleSort(int arr[], int n) { // 外层循环：控制排序轮数（n个元素最多需要n-1轮） for (int i = 0; i &lt; n - 1; ++i) { bool swapped = false; // 优化：标记本轮是否发生交换（提前终止） // 内层循环：每轮比较相邻元素，把最大的&quot;冒泡&quot;到末尾 // 每轮结束后，末尾i个元素已排好，无需重复比较 for (int j = 0; j &lt; n - 1 - i; ++j) { // 相邻元素逆序，交换位置 if (arr[j] &gt; arr[j + 1]) { swap(arr[j], arr[j + 1]); swapped = true; // 标记有交换发生 } } // 本轮无交换 → 数组已完全有序，直接退出（优化效率） if (!swapped) break; }} 时间复杂度：O(n²) 稳定排序（判断条件为arr[j] ==&gt;== arr[j+1]） 举例 数组初始状态：21 25 49 25* 16 8第一趟：21 25 25* 16 8 49第二趟：21 25 16 8 25* 49第三趟：21 16 8 25 25* 49第四趟：16 8 21 25 25* 49第五趟：8 16 21 25 25* 49 快速排序思路 选一个基准值；遍历数组，将比基准小的放左、大的放右，基准归位（最终排序位置）；递归对基准左右的子数组重复操作，直到子数组仅 1 个元素（天然有序）。 代码模板12345678910111213141516vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { sort(nums,0,nums.size()-1); return nums; } void sort(vector&lt;int&gt; &amp;nums,int l,int r){ if(l&gt;=r) return; int x=nums[l],i=l-1,j=r+1; while(i&lt;j){ do i++;while(nums[i]&lt;x); do j--;while(nums[j]&gt;x); if(i&lt;j) swap(nums[i],nums[j]); } sort(nums,l,j); sort(nums,j+1,r); } 时间复杂度：复杂度 O (n log n) 不稳定排序 适用于n较大的情况 选择排序简单选择排序基本思想 外层循环：遍历数组，确定每轮要归位的位置（第i轮处理索引i）；内层循环：在[i, 数组末尾]的未排序区间，找到最小值的索引；交换：将最小值与未排序区间的第一个元素（索引i）交换，完成该位置的归位；重复上述步骤，直到所有元素归位。 代码模板1234567891011121314void selectionSort(int arr[], int n) { // 外层循环：确定每轮归位的位置i（0到n-2，最后1个元素无需处理） for (int i = 0; i &lt; n - 1; ++i) { int minIdx = i; // 初始化最小值索引为当前未排序区间的第一个位置 // 内层循环：在[i, n-1]找最小值的索引 for (int j = i + 1; j &lt; n; ++j) { if (arr[j] &lt; arr[minIdx]) { minIdx = j; // 更新最小值索引 } } // 交换：把最小值放到索引i的位置（归位） swap(arr[i], arr[minIdx]); }} 时间复杂度：O(n²) 不稳定排序 举例 数组初始状态：6, 3, 8, 5, 9, 1, 7, 2, 4, 0第一轮 [0, 3, 8, 5, 9, 1, 7, 2, 4, 6]第二轮 [0, 1, 8, 5, 9, 3, 7, 2, 4, 6]第三轮 [0, 1, 2, 5, 9, 3, 7, 8, 4, 6]第四轮 [0, 1, 2, 3, 9, 5, 7, 8, 4, 6]第五轮 [0, 1, 2, 3, 4, 5, 7, 8, 9, 6]第六轮 不变第七轮 [0, 1, 2, 3, 4, 5, 6, 8, 9, 7]第八轮 [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]第九轮 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 树形选择排序(打擂台)模拟 15 25 15 25 28 19 15 49 25 37 28 19 65 15 34 每个枝结点的关键字都等于其左、右孩子结点中较小的关键字，根结点是最小的。输出最小关键字后，只需将叶子结点中的最小关键字改为最大值，然后重复上述步骤即可 堆排序前置知识 堆是基于完全二叉树的一种数据结构，核心满足「堆序性」，分为两种类型（升序排序常用大顶堆）： 堆类型 核心规则 关键特征 大顶堆 每个父节点值 ≥ 左右子节点值 堆顶是全局最大值 小顶堆 每个父节点值 ≤ 左右子节点值 堆顶是全局最小值 数组模拟堆（索引从 0 开始）：父节点 i 的左子节点：2i+1，右子节点：2i+2；子节点 j 的父节点：(j-1)/2（整数除法）。 堆的特点：序列中第一个元素为序列中最大（最小）值 代码模板123456789101112131415161718192021//大顶堆-&gt;升序 // unsortLen为未排序区间（0,,,unsortLen）左闭右闭void heapAdjust(vector&lt;int&gt;&amp; nums,int root,int unsortLen){ int lChild=2*root+1,rChild=2*root+2; int maxIdx=root; if(lChild&lt;=unsortLen&amp;&amp;nums[lChild]&gt;nums[maxIdx]) maxIdx=lChild; if(rChild&lt;=unsortLen&amp;&amp;nums[rChild]&gt;nums[maxIdx]) maxIdx=rChild; if(root!=maxIdx){ swap(nums[root],nums[maxIdx]); heapAdjust(nums,maxIdx,unsortLen); }}vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { int n=nums.size()-1; for(int root=(n-1)/2;root&gt;=0;root--) heapAdjust(nums,root,n);// 子节点 j 的父节点：(j-1)/2（整数除法）。 for(int unsortLen=n;unsortLen&gt;0;unsortLen--){ swap(nums[0],nums[unsortLen]); heapAdjust(nums,0,unsortLen-1); } return nums;} 1234567891011121314151617181920//小顶堆-&gt;降序void heapAdjust(vector&lt;int&gt;&amp; nums,int root,int unsortLen){ int lChild=2*root+1,rChild=2*root+2; int minIdx=root; if(lChild&lt;=unsortLen&amp;&amp;nums[lChild]&lt;nums[minIdx]) minIdx=lChild; if(rChild&lt;=unsortLen&amp;&amp;nums[rChild]&lt;nums[minIdx]) minIdx=rChild; if(root!=minIdx){ swap(nums[root],nums[minIdx]); heapAdjust(nums,minIdx,unsortLen); }}vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { int n=nums.size()-1; for(int root=(n-1)/2;root&gt;=0;root--) heapAdjust(nums,root,n);// 子节点 j 的父节点：(j-1)/2（整数除法）。 for(int unsortLen=n;unsortLen&gt;0;unsortLen--){ swap(nums[0],nums[unsortLen]); heapAdjust(nums,0,unsortLen-1); } return nums;} 时间复杂度：O(nlogn) 排序不稳定 归并排序思路 分（拆分）：将待排序数组从中间递归拆分为左右两个子数组，直到每个子数组仅含 1 个元素（单个元素天然有序）。治（合并）：将两个有序的子数组，通过双指针逐个比较、按大小合并为一个有序数组，逐层向上合并后得到最终有序数组。 代码模板1234567891011121314151617int temp[10005];void merge_sort(vector&lt;int&gt; &amp;num,int l,int r){ if(l&gt;=r) return; int mid = (l+r)/2; merge_sort(num,l,mid),merge_sort(num,mid+1,r); int k=0,i=l,j=mid+1; // 双指针比较，把较小元素放入temp while(i&lt;=mid&amp;&amp;j&lt;=r) if(num[i]&lt;=num[j]) temp[k++] = num[i++];// 如果是num[i]&lt;num[j]排序会变得不稳定。 else temp[k++] = num[j++]; // 处理左子数组剩余元素 while(i&lt;=mid) temp[k++]=num[i++]; // 处理右子数组剩余元素 while(j&lt;=r) temp[k++]=num[j++]; // 把temp中有序数据复制回原数组num的[l, r]区间 for(i=l,j=0;i&lt;=r;i++,j++) num[i]=temp[j]; } 时间复杂度：O(nlogn) 排序稳定 图论图的遍历深度搜索DFS三部曲 确认递归函数参数 确认终止条件 处理目前搜索节点出发的路径 思路代码框架123456789101112void dfs(参数) { if (终止条件) { 存放结果; return; } for (选择：本节点所连接的其他节点) { 处理节点; dfs(图，选择的节点); // 递归 回溯，撤销处理结果 }} 模板题代码模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//邻接矩阵写法#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; result; // 收集符合条件的路径vector&lt;int&gt; path; // 1节点到终点的路径void dfs (const vector&lt;vector&lt;int&gt;&gt;&amp; graph, int x, int n) { // 当前遍历的节点x 到达节点n if (x == n) { // 找到符合条件的一条路径 result.push_back(path); return; } for (int i = 1; i &lt;= n; i++) { // 遍历节点x链接的所有节点 if (graph[x][i] == 1) { // 找到 x链接的节点 path.push_back(i); // 遍历到的节点加入到路径中来 dfs(graph, i, n); // 进入下一层递归 path.pop_back(); // 回溯，撤销本节点 } }}int main() { int n, m, s, t; cin &gt;&gt; n &gt;&gt; m; // 节点编号从1到n，所以申请 n+1 这么大的数组 vector&lt;vector&lt;int&gt;&gt; graph(n + 1, vector&lt;int&gt;(n + 1, 0)); while (m--) { cin &gt;&gt; s &gt;&gt; t; // 使用邻接矩阵 表示无线图，1 表示 s 与 t 是相连的 graph[s][t] = 1; } path.push_back(1); // 无论什么路径已经是从0节点出发 dfs(graph, 1, n); // 开始遍历 // 输出结果 if (result.size() == 0) cout &lt;&lt; -1 &lt;&lt; endl; for (const vector&lt;int&gt; &amp;pa : result) { for (int i = 0; i &lt; pa.size() - 1; i++) { cout &lt;&lt; pa[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; pa[pa.size() - 1] &lt;&lt; endl; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//邻接表写法#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; result; // 收集符合条件的路径vector&lt;int&gt; path; // 1节点到终点的路径void dfs (const vector&lt;list&lt;int&gt;&gt;&amp; graph, int x, int n) { if (x == n) { // 找到符合条件的一条路径 result.push_back(path); return; } for (int i : graph[x]) { // 找到 x指向的节点 path.push_back(i); // 遍历到的节点加入到路径中来 dfs(graph, i, n); // 进入下一层递归 path.pop_back(); // 回溯，撤销本节点 }}int main() { int n, m, s, t; cin &gt;&gt; n &gt;&gt; m; // 节点编号从1到n，所以申请 n+1 这么大的数组 vector&lt;list&lt;int&gt;&gt; graph(n + 1); // 邻接表 while (m--) { cin &gt;&gt; s &gt;&gt; t; // 使用邻接表 ，表示 s -&gt; t 是相连的 graph[s].push_back(t); } path.push_back(1); // 无论什么路径已经是从0节点出发 dfs(graph, 1, n); // 开始遍历 // 输出结果 if (result.size() == 0) cout &lt;&lt; -1 &lt;&lt; endl; for (const vector&lt;int&gt; &amp;pa : result) { for (int i = 0; i &lt; pa.size() - 1; i++) { cout &lt;&lt; pa[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; pa[pa.size() - 1] &lt;&lt; endl; }} 广度搜索BFS使用场景适合于解决两个点之间的最短路径问题。 求单源最短路径，何时用BFS？何时用dijkstra？是否需要求解最短路径？→ 是 → 图的边权是否相等（或无权）？ → 是 → 用 BFS（高效简洁） → 否 → 边权是否非负？ → 是 → 用 Dijkstra 算法（贪心+优先队列） → 否 → 用 Bellman-Ford/SPFA 算法（处理负权） 思路代码模板123456789101112131415161718192021222324int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向// grid 是地图，也就是一个二维数组// visited标记访问过的节点，不要重复访问// x,y 表示开始搜索节点的下标void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) { queue&lt;pair&lt;int, int&gt;&gt; que; // 定义队列 que.push({x, y}); // 起始节点加入队列 visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点 while(!que.empty()) { // 开始遍历队列里的元素 pair&lt;int ,int&gt; cur = que.front(); que.pop(); // 从队列取元素 int curx = cur.first; int cury = cur.second; // 当前节点坐标 for (int i = 0; i &lt; 4; i++) { // 开始想当前节点的四个方向左右上下去遍历 int nextx = curx + dir[i][0]; int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标 if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue; // 坐标越界了，直接跳过 if (!visited[nextx][nexty]) { // 如果节点没被访问过 que.push({nextx, nexty}); // 队列添加该节点为下一轮要遍历的节点 visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问 } } }} 大家应该好奇，这一圈一圈的搜索过程是怎么做到的，是放在什么容器里，才能这样去遍历。很多网上的资料都是直接说用队列来实现。其实，我们仅仅需要一个容器，能保存我们要遍历过的元素就可以，那么用队列，还是用栈，甚至用数组，都是可以的。用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针。因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。如果用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历。因为栈是先进后出，加入元素和弹出元素的顺序改变了。那么广搜需要注意 转圈搜索的顺序吗？ 不需要！所以用队列，还是用栈都是可以的，但大家都习惯用队列了，所以下面的讲解用我也用队列来讲，只不过要给大家说清楚，并不是非要用队列，用栈也可以。 并查集适用场景 需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。（常用来解决连通性问题） 思路代码模板123456789101112131415161718192021222324252627class Union{private: vector&lt;int&gt; father;public:// 初始化 Union(int num){ father.resize(num); for(int i=0;i&lt;num;++i) father[i]=i; }// 并查集里寻根的过程 int find(int u){ if(u==father[u]) return u; father[u]=find(father[u]);//路径压缩 return father[u]; }// 核心// 将u-v 这条边加入并查集 void join(int u,int v){ u=find(u); v=find(v); if(u==v) return; father[u]=v; }// 判断 u 和 v是否找到同一个根 bool isSame(int u,int v){ return find(u)==find(v); }}; 模板题最小生成树概念生成树：是一个极小连通子图，它含有图中的全部顶点，但只有n-1条边。生成森林：由若干棵生成树组成，含全部顶点，但构成这些树的边是最少的。最小生成树：所有节点的最小连通子图，即：以最小的成本（边的权值）将图中所有节点链接到一起。 prim算法三部曲 第一步，选距离生成树最近节点第二步，最近节点加入生成树第三步，更新非生成树节点到生成树的距离（即更新minDist数组） 适用条件：无向图 连通图 无回路 权值无论正负模板题思路代码模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;vector&gt;#include &lt;climits&gt;using namespace std;int main() { int v, e; int x, y, k; cin &gt;&gt; v &gt;&gt; e; // 填一个默认最大值，题目描述val最大为10000 vector&lt;vector&lt;int&gt;&gt; grid(v + 1, vector&lt;int&gt;(v + 1, 10001)); while (e--) { cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; // 因为是双向图，所以两个方向都要填上 grid[x][y] = k; grid[y][x] = k; } // 所有节点到最小生成树的最小距离 vector&lt;int&gt; minDist(v + 1, 10001); // 这个节点是否在树里 vector&lt;bool&gt; isInTree(v + 1, false); // 我们只需要循环 n-1次，建立 n - 1条边，就可以把n个节点的图连在一起 for (int i = 1; i &lt; v; i++) { // 1、prim三部曲，第一步：选距离生成树最近节点 int cur = -1; // 选中哪个节点 加入最小生成树 int minVal = INT_MAX; for (int j = 1; j &lt;= v; j++) { // 1 - v，顶点编号，这里下标从1开始 // 选取最小生成树节点的条件： // （1）不在最小生成树里 // （2）距离最小生成树最近的节点 if (!isInTree[j] &amp;&amp; minDist[j] &lt; minVal) { minVal = minDist[j]; cur = j; } } // 2、prim三部曲，第二步：最近节点（cur）加入生成树 isInTree[cur] = true; // 3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新minDist数组） // cur节点加入之后， 最小生成树加入了新的节点，那么所有节点到 最小生成树的距离（即minDist数组）需要更新一下 // 由于cur节点是新加入到最小生成树，那么只需要关心与 cur 相连的 非生成树节点 的距离 是否比 原来 非生成树节点到生成树节点的距离更小了呢 for (int j = 1; j &lt;= v; j++) { // 更新的条件： // （1）节点是 非生成树里的节点 // （2）与cur相连的某节点的权值 比 该某节点距离最小生成树的距离小 // 很多录友看到自己 就想不明白什么意思，其实就是 cur 是新加入 最小生成树的节点，那么 所有非生成树的节点距离生成树节点的最近距离 由于 cur的新加入，需要更新一下数据了 if (!isInTree[j] &amp;&amp; grid[cur][j] &lt; minDist[j]) { minDist[j] = grid[cur][j]; } } } // 统计结果 int result = 0; for (int i = 2; i &lt;= v; i++) { // 不计第一个顶点，因为统计的是边的权值，v个节点有 v-1条边 result += minDist[i]; } cout &lt;&lt; result &lt;&lt; endl;} kruskal算法思路 边的权值排序，因为要优先选最小的边加入到生成树里遍历排序后的边如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合 代码模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct Edge{ int u; int v; int w;};class Union{private: vector&lt;int&gt; father;public: Union(int n){ father.resize(n+1); for(int i=1;i&lt;=n;i++) father[i]=i; } int find(int u){ if(u==father[u]) return father[u]; father[u]=find(father[u]); return father[u]; } void join(int u,int v){ u=find(u); v=find(v); if(u==v) return; father[u]=v; } bool isSame(int u,int v){ return find(u)==find(v); }};int main(){ int v,e; cin&gt;&gt;v&gt;&gt;e; vector&lt;Edge&gt; edges; for(int i=0;i&lt;e;i++){ int u,v,w; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; edges.push_back({u,v,w}); } sort(edges.begin(),edges.end(),[&amp;](const Edge a,const Edge b){ return a.w&lt;b.w; }); Union setv(v); int result=0; for(auto edge:edges){ if(!setv.isSame(edge.u,edge.v)){ setv.join(edge.u,edge.v); result+=edge.w; } } cout&lt;&lt;result;} prim与kruskal对比总结 prim维护的是节点的集合，而 Kruskal 维护的是边的集合。 Prim 算法 时间复杂度为 O(n^2)，其中 n 为节点数量，它的运行效率和图中边树无关，适用稠密图。 Kruskal算法 时间复杂度 为 nlogn，其中n 为边的数量，适用稀疏图。 拓扑排序前置概念 AOV网：用顶点表示活动的网络 AOE网：用边表示活动的网络 适用场景 给出一个 有向图，把这个有向图转成线性的排序 就叫拓扑排序。 拓扑排序也是图论中判断有向无环图的常用方法。 思路 找到入度为0 的节点，加入结果集 将该节点从图中移除 循环以上俩步 代码模板123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;using namespace std;int main(){ int N,M; cin&gt;&gt;N&gt;&gt;M; vector&lt;int&gt; inDegree(N,0); vector&lt;list&lt;int&gt;&gt; graph(N); queue&lt;int&gt; q; vector&lt;int&gt; result; for(int i=0;i&lt;M;i++){ int S,T; cin&gt;&gt;S&gt;&gt;T; graph[S].push_back(T); inDegree[T]++; } for(int i=0;i&lt;N;i++) if(inDegree[i]==0) q.push(i); while(!q.empty()){ int cur=q.front(); q.pop(); result.push_back(cur); for(int i:graph[cur]) if(--inDegree[i]==0) q.push(i); } if(result.size()==N){ for(int i=0;i&lt;N-1;i++) cout&lt;&lt;result[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;result[N-1]; }else cout&lt;&lt;-1&lt;&lt;endl;} 判断是否有环 结果集元素个数 不等于 图中节点个数，我们就可以认定图中一定有 有向环！ 时间复杂度 O(n+e) AOE网络核心定义 Ve(j)：从起点到本节点的最长的路径。意味着事件最早能够发生的时刻。 Vl(j)：不影响工程的如期完工，本节点事件必须发生的时刻。 e(ai)：活动的最早开始时间 e(ai)=Ve(j) l(ai)：活动的最迟开始时间 l(ai)=Vl(k)-dut(j,k) 关键活动：最早开始时间=最迟开始时间的活动 关键路径：从原点到汇点的最长的一条路径，或者全部由关键活动构成的路径 AOE网络关键路径求解 核心步骤：拓扑排序得到拓扑序列；按拓扑序计算Ve（事件最早发生时间）；按逆拓扑序计算Vl（事件最迟发生时间）；计算所有活动的e和l，找出关键活动；关键活动构成的路径即为关键路径。 代码模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;climits&gt;using namespace std;// 边结构体：to=邻接顶点，weight=活动持续时间struct Edge { int to, weight; Edge(int t, int w) : to(t), weight(w) {}};int main() { int N, M; // N=事件数（顶点），M=活动数（边） cin &gt;&gt; N &gt;&gt; M; vector&lt;list&lt;Edge&gt;&gt; graph(N); // 正邻接表 vector&lt;list&lt;Edge&gt;&gt; reverseGraph(N);// 逆邻接表（用于逆拓扑序计算Vl） vector&lt;int&gt; inDegree(N, 0); vector&lt;int&gt; Ve(N, 0); // 事件最早发生时间 vector&lt;int&gt; Vl(N, INT_MAX); // 事件最迟发生时间 vector&lt;int&gt; topoOrder; // 拓扑序列 queue&lt;int&gt; q; // 构建图 for (int i = 0; i &lt; M; i++) { int S, T, W; cin &gt;&gt; S &gt;&gt; T &gt;&gt; W; graph[S].emplace_back(T, W); reverseGraph[T].emplace_back(S, W); inDegree[T]++; } // 步骤1：拓扑排序 for (int i = 0; i &lt; N; i++) { if (inDegree[i] == 0) q.push(i); } while (!q.empty()) { int cur = q.front(); q.pop(); topoOrder.push_back(cur); for (auto&amp; edge : graph[cur]) { if (--inDegree[edge.to] == 0) q.push(edge.to); } } if (topoOrder.size() != N) { cout &lt;&lt; &quot;存在环，无法计算关键路径&quot; &lt;&lt; endl; return 0; } // 步骤2：计算Ve（拓扑序） for (int u : topoOrder) { for (auto&amp; edge : graph[u]) { int v = edge.to; Ve[v] = max(Ve[v], Ve[u] + edge.weight); } } // 步骤3：计算Vl（逆拓扑序） Vl[topoOrder.back()] = Ve[topoOrder.back()]; // 汇点Vl=Ve for (int i = topoOrder.size() - 2; i &gt;= 0; i--) { int u = topoOrder[i]; for (auto&amp; edge : graph[u]) { int v = edge.to; Vl[u] = min(Vl[u], Vl[v] - edge.weight); } } // 步骤4：输出关键活动和工程最短完成时间 cout &lt;&lt; &quot;关键活动（边&lt;u,v&gt;）：&quot; &lt;&lt; endl; for (int u = 0; u &lt; N; u++) { for (auto&amp; edge : graph[u]) { int v = edge.to; int e = Ve[u]; // 活动最早开始时间 int l = Vl[v] - edge.weight; // 活动最迟开始时间 if (e == l) { cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; u &lt;&lt; &quot;,&quot; &lt;&lt; v &lt;&lt; &quot;&gt; （持续时间：&quot; &lt;&lt; edge.weight &lt;&lt; &quot;）&quot; &lt;&lt; endl; } } } cout &lt;&lt; &quot;工程最短完成时间：&quot; &lt;&lt; Ve[topoOrder.back()] &lt;&lt; endl; return 0;} 最短路径dijkstra算法 模板题 朴素版dijkstra三部曲 1、选源点到哪个节点近且该节点未被访问过(源点距离源点最近，距离为0，且未被访问。)2、该最近节点被标记访问过(标记源点访问过)3、更新非访问节点到源点的距离(即更新minDist数组) 限制条件==单源==最短路，即可求一点出发到任意点的最短路径。不能出现==负数权值== 与prim算法的区别对比prim算法的三部曲：第一步，选距离生成树最近节点第二步，最近节点加入生成树第三步，更新非生成树节点到生成树的距离（即更新minDist数组）prim算法支持负数权值 代码模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;int main() { int n, m, p1, p2, val; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; grid(n + 1, vector&lt;int&gt;(n + 1, INT_MAX)); for(int i = 0; i &lt; m; i++){ cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val; grid[p1][p2] = val; } int start = 1; int end = n; // 存储从源点到每个节点的最短距离 std::vector&lt;int&gt; minDist(n + 1, INT_MAX); // 记录顶点是否被访问过 std::vector&lt;bool&gt; visited(n + 1, false); minDist[start] = 0; // 起始点到自身的距离为0 for (int i = 1; i &lt;= n; i++) { // 遍历所有节点 int minVal = INT_MAX; int cur = 1; // 1、选距离源点最近且未访问过的节点 for (int v = 1; v &lt;= n; ++v) { if (!visited[v] &amp;&amp; minDist[v] &lt; minVal) { minVal = minDist[v]; cur = v; } } visited[cur] = true; // 2、标记该节点已被访问 // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组） for (int v = 1; v &lt;= n; v++) { if (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; minDist[cur] + grid[cur][v] &lt; minDist[v]) { minDist[v] = minDist[cur] + grid[cur][v]; } } } if (minDist[end] == INT_MAX) cout &lt;&lt; -1 &lt;&lt; endl; // 不能到达终点 else cout &lt;&lt; minDist[end] &lt;&lt; endl; // 到达终点最短路径} 复杂度 时间复杂度：O(n^2) 空间复杂度：O(n^2) 如何求路径？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;int main() { int n, m, p1, p2, val; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; grid(n + 1, vector&lt;int&gt;(n + 1, INT_MAX)); for(int i = 0; i &lt; m; i++){ cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val; grid[p1][p2] = val; } int start = 1; int end = n; std::vector&lt;int&gt; minDist(n + 1, INT_MAX); std::vector&lt;bool&gt; visited(n + 1, false); minDist[start] = 0; //加上初始化 vector&lt;int&gt; parent(n + 1, -1); for (int i = 1; i &lt;= n; i++) { int minVal = INT_MAX; int cur = 1; for (int v = 1; v &lt;= n; ++v) { if (!visited[v] &amp;&amp; minDist[v] &lt; minVal) { minVal = minDist[v]; cur = v; } } visited[cur] = true; for (int v = 1; v &lt;= n; v++) { if (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; minDist[cur] + grid[cur][v] &lt; minDist[v]) { minDist[v] = minDist[cur] + grid[cur][v]; parent[v] = cur; // 记录边 } } } // 输出最短情况 for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; parent[i] &lt;&lt; &quot;-&gt;&quot; &lt;&lt; i &lt;&lt; endl; }} 打印结果： 1234567-1-&gt;11-&gt;22-&gt;33-&gt;44-&gt;52-&gt;65-&gt;7 堆优化版dijkstra优化方向用最小堆自动排序，时间缩短至logn。用邻接表优化邻接矩阵（适用于稀疏图） 前置知识堆： 一般用stl中的优先队列(priority_queue)实现。自定义堆的排序规则:一般用自定义比较结构体实现 1234567891011struct Node { int val; int weight; };// 自定义比较器：按weight降序（weight大的优先级高）struct CompareNode { bool operator()(const Node&amp; a, const Node&amp; b) { return a.weight &lt; b.weight; // comp(a,b) = a.weight &lt; b.weight }};priority_queue&lt;Node, vector&lt;Node&gt;, CompareNode&gt; pq;pq.push({1, 5}); // apq.push({2, 3}); // b 如何确定优先级？ 要理解「comp(a, b) = true 则 b 优，false 则 a 优」的底层原理，核心要抓住两个关键点：C++ priority_queue 的底层是二叉堆，堆的核心规则是「父节点优先级 ≥ 子节点优先级」；比较器 comp 的设计语义是：判断 a 是否应该被放在 b 的下方（优先级更低） —— 这是 STL 对 “严格弱序” 比较器的标准化设计。 快速验证： 目标：x(weight=3) 优先级 &gt; y(weight=5)；比较器：comp(a,b) = a.weight &gt; b.weight；计算 comp(x,y) = 3&gt;5 → false → 符合预期（x 优先级高）。 代码模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;climits&gt;using namespace std; // 小顶堆class mycomparison {public: bool operator()(const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt;&amp; rhs) { return lhs.second &gt; rhs.second; }};// 定义一个结构体来表示带权重的边struct Edge { int to; // 邻接顶点 int val; // 边的权重 Edge(int t, int w): to(t), val(w) {} // 构造函数};int main() { int n, m, p1, p2, val; cin &gt;&gt; n &gt;&gt; m; vector&lt;list&lt;Edge&gt;&gt; grid(n + 1); for(int i = 0; i &lt; m; i++){ cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val; // p1 指向 p2，权值为 val grid[p1].push_back(Edge(p2, val)); } int start = 1; // 起点 int end = n; // 终点 // 存储从源点到每个节点的最短距离 std::vector&lt;int&gt; minDist(n + 1, INT_MAX); // 记录顶点是否被访问过 std::vector&lt;bool&gt; visited(n + 1, false); // 优先队列中存放 pair&lt;节点，源点到该节点的权值&gt; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, mycomparison&gt; pq; // 初始化队列，源点到源点的距离为0，所以初始为0 pq.push(pair&lt;int, int&gt;(start, 0)); minDist[start] = 0; // 起始点到自身的距离为0 while (!pq.empty()) { // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现） // &lt;节点， 源点到该节点的距离&gt; pair&lt;int, int&gt; cur = pq.top(); pq.pop(); if (visited[cur.first]) continue; // 2. 第二步，该最近节点被标记访问过 visited[cur.first] = true; // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组） for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge // cur指向的节点edge.to，这条边的权值为 edge.val if (!visited[edge.to] &amp;&amp; minDist[cur.first] + edge.val &lt; minDist[edge.to]) { // 更新minDist minDist[edge.to] = minDist[cur.first] + edge.val; pq.push(pair&lt;int, int&gt;(edge.to, minDist[edge.to])); } } } if (minDist[end] == INT_MAX) cout &lt;&lt; -1 &lt;&lt; endl; // 不能到达终点 else cout &lt;&lt; minDist[end] &lt;&lt; endl; // 到达终点最短路径} 复杂度 时间复杂度：O(ElogE) E 为边的数量 空间复杂度：O(N + E) N 为节点的数量 Floy算法核心：动态规划求多源最短路径（对边的权值正负没有要求）思路：最好直接看三维讲解动态规划五部曲： 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 变量定义 grid[i][j][k] = m，表示 节点i 到 节点j 以[1…k] 集合中的一个节点为中间节点的最短距离为m。 递推公式定义（俩种情况）：节点i 到 节点j 的最短路径经过节点k节点i 到 节点j 的最短路径不经过节点k 遍历顺序(和积分类似，以k为基础，遍历ij面，对于每k层的每个ij点，更新其最小值)：从k=0层开始向上递推==更新== 代码模板12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;using namespace std;int main() { int n, m, p1, p2, val; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; grid(n + 1, vector&lt;vector&lt;int&gt;&gt;(n + 1, vector&lt;int&gt;(n + 1, 10005))); // 因为边的最大距离是10^4 for(int i = 0; i &lt; m; i++){ cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val; grid[p1][p2][0] = val; grid[p2][p1][0] = val; // 注意这里是双向图 } // 开始 floyd for (int k = 1; k &lt;= n; k++) { for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { grid[i][j][k] = min(grid[i][j][k-1], grid[i][k][k-1] + grid[k][j][k-1]); } } } // 输出结果 int z, start, end; cin &gt;&gt; z; while (z--) { cin &gt;&gt; start &gt;&gt; end; if (grid[start][end][n] == 10005) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; grid[start][end][n] &lt;&lt; endl; }} 结尾内容及代码有任何错误欢迎留言指正。","link":"/2026/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"}],"tags":[{"name":"Gin","slug":"Gin","link":"/tags/Gin/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"Gin","slug":"Gin","link":"/categories/Gin/"},{"name":"Markdown","slug":"Markdown","link":"/categories/Markdown/"},{"name":"Go","slug":"Go","link":"/categories/Go/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"博客搭建教学","slug":"博客搭建教学","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E5%AD%A6/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"pages":[]}
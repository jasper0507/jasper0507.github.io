<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>数据结构与算法(长期更新) - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#ffffff"><meta name="application-name" content="jasper0507&#039;s blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="msapplication-TileColor" content="#ffffff"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="jasper0507&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="这是一篇长期更新的数据结构与算法个人总结性文章。cpp代码编写，适合大学生复习。"><meta property="og:type" content="blog"><meta property="og:title" content="数据结构与算法(长期更新)"><meta property="og:url" content="http://example.com/2026/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="这是一篇长期更新的数据结构与算法个人总结性文章。cpp代码编写，适合大学生复习。"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:published_time" content="2026-01-23T07:45:34.000Z"><meta property="article:modified_time" content="2026-01-23T07:45:34.000Z"><meta property="article:author" content="jasper0507"><meta property="article:tag" content="数据结构与算法"><meta property="article:tag" content="期末复习"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2026/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"},"headline":"数据结构与算法(长期更新)","image":["http://example.com/img/og_image.png"],"datePublished":"2026-01-23T07:45:34.000Z","dateModified":"2026-01-23T07:45:34.000Z","author":{"@type":"Person","name":"jasper0507"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":"这是一篇长期更新的数据结构与算法个人总结性文章。cpp代码编写，适合大学生复习。"}</script><link rel="canonical" href="http://example.com/2026/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?a7616da8eba57c8dc5dce4d0e23759c6";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 8.1.1"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" target="_blank" rel="noopener" href="https://github.com/jasper0507/jasper0507.github.io/new/main?filename=README.md">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/jasper0507"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2026-01-23T07:45:34.000Z" title="2026/1/23 15:45:34">2026-01-23</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span><span class="level-item">an hour read (About 11176 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">数据结构与算法(长期更新)</h1><div class="content"><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h2><h3 id="中缀表达式转化为后缀表达式"><a href="#中缀表达式转化为后缀表达式" class="headerlink" title="中缀表达式转化为后缀表达式"></a>中缀表达式转化为后缀表达式</h3><h4 id="转换规则（调度场算法）："><a href="#转换规则（调度场算法）：" class="headerlink" title="转换规则（调度场算法）："></a>转换规则（调度场算法）：</h4><ul>
<li>操作数直接输出。</li>
<li>运算符根据优先级处理，优先级高的先输出，同优先级左结合。</li>
<li>左括号 ( 入栈；遇到右括号 ) 时，弹出栈内运算符直到遇到左括号。</li>
<li>扫描完毕后，将栈中剩余运算符依次弹出。</li>
</ul>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>原始表达式：<code>a/b+(c*d-e*f)/g</code></p>
<table>
<thead>
<tr>
<th>扫描字符</th>
<th>动作</th>
<th>输出</th>
<th>栈（底→顶）</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>输出 a</td>
<td>a</td>
<td>空</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>入栈 &#x2F;</td>
<td>a</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>b</td>
<td>输出 b</td>
<td>a b</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>+</td>
<td>弹出&#x2F;输出，入栈+</td>
<td>a b &#x2F;</td>
<td>+</td>
</tr>
<tr>
<td>(</td>
<td>入栈 (</td>
<td>a b &#x2F;</td>
<td>+ (</td>
</tr>
<tr>
<td>c</td>
<td>输出 c</td>
<td>a b &#x2F; c</td>
<td>+ (</td>
</tr>
<tr>
<td>*</td>
<td>入栈 *</td>
<td>a b &#x2F; c</td>
<td>+ ( *</td>
</tr>
<tr>
<td>d</td>
<td>输出 d</td>
<td>a b &#x2F; c d</td>
<td>+ ( *</td>
</tr>
<tr>
<td>-</td>
<td>弹出*输出，入栈-</td>
<td>a b &#x2F; c d *</td>
<td>+ ( -</td>
</tr>
<tr>
<td>e</td>
<td>输出 e</td>
<td>a b &#x2F; c d * e</td>
<td>+ ( -</td>
</tr>
<tr>
<td>*</td>
<td>入栈 *</td>
<td>a b &#x2F; c d * e</td>
<td>+ ( - *</td>
</tr>
<tr>
<td>f</td>
<td>输出 f</td>
<td>a b &#x2F; c d * e f</td>
<td>+ ( - *</td>
</tr>
<tr>
<td>)</td>
<td>弹出*、-输出，弹出(</td>
<td>a b &#x2F; c d * e f * -</td>
<td>+</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>入栈 &#x2F;</td>
<td>a b &#x2F; c d * e f * -</td>
<td>+ &#x2F;</td>
</tr>
<tr>
<td>g</td>
<td>输出 g</td>
<td>a b &#x2F; c d * e f * - g</td>
<td>+ &#x2F;</td>
</tr>
<tr>
<td>结束</td>
<td>弹出&#x2F;、+输出</td>
<td>a b &#x2F; c d * e f * - g &#x2F; +</td>
<td>空</td>
</tr>
</tbody></table>
<p><strong>最终后缀表达式</strong>：<code>ab/cd*ef*-g/+</code></p>
<h3 id="后缀表达式求值"><a href="#后缀表达式求值" class="headerlink" title="后缀表达式求值"></a>后缀表达式求值</h3><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul>
<li>从左到右扫描后缀表达式</li>
<li>遇到操作数 → 压入操作数栈</li>
<li>遇到运算符 → 弹出两个操作数（先右后左），计算结果压回栈中</li>
<li>扫描结束，栈顶即为表达式值<blockquote>
<p>补充：先弹出的操作数对应运算符右侧的操作数，后弹出的对应运算符左侧的操作数。</p>
</blockquote>
</li>
</ul>
<h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>设：<code>a=8, b=2, c=3, d=4, e=5, f=6, g=2</code><br>后缀表达式：<code>ab/cd*ef*-g/+</code></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>扫描字符</th>
<th>操作</th>
<th>操作数栈（底→顶）</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
<td>压入 8</td>
<td>8</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>压入 2</td>
<td>8, 2</td>
</tr>
<tr>
<td>3</td>
<td>&#x2F;</td>
<td>8÷2&#x3D;4</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>c</td>
<td>压入 3</td>
<td>4, 3</td>
</tr>
<tr>
<td>5</td>
<td>d</td>
<td>压入 4</td>
<td>4, 3, 4</td>
</tr>
<tr>
<td>6</td>
<td>*</td>
<td>3×4&#x3D;12</td>
<td>4, 12</td>
</tr>
<tr>
<td>7</td>
<td>e</td>
<td>压入 5</td>
<td>4, 12, 5</td>
</tr>
<tr>
<td>8</td>
<td>f</td>
<td>压入 6</td>
<td>4, 12, 5, 6</td>
</tr>
<tr>
<td>9</td>
<td>*</td>
<td>5×6&#x3D;30</td>
<td>4, 12, 30</td>
</tr>
<tr>
<td>10</td>
<td>-</td>
<td>12-30&#x3D;-18</td>
<td>4, -18</td>
</tr>
<tr>
<td>11</td>
<td>g</td>
<td>压入 2</td>
<td>4, -18, 2</td>
</tr>
<tr>
<td>12</td>
<td>&#x2F;</td>
<td>-18÷2&#x3D;-9</td>
<td>4, -9</td>
</tr>
<tr>
<td>13</td>
<td>+</td>
<td>4+(-9)&#x3D;-5</td>
<td>-5</td>
</tr>
</tbody></table>
<p><strong>结果：<code>-5</code></strong></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运算符优先级</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">precedence</span><span class="params">(<span class="type">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span> || op == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span> || op == <span class="string">&#x27;/&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中缀转后缀</span></span><br><span class="line"><span class="function">string <span class="title">infixToPostfix</span><span class="params">(<span class="type">const</span> string&amp; infix)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">    string postfix = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : infix) &#123;</span><br><span class="line">        <span class="comment">// 如果是操作数（字母或数字）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalnum</span>(ch)) &#123;</span><br><span class="line">            postfix += ch;</span><br><span class="line">            postfix += <span class="string">&#x27; &#x27;</span>;  <span class="comment">// 用空格分隔</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是左括号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是右括号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                postfix += st.<span class="built_in">top</span>();</span><br><span class="line">                postfix += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">pop</span>();  <span class="comment">// 弹出 &#x27;(&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是运算符</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span> || ch == <span class="string">&#x27;*&#x27;</span> || ch == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">precedence</span>(st.<span class="built_in">top</span>()) &gt;= <span class="built_in">precedence</span>(ch)) &#123;</span><br><span class="line">                postfix += st.<span class="built_in">top</span>();</span><br><span class="line">                postfix += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 弹出栈中剩余运算符</span></span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        postfix += st.<span class="built_in">top</span>();</span><br><span class="line">        postfix += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> postfix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后缀表达式求值</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">evaluatePostfix</span><span class="params">(<span class="type">const</span> string&amp; postfix, map&lt;<span class="type">char</span>, <span class="type">double</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">double</span>&gt; st;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; postfix.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> ch = postfix[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 跳过空格</span></span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果是操作数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(ch)) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(values[ch]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是数字（多位数处理）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="type">double</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; postfix.<span class="built_in">length</span>() &amp;&amp; <span class="built_in">isdigit</span>(postfix[i])) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + (postfix[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;  <span class="comment">// 回退一格</span></span><br><span class="line">            st.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是运算符</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">double</span> b = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">double</span> a = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: st.<span class="built_in">push</span>(a + b); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: st.<span class="built_in">push</span>(a - b); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: st.<span class="built_in">push</span>(a * b); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: st.<span class="built_in">push</span>(a / b); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="关键定义"><a href="#关键定义" class="headerlink" title="关键定义"></a>关键定义</h3><h4 id="前缀表（next数组）"><a href="#前缀表（next数组）" class="headerlink" title="前缀表（next数组）"></a>前缀表（next数组）</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</p>
<ul>
<li>前缀：不包含最后一个字符的所有以第一个字符开头的连续子串。</li>
<li>后缀：不包含第一个字符的所有以最后一个字符结尾的连续子串。</li>
</ul>
<h5 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h5><table>
<thead>
<tr>
<th align="left">0</th>
<th align="left">1</th>
<th align="left">2</th>
<th align="left">3</th>
<th align="left">4</th>
<th align="left">5</th>
<th align="left">6</th>
<th align="left">7</th>
<th align="left">8</th>
<th align="left">9</th>
<th align="left">10</th>
<th align="left">11</th>
<th align="left">12</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a</td>
<td align="left">a</td>
<td align="left">b</td>
<td align="left">a</td>
<td align="left">a</td>
<td align="left">b</td>
<td align="left">s</td>
<td align="left">a</td>
<td align="left">a</td>
<td align="left">b</td>
<td align="left">a</td>
<td align="left">a</td>
<td align="left">a</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">5</td>
<td align="left">2</td>
</tr>
</tbody></table>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span> </span>&#123; </span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123; <span class="comment">// j要保证大于0，因为下面有取j-1作为数组下标的操作</span></span><br><span class="line">                j = next[j - <span class="number">1</span>]; <span class="comment">// 注意这里，是要找前一位的对应的回退位置了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// j指向前缀末尾位置，i指向后缀末尾位置</span></span><br><span class="line"><span class="comment">// j还代表着当前i之前（包括i）子串的最长相等前后缀的长度。</span></span><br><span class="line"><span class="comment">// 主要聚焦于i指针，代表当前遍历到的子串的最后一个位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line">        <span class="built_in">getNext</span>(next,needle);</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;haystack.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;haystack[i]!=needle[j]) j=next[j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(haystack[i]==needle[j]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j==needle.<span class="built_in">size</span>()) <span class="keyword">return</span> i-j+ <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i为当前遍历到的haystack字符串的位置</span></span><br><span class="line"><span class="comment">// j为当前遍历到的needle字符串的位置</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度: O(n + m)</li>
<li>空间复杂度: O(m)</li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a><a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">理论基础</a></h2><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><h4 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h4><h5 id="递归三部曲"><a href="#递归三部曲" class="headerlink" title="递归三部曲"></a>递归三部曲</h5><ul>
<li><strong>确定递归函数的参数和返回值</strong><br>确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件</strong><br>写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑</strong><br>确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。<br><em><strong>递归函数中，什么时候需要返回值？</strong></em><br>如果需要搜索整棵二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。</li>
</ul>
<h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">       vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">       <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">       <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h4><h5 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();                       <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);           <span class="comment">// 右（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);             <span class="comment">// 左（空节点不入栈）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 空节点不入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 将结果反转之后就是左右中的顺序了</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">       stack&lt;TreeNode*&gt; st;</span><br><span class="line">       TreeNode* cur = root;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123; <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">               st.<span class="built_in">push</span>(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">               cur = cur-&gt;left;                <span class="comment">// 左</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               cur = st.<span class="built_in">top</span>(); <span class="comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span></span><br><span class="line">               st.<span class="built_in">pop</span>();</span><br><span class="line">               result.<span class="built_in">push_back</span>(cur-&gt;val);     <span class="comment">// 中</span></span><br><span class="line">               cur = cur-&gt;right;               <span class="comment">// 右</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="统一迭代法"><a href="#统一迭代法" class="headerlink" title="统一迭代法"></a><a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html#%E6%80%9D%E8%B7%AF">统一迭代法</a></h5><h3 id="BFS-层序遍历"><a href="#BFS-层序遍历" class="headerlink" title="BFS(层序遍历)"></a>BFS(层序遍历)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/description/">对称二叉树（双指针遍历）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/description/">另一棵树的子树</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">二叉树的最大深度</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">二叉树的最小深度</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">二叉树的最近公共祖先（空节点做标记）</a></li>
</ul>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">验证二叉搜索树</a></h3><ul>
<li>关键点：中序遍历下，输出的二叉搜索树节点的数值是升序序列。<blockquote>
<p>看到题目中出现二叉搜索树，首先想到该特性。</p>
</blockquote>
</li>
</ul>
<h3 id="二叉搜索树的插入"><a href="#二叉搜索树的插入" class="headerlink" title="二叉搜索树的插入"></a>二叉搜索树的插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)           <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&gt;val)   root-&gt;left=<span class="built_in">insertIntoBST</span>(root-&gt;left,val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;val)   root-&gt;right=<span class="built_in">insertIntoBST</span>(root-&gt;right,val);</span><br><span class="line">        <span class="keyword">return</span>  root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树的删除"><a href="#二叉搜索树的删除" class="headerlink" title="二叉搜索树的删除"></a><a target="_blank" rel="noopener" href="https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">二叉搜索树的删除</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root; <span class="comment">// 第一种情况：没找到删除的节点，遍历到空节点直接返回了</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">            <span class="comment">// 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="comment">///! 内存释放</span></span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> retNode = root-&gt;right;</span><br><span class="line">                <span class="comment">///! 内存释放</span></span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> retNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> retNode = root-&gt;left;</span><br><span class="line">                <span class="comment">///! 内存释放</span></span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> retNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span></span><br><span class="line">            <span class="comment">// 并返回删除节点右孩子为新的根节点。</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode* cur = root-&gt;right; <span class="comment">// 找右子树最左面的节点</span></span><br><span class="line">                <span class="keyword">while</span>(cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur-&gt;left = root-&gt;left; <span class="comment">// 把要删除的节点（root）左子树放在cur的左孩子的位置</span></span><br><span class="line">                TreeNode* tmp = root;   <span class="comment">// 把root节点保存一下，下面来删除</span></span><br><span class="line">                root = root-&gt;right;     <span class="comment">// 返回旧root的右孩子作为新root</span></span><br><span class="line">                <span class="keyword">delete</span> tmp;             <span class="comment">// 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）</span></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h2><h3 id="理论理解"><a href="#理论理解" class="headerlink" title="理论理解"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1tZ421q72h?vd_source=fe146844c3a7d03bc7a83fe89415755d">理论理解</a></h3><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;         </span><br><span class="line">    AVLNode* left;    </span><br><span class="line">    AVLNode* right;   </span><br><span class="line">    <span class="type">int</span> height;       <span class="comment">// 节点高度（叶子节点高度=1，空节点高度=0）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVLNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">height</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取节点高度（空节点高度为0）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(AVLNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 更新节点高度：当前节点高度 = 左右子树高度的最大值 + 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateHeight</span><span class="params">(AVLNode* node)</span> </span>&#123;</span><br><span class="line">    node-&gt;height = <span class="built_in">max</span>(<span class="built_in">getHeight</span>(node-&gt;left), <span class="built_in">getHeight</span>(node-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 计算平衡因子：平衡因子 = 左子树高度 - 右子树高度</span></span><br><span class="line"><span class="comment">// 平衡因子绝对值&gt;1 时，节点失衡</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getBalanceFactor</span><span class="params">(AVLNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getHeight</span>(node-&gt;left) - <span class="built_in">getHeight</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===================== 旋转操作（核心） =====================</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 右旋转（处理LL型失衡）</span></span><br><span class="line"><span class="comment"> * 失衡场景：节点的平衡因子&gt;1，且左孩子的平衡因子≥0</span></span><br><span class="line"><span class="comment"> * 旋转逻辑：</span></span><br><span class="line"><span class="comment"> *        y                            x</span></span><br><span class="line"><span class="comment"> *       / \                         /   \</span></span><br><span class="line"><span class="comment"> *      x   T3  右旋转 (y)          z     y</span></span><br><span class="line"><span class="comment"> *     / \       -------&gt;         / \   / \</span></span><br><span class="line"><span class="comment"> *    z   T2                     T1 T4 T2 T3</span></span><br><span class="line"><span class="comment"> *   / \</span></span><br><span class="line"><span class="comment"> *  T1 T4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVLNode* <span class="title">rightRotate</span><span class="params">(AVLNode* y)</span> </span>&#123;</span><br><span class="line">    AVLNode* x = y-&gt;left;    <span class="comment">// x是y的左孩子</span></span><br><span class="line">    AVLNode* T2 = x-&gt;right;  <span class="comment">// T2是x的右子树</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行旋转</span></span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;left = T2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新高度（先更子节点y，再更父节点x）</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(y);</span><br><span class="line">    <span class="built_in">updateHeight</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;  <span class="comment">// 返回旋转后的新根节点x</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 左旋转（处理RR型失衡）</span></span><br><span class="line"><span class="comment"> * 失衡场景：节点的平衡因子&lt;-1，且右孩子的平衡因子≤0</span></span><br><span class="line"><span class="comment"> * 旋转逻辑：</span></span><br><span class="line"><span class="comment"> *    y                            x</span></span><br><span class="line"><span class="comment"> *   / \                         /   \</span></span><br><span class="line"><span class="comment"> *  T1  x  左旋转 (y)          y     z</span></span><br><span class="line"><span class="comment"> *     / \  -------&gt;         / \   / \</span></span><br><span class="line"><span class="comment"> *    T2  z                 T1 T2 T3 T4</span></span><br><span class="line"><span class="comment"> *       / \</span></span><br><span class="line"><span class="comment"> *      T3 T4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVLNode* <span class="title">leftRotate</span><span class="params">(AVLNode* y)</span> </span>&#123;</span><br><span class="line">    AVLNode* x = y-&gt;right;   <span class="comment">// x是y的右孩子</span></span><br><span class="line">    AVLNode* T2 = x-&gt;left;   <span class="comment">// T2是x的左子树</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行旋转</span></span><br><span class="line">    x-&gt;left = y;</span><br><span class="line">    y-&gt;right = T2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(y);</span><br><span class="line">    <span class="built_in">updateHeight</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;  <span class="comment">// 返回旋转后的新根节点x</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===================== 插入操作 =====================</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归插入节点（核心逻辑）</span></span><br><span class="line"><span class="comment"> * 步骤：</span></span><br><span class="line"><span class="comment"> * 1. 普通二叉搜索树的插入</span></span><br><span class="line"><span class="comment"> * 2. 更新当前节点高度</span></span><br><span class="line"><span class="comment"> * 3. 计算平衡因子，判断是否失衡</span></span><br><span class="line"><span class="comment"> * 4. 失衡则根据类型旋转恢复平衡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVLNode* <span class="title">insert</span><span class="params">(AVLNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步：普通BST插入</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AVLNode</span>(val);  <span class="comment">// 空节点，创建新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;left = <span class="built_in">insert</span>(root-&gt;left, val);  <span class="comment">// 插入左子树</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right = <span class="built_in">insert</span>(root-&gt;right, val); <span class="comment">// 插入右子树</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;  <span class="comment">// 不允许重复值，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：更新当前节点的高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：计算平衡因子，检查是否失衡</span></span><br><span class="line">    <span class="type">int</span> balance = <span class="built_in">getBalanceFactor</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四步：处理4种失衡情况</span></span><br><span class="line">    <span class="comment">// 1. LL型：平衡因子&gt;1，左孩子平衡因子≥0 → 右旋转</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">getBalanceFactor</span>(root-&gt;left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rightRotate</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. RR型：平衡因子&lt;-1，右孩子平衡因子≤0 → 左旋转</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">getBalanceFactor</span>(root-&gt;right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leftRotate</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. LR型：平衡因子&gt;1，左孩子平衡因子&lt;0 → 先左旋左孩子，再右旋当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">getBalanceFactor</span>(root-&gt;left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        root-&gt;left = <span class="built_in">leftRotate</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rightRotate</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. RL型：平衡因子&lt;-1，右孩子平衡因子&gt;0 → 先右旋右孩子，再左旋当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">getBalanceFactor</span>(root-&gt;right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        root-&gt;right = <span class="built_in">rightRotate</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leftRotate</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未失衡，返回原根节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>哈夫曼树（也叫最优二叉树）：对于一组带有确定权值的叶子节点，构造的二叉树中带权路径长度（WPL）最小的二叉树。</p>
<h3 id="构建思路"><a href="#构建思路" class="headerlink" title="构建思路"></a>构建思路</h3><p>反复合并最小权值的两棵树，直到只剩一棵</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(HuffmanNode* a,HuffmanNode* b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;weight&gt;b-&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">HuffmanNode* <span class="title">buildHuffmanTree</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;weights)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;HuffmanNode*,vector&lt;HuffmanNode*&gt;,Compare&gt; minHeap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> weight:weights) minHeap.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">HuffmanNode</span>(weight));</span><br><span class="line">    <span class="keyword">while</span>(minHeap.<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        HuffmanNode* left=minHeap.<span class="built_in">top</span>();</span><br><span class="line">        minHeap.<span class="built_in">pop</span>();</span><br><span class="line">        HuffmanNode* right=minHeap.<span class="built_in">top</span>();</span><br><span class="line">        minHeap.<span class="built_in">pop</span>();</span><br><span class="line">        HuffmanNode* parent= <span class="keyword">new</span> <span class="built_in">HuffmanNode</span>(left-&gt;weight+right-&gt;weight);</span><br><span class="line">        parent-&gt;left=left;</span><br><span class="line">        parent-&gt;right=right;</span><br><span class="line">        minHeap.<span class="built_in">push</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minHeap.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculateWPL</span><span class="params">(HuffmanNode* root,<span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right) <span class="keyword">return</span> root-&gt;weight*depth;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">calculateWPL</span>(root-&gt;left,depth<span class="number">+1</span>)+<span class="built_in">calculateWPL</span>(root-&gt;right,depth<span class="number">+1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>左分支标记为 0，右分支标记为 1</p>
<h2 id="m阶B-树"><a href="#m阶B-树" class="headerlink" title="m阶B-树"></a>m阶B-树</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li><strong>阶数约束</strong>：每个节点最多有 m 个子节点。</li>
<li><strong>关键字数量范围</strong>：<br>非根节点（无论叶子或非叶子）：关键字数 k 满足 ⌈m&#x2F;2⌉ - 1 ≤ k ≤ m - 1；<br>根节点：若为非叶子节点，1 ≤ k ≤ m - 1；若为树中唯一节点（叶子），k 可为 0 或 1。<br>子节点与关键字数量关系：节点的子节点数 &#x3D; 关键字数 + 1。</li>
<li><strong>有序性与范围约束</strong>：<br>单个节点内的关键字严格升序排列；<br>子树关键字范围由父节点关键字划分，左子树关键字小于对应父关键字，右子树关键字大于对应父关键字。</li>
<li><strong>平衡性质</strong>：所有叶子节点都位于同一层。</li>
<li><strong>动态维护性质</strong>：插入时节点关键字数超上限则触发分裂，删除时节点关键字数低于下限则触发借关键字或合并，操作后仍保持所有核心性质。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>B - 树：关键字分布在所有节点，叶子节点和非叶子节点都存数据；</li>
<li>B + 树：仅叶子节点存数据，非叶子节点只存索引，叶子节点通过链表相连（更适合范围查询）；</li>
</ul>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="查找方法评价指标"><a href="#查找方法评价指标" class="headerlink" title="查找方法评价指标"></a>查找方法评价指标</h2><ul>
<li>平均查找长度(ASL)：查找过程中主要操作是关键字的比较，查找过程中关键字的平均比较次数（平均查找长度）作为衡量一个查找算法效率高低的标准。</li>
<li>ASL&#x3D;Pi*Ci(累加)</li>
<li>Pi为查找第i个元素的概率</li>
<li>Ci为找到第i个元素所需的关键字与给定值的比较次数</li>
</ul>
<h2 id="查找方法分类"><a href="#查找方法分类" class="headerlink" title="查找方法分类"></a>查找方法分类</h2><ul>
<li>顺序表和链表的查找</li>
<li>哈希表的查找</li>
<li>索引查找表的查找</li>
</ul>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键：确定好循环不变量的定义。确定好if()括号内判断的逻辑。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">// 防止溢出 等同于(left + right)/2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>; <span class="comment">// target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(log n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="经典题"><a href="#经典题" class="headerlink" title="经典题"></a>经典题</h3><ul>
<li><a target="_blank" rel="noopener" href="https://matrix.sysu.edu.cn/course/private/2280281/assignment/2864759">跳石头</a></li>
</ul>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="理论基础-1"><a href="#理论基础-1" class="headerlink" title="理论基础"></a><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">理论基础</a></h3><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h2><ul>
<li>在待排序序列中，若存在两个或多个关键字相等的元素，排序后它们的相对顺序与排序前保持一致，则称该排序算法是「稳定的」；反之则为「不稳定的」。</li>
</ul>
<h2 id="衡量排序方法的标准"><a href="#衡量排序方法的标准" class="headerlink" title="衡量排序方法的标准"></a>衡量排序方法的标准</h2><ul>
<li>平均比较次数</li>
<li>平均移动</li>
<li>平均辅助存储空间</li>
<li>稳定性</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>将数组划分为已排序（初始仅首个元素）和未排序区间，依次取出未排序区间的元素，向前插入到已排序区间的合适位置（保证已排序区间始终有序），直至所有元素插入完成。</p>
<h4 id="代码模板-2"><a href="#代码模板-2" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(std::vector&lt;T&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空数组或单元素数组无需排序</span></span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已排序区间初始为 [0]，未排序区间从 i=1 开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 保存当前待插入的元素（避免移动过程中被覆盖）</span></span><br><span class="line">        T temp = arr[i];</span><br><span class="line">        <span class="comment">// j 指向已排序区间的最后一个元素，向前遍历找插入位置</span></span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向前比较：若已排序元素 &gt; 待插入元素，则后移（腾出插入位置）</span></span><br><span class="line">        <span class="comment">// 相等元素不移动 → 保证稳定性</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];  <span class="comment">// 元素后移</span></span><br><span class="line">            --j;                  <span class="comment">// 继续向前找</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到插入位置（j+1），放入待插入元素</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O (n²)</li>
<li>稳定排序</li>
</ul>
<h4 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h4><blockquote>
<p>以数组 [5, 2, 9, 3, 7] 为例，直接插入排序过程如下（已排序区间用「」标注，未排序区间用 () 标注）：<br>初始状态：「5」，(2, 9, 3, 7)<br>取未排序首元素 2，插入「5」的合适位置 → 「2, 5」，(9, 3, 7)<br>取 9，插入「2, 5」末尾（9&gt;5）→ 「2, 5, 9」，(3, 7)<br>取 3，向前比较：5&gt;3 则后移，2≤3 则插入 → 「2, 3, 5, 9」，(7)<br>取 7，向前比较：9&gt;7 则后移，5≤7 则插入 → 「2, 3, 5, 7, 9」（完成）。</p>
</blockquote>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p>希尔排序基本思想：作为直接插入排序的改进算法，先按递减的增量（步长）将数组划分为若干个子序列，对每个子序列分别执行直接插入排序；逐步缩小增量直至为 1，最后对整个数组执行一次直接插入排序（此时数组已基本有序，大幅降低插入排序的时间开销）。</p>
<h4 id="代码模板-3"><a href="#代码模板-3" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSortWithGap</span><span class="params">(std::vector&lt;T&gt;&amp; arr, <span class="type">int</span> gap)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑和普通插入排序完全一致，仅将“1”改为“gap”</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; ++i) &#123;</span><br><span class="line">        T temp = arr[i]; <span class="comment">// 保存待插入元素</span></span><br><span class="line">        <span class="type">int</span> j = i-gap; <span class="comment">// 已排序序列最后一个元素</span></span><br><span class="line">        <span class="comment">// 向前遍历子序列（步长gap），找到插入位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">            arr[j + gap] = arr[j]; <span class="comment">// 元素后移（步长gap）</span></span><br><span class="line">            j -= gap;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + gap] = temp; <span class="comment">// 插入到合适位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(std::vector&lt;T&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外层仅控制步长（增量），核心排序逻辑复用插入排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前步长gap=&quot;</span> &lt;&lt; gap &lt;&lt; <span class="string">&quot;，调用带步长的插入排序&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">insertionSortWithGap</span>(arr, gap); <span class="comment">// 复用插入排序处理当前步长的子序列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O (n log n) ~ O (n²) 之间</li>
<li>不稳定排序</li>
</ul>
<h4 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h4><blockquote>
<p>数组：[8,5,9,1,7,2,6,4]<br>选短数组 + 简单间隔（8→4→2→1）<br>初始状态<br>数组：[8, 5, 9, 1, 7, 2, 6, 4]数组长度 n&#x3D;8，初始间隔（gap）&#x3D;8&#x2F;2&#x3D;4<br>第一步：gap&#x3D;4（大间隔分组粗排）<br>分组规则：索引差 4 为一组，共 4 组<br>组 1（索引 0、4）：8、7 → 插入排序后：7、8<br>组 2（索引 1、5）：5、2 → 插入排序后：2、5<br>组 3（索引 2、6）：9、6 → 插入排序后：6、9<br>组 4（索引 3、7）：1、4 → 插入排序后：1、4<br>排序后数组：[7, 2, 6, 1, 8, 5, 9, 4]（从完全乱序→初步有序）<br>第二步：gap&#x3D;2（缩小间隔再粗排）<br>分组规则：索引差 2 为一组，共 2 组<br>组 1（索引 0、2、4、6）：7、6、8、9 → 插入排序后：6、7、8、9<br>组 2（索引 1、3、5、7）：2、1、5、4 → 插入排序后：1、2、4、5<br>排序后数组：[6, 1, 7, 2, 8, 4, 9, 5]（更接近有序，仅需微调）<br>第三步：gap&#x3D;1（间隔 1 &#x3D; 普通插入排序）<br>此时数组[6,1,7,2,8,4,9,5]已基本有序，插入排序仅需少量调整：<br>1 插到 6 前 → [1,6,7,2,8,4,9,5]<br>2 插到 6 前 → [1,2,6,7,8,4,9,5]<br>4 插到 6 前 → [1,2,4,6,7,8,9,5]<br>5 插到 9 前 → 最终：[1,2,4,5,6,7,8,9]</p>
</blockquote>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h4><ul>
<li>俩俩比较待排序对象的关键字</li>
</ul>
<h4 id="代码模板-4"><a href="#代码模板-4" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 外层循环：控制排序轮数（n个元素最多需要n-1轮）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="type">bool</span> swapped = <span class="literal">false</span>; <span class="comment">// 优化：标记本轮是否发生交换（提前终止）</span></span><br><span class="line">        <span class="comment">// 内层循环：每轮比较相邻元素，把最大的&quot;冒泡&quot;到末尾</span></span><br><span class="line">        <span class="comment">// 每轮结束后，末尾i个元素已排好，无需重复比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; ++j) &#123;</span><br><span class="line">            <span class="comment">// 相邻元素逆序，交换位置</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]); </span><br><span class="line">                swapped = <span class="literal">true</span>; <span class="comment">// 标记有交换发生</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 本轮无交换 → 数组已完全有序，直接退出（优化效率）</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n²)</li>
<li>稳定排序（判断条件为arr[j] &#x3D;&#x3D;&gt;&#x3D;&#x3D; arr[j+1]）</li>
</ul>
<h4 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h4><blockquote>
<p>数组初始状态：21 25 49 25* 16 8<br>第一趟：21 25 25* 16 8 49<br>第二趟：21 25 16 8 25* 49<br>第三趟：21 16 8 25 25* 49<br>第四趟：16 8 21 25 25* 49<br>第五趟：8 16 21 25 25* 49</p>
</blockquote>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul>
<li>选一个基准值；<br>遍历数组，将比基准小的放左、大的放右，基准归位（最终排序位置）；<br>递归对基准左右的子数组重复操作，直到子数组仅 1 个元素（天然有序）。</li>
</ul>
<h4 id="代码模板-5"><a href="#代码模板-5" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> x=nums[l],i=l<span class="number">-1</span>,j=r<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">do</span> i++;<span class="keyword">while</span>(nums[i]&lt;x);</span><br><span class="line">            <span class="keyword">do</span> j--;<span class="keyword">while</span>(nums[j]&gt;x);</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums,l,j);</span><br><span class="line">        <span class="built_in">sort</span>(nums,j<span class="number">+1</span>,r);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：复杂度 O (n log n)</li>
<li>不稳定排序 适用于n较大的情况</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><h4 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h4><ul>
<li>外层循环：遍历数组，确定每轮要归位的位置（第i轮处理索引i）；<br>内层循环：在[i, 数组末尾]的未排序区间，找到最小值的索引；<br>交换：将最小值与未排序区间的第一个元素（索引i）交换，完成该位置的归位；<br>重复上述步骤，直到所有元素归位。</li>
</ul>
<h4 id="代码模板-6"><a href="#代码模板-6" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 外层循环：确定每轮归位的位置i（0到n-2，最后1个元素无需处理）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> minIdx = i; <span class="comment">// 初始化最小值索引为当前未排序区间的第一个位置</span></span><br><span class="line">        <span class="comment">// 内层循环：在[i, n-1]找最小值的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx]) &#123;</span><br><span class="line">                minIdx = j; <span class="comment">// 更新最小值索引</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换：把最小值放到索引i的位置（归位）</span></span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[minIdx]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n²)</li>
<li>不稳定排序</li>
</ul>
<h4 id="举例-6"><a href="#举例-6" class="headerlink" title="举例"></a>举例</h4><blockquote>
<p>数组初始状态：6, 3, 8, 5, 9, 1, 7, 2, 4, 0<br>第一轮 [0, 3, 8, 5, 9, 1, 7, 2, 4, 6]<br>第二轮 [0, 1, 8, 5, 9, 3, 7, 2, 4, 6]<br>第三轮 [0, 1, 2, 5, 9, 3, 7, 8, 4, 6]<br>第四轮 [0, 1, 2, 3, 9, 5, 7, 8, 4, 6]<br>第五轮 [0, 1, 2, 3, 4, 5, 7, 8, 9, 6]<br>第六轮 不变<br>第七轮 [0, 1, 2, 3, 4, 5, 6, 8, 9, 7]<br>第八轮 [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]<br>第九轮 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</p>
</blockquote>
<h3 id="树形选择排序-打擂台"><a href="#树形选择排序-打擂台" class="headerlink" title="树形选择排序(打擂台)"></a>树形选择排序(打擂台)</h3><h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h4><blockquote>
<pre><code>     15
    25 15
  25 28 19 15
49 25 37 28 19 65 15 34
</code></pre>
<p>每个枝结点的关键字都等于其左、右孩子结点中较小的关键字，根结点是最小的。<br>输出最小关键字后，只需将叶子结点中的最小关键字改为最大值，然后重复上述步骤即可</p>
</blockquote>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ul>
<li>堆是基于完全二叉树的一种数据结构，核心满足「堆序性」，分为两种类型（升序排序常用大顶堆）：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">堆类型</th>
<th align="left">核心规则</th>
<th align="left">关键特征</th>
</tr>
</thead>
<tbody><tr>
<td align="left">大顶堆</td>
<td align="left">每个父节点值 ≥ 左右子节点值</td>
<td align="left">堆顶是全局最大值</td>
</tr>
<tr>
<td align="left">小顶堆</td>
<td align="left">每个父节点值 ≤ 左右子节点值</td>
<td align="left">堆顶是全局最小值</td>
</tr>
</tbody></table>
<ul>
<li>数组模拟堆（索引从 0 开始）：<br>父节点 i 的左子节点：2i+1，右子节点：2i+2；<br>子节点 j 的父节点：(j-1)&#x2F;2（整数除法）。</li>
<li>堆的特点：序列中第一个元素为序列中最大（最小）值</li>
</ul>
<h4 id="代码模板-7"><a href="#代码模板-7" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大顶堆-&gt;升序 </span></span><br><span class="line"><span class="comment">// unsortLen为未排序区间（0,,,unsortLen）左闭右闭</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapAdjust</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> root,<span class="type">int</span> unsortLen)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> lChild=<span class="number">2</span>*root<span class="number">+1</span>,rChild=<span class="number">2</span>*root<span class="number">+2</span>;</span><br><span class="line">    <span class="type">int</span> maxIdx=root;</span><br><span class="line">    <span class="keyword">if</span>(lChild&lt;=unsortLen&amp;&amp;nums[lChild]&gt;nums[maxIdx]) maxIdx=lChild;</span><br><span class="line">    <span class="keyword">if</span>(rChild&lt;=unsortLen&amp;&amp;nums[rChild]&gt;nums[maxIdx]) maxIdx=rChild;</span><br><span class="line">    <span class="keyword">if</span>(root!=maxIdx)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[root],nums[maxIdx]);</span><br><span class="line">        <span class="built_in">heapAdjust</span>(nums,maxIdx,unsortLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> root=(n<span class="number">-1</span>)/<span class="number">2</span>;root&gt;=<span class="number">0</span>;root--) <span class="built_in">heapAdjust</span>(nums,root,n);<span class="comment">// 子节点 j 的父节点：(j-1)/2（整数除法）。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> unsortLen=n;unsortLen&gt;<span class="number">0</span>;unsortLen--)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>],nums[unsortLen]);</span><br><span class="line">        <span class="built_in">heapAdjust</span>(nums,<span class="number">0</span>,unsortLen<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小顶堆-&gt;降序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapAdjust</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> root,<span class="type">int</span> unsortLen)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> lChild=<span class="number">2</span>*root<span class="number">+1</span>,rChild=<span class="number">2</span>*root<span class="number">+2</span>;</span><br><span class="line">    <span class="type">int</span> minIdx=root;</span><br><span class="line">    <span class="keyword">if</span>(lChild&lt;=unsortLen&amp;&amp;nums[lChild]&lt;nums[minIdx]) minIdx=lChild;</span><br><span class="line">    <span class="keyword">if</span>(rChild&lt;=unsortLen&amp;&amp;nums[rChild]&lt;nums[minIdx]) minIdx=rChild;</span><br><span class="line">    <span class="keyword">if</span>(root!=minIdx)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[root],nums[minIdx]);</span><br><span class="line">        <span class="built_in">heapAdjust</span>(nums,minIdx,unsortLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> root=(n<span class="number">-1</span>)/<span class="number">2</span>;root&gt;=<span class="number">0</span>;root--) <span class="built_in">heapAdjust</span>(nums,root,n);<span class="comment">// 子节点 j 的父节点：(j-1)/2（整数除法）。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> unsortLen=n;unsortLen&gt;<span class="number">0</span>;unsortLen--)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>],nums[unsortLen]);</span><br><span class="line">        <span class="built_in">heapAdjust</span>(nums,<span class="number">0</span>,unsortLen<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(nlogn)</li>
<li>排序不稳定</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>分（拆分）：将待排序数组从中间递归拆分为左右两个子数组，直到每个子数组仅含 1 个元素（单个元素天然有序）。<br>治（合并）：将两个有序的子数组，通过双指针逐个比较、按大小合并为一个有序数组，逐层向上合并后得到最终有序数组。</p>
</blockquote>
<h3 id="代码模板-8"><a href="#代码模板-8" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;num,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(num,l,mid),<span class="built_in">merge_sort</span>(num,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>,i=l,j=mid<span class="number">+1</span>;</span><br><span class="line">    <span class="comment">// 双指针比较，把较小元素放入temp</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">    <span class="keyword">if</span>(num[i]&lt;=num[j]) temp[k++] = num[i++];<span class="comment">// 如果是num[i]&lt;num[j]排序会变得不稳定。</span></span><br><span class="line">    <span class="keyword">else</span> temp[k++] = num[j++];</span><br><span class="line">    <span class="comment">// 处理左子数组剩余元素</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) temp[k++]=num[i++];</span><br><span class="line">    <span class="comment">// 处理右子数组剩余元素</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) temp[k++]=num[j++];</span><br><span class="line">    <span class="comment">// 把temp中有序数据复制回原数组num的[l, r]区间</span></span><br><span class="line">    <span class="keyword">for</span>(i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) num[i]=temp[j]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(nlogn)</li>
<li>排序稳定</li>
</ul>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度搜索DFS"><a href="#深度搜索DFS" class="headerlink" title="深度搜索DFS"></a>深度搜索DFS</h3><h4 id="三部曲"><a href="#三部曲" class="headerlink" title="三部曲"></a>三部曲</h4><ul>
<li>确认递归函数参数</li>
<li>确认终止条件</li>
<li>处理目前搜索节点出发的路径</li>
</ul>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a><a target="_blank" rel="noopener" href="https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E6%B7%B1%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#dfs-%E4%B8%8E-bfs-%E5%8C%BA%E5%88%AB">思路</a></h4><h4 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">dfs</span>(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1170">模板题</a></h4><h4 id="代码模板-9"><a href="#代码模板-9" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵写法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 收集符合条件的路径</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 1节点到终点的路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前遍历的节点x 到达节点n </span></span><br><span class="line">    <span class="keyword">if</span> (x == n) &#123; <span class="comment">// 找到符合条件的一条路径</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历节点x链接的所有节点</span></span><br><span class="line">        <span class="keyword">if</span> (graph[x][i] == <span class="number">1</span>) &#123; <span class="comment">// 找到 x链接的节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 遍历到的节点加入到路径中来</span></span><br><span class="line">            <span class="built_in">dfs</span>(graph, i, n); <span class="comment">// 进入下一层递归</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销本节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, s, t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="comment">// 使用邻接矩阵 表示无线图，1 表示 s 与 t 是相连的</span></span><br><span class="line">        graph[s][t] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">// 无论什么路径已经是从0节点出发</span></span><br><span class="line">    <span class="built_in">dfs</span>(graph, <span class="number">1</span>, n); <span class="comment">// 开始遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">size</span>() == <span class="number">0</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;pa : result) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pa.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            cout &lt;&lt; pa[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; pa[pa.<span class="built_in">size</span>() - <span class="number">1</span>]  &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表写法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 收集符合条件的路径</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 1节点到终点的路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">const</span> vector&lt;list&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == n) &#123; <span class="comment">// 找到符合条件的一条路径</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : graph[x]) &#123; <span class="comment">// 找到 x指向的节点</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(i); <span class="comment">// 遍历到的节点加入到路径中来</span></span><br><span class="line">        <span class="built_in">dfs</span>(graph, i, n); <span class="comment">// 进入下一层递归</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销本节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, s, t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span></span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>); <span class="comment">// 邻接表</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="comment">// 使用邻接表 ，表示 s -&gt; t 是相连的</span></span><br><span class="line">        graph[s].<span class="built_in">push_back</span>(t);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">// 无论什么路径已经是从0节点出发</span></span><br><span class="line">    <span class="built_in">dfs</span>(graph, <span class="number">1</span>, n); <span class="comment">// 开始遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">size</span>() == <span class="number">0</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;pa : result) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pa.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            cout &lt;&lt; pa[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; pa[pa.<span class="built_in">size</span>() - <span class="number">1</span>]  &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度搜索BFS"><a href="#广度搜索BFS" class="headerlink" title="广度搜索BFS"></a>广度搜索BFS</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>适合于解决两个点之间的最短路径问题。</p>
<h4 id="求单源最短路径，何时用BFS？何时用dijkstra？"><a href="#求单源最短路径，何时用BFS？何时用dijkstra？" class="headerlink" title="求单源最短路径，何时用BFS？何时用dijkstra？"></a>求单源最短路径，何时用BFS？何时用dijkstra？</h4><p>是否需要求解最短路径？<br>→ 是 → 图的边权是否相等（或无权）？<br>    → 是 → 用 BFS（高效简洁）<br>    → 否 → 边权是否非负？<br>      → 是 → 用 Dijkstra 算法（贪心+优先队列）<br>      → 否 → 用 Bellman-Ford&#x2F;SPFA 算法（处理负权）</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a><a target="_blank" rel="noopener" href="https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E5%B9%BF%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%B9%BF%E6%90%9C%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">思路</a></h4><h4 id="代码模板-10"><a href="#代码模板-10" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 表示四个方向</span></span><br><span class="line"><span class="comment">// grid 是地图，也就是一个二维数组</span></span><br><span class="line"><span class="comment">// visited标记访问过的节点，不要重复访问</span></span><br><span class="line"><span class="comment">// x,y 表示开始搜索节点的下标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que; <span class="comment">// 定义队列</span></span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y&#125;); <span class="comment">// 起始节点加入队列</span></span><br><span class="line">    visited[x][y] = <span class="literal">true</span>; <span class="comment">// 只要加入队列，立刻标记为访问过的节点</span></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123; <span class="comment">// 开始遍历队列里的元素</span></span><br><span class="line">        pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>(); <span class="comment">// 从队列取元素</span></span><br><span class="line">        <span class="type">int</span> curx = cur.first;</span><br><span class="line">        <span class="type">int</span> cury = cur.second; <span class="comment">// 当前节点坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 开始想当前节点的四个方向左右上下去遍历</span></span><br><span class="line">            <span class="type">int</span> nextx = curx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cury + dir[i][<span class="number">1</span>]; <span class="comment">// 获取周边四个方向的坐标</span></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;  <span class="comment">// 坐标越界了，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty]) &#123; <span class="comment">// 如果节点没被访问过</span></span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;);  <span class="comment">// 队列添加该节点为下一轮要遍历的节点</span></span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>; <span class="comment">// 只要加入队列立刻标记，避免重复访问</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>大家应该好奇，这一圈一圈的搜索过程是怎么做到的，是放在什么容器里，才能这样去遍历。<br>很多网上的资料都是直接说用队列来实现。<br>其实，我们仅仅需要一个容器，能保存我们要遍历过的元素就可以，那么用队列，还是用栈，甚至用数组，都是可以的。<br>用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针。<br>因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。<br>如果用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历。<br>因为栈是先进后出，加入元素和弹出元素的顺序改变了。<br>那么广搜需要注意 转圈搜索的顺序吗？ 不需要！<br>所以用队列，还是用栈都是可以的，但大家都习惯用队列了，所以下面的讲解用我也用队列来讲，只不过要给大家说清楚，并不是非要用队列，用栈也可以。</p>
</blockquote>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。（常用来解决连通性问题）</li>
</ul>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a><a target="_blank" rel="noopener" href="https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9">思路</a></h3><h4 id="代码模板-11"><a href="#代码模板-11" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Union</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; father;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">Union</span>(<span class="type">int</span> num)&#123;</span><br><span class="line">        father.<span class="built_in">resize</span>(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;++i) father[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==father[u]) <span class="keyword">return</span> u;</span><br><span class="line">        father[u]=<span class="built_in">find</span>(father[u]);<span class="comment">//路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> father[u];</span><br><span class="line">    &#125;<span class="comment">// 核心</span></span><br><span class="line"><span class="comment">// 将u-v 这条边加入并查集</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        u=<span class="built_in">find</span>(u);</span><br><span class="line">        v=<span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">return</span>;</span><br><span class="line">        father[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(u)==<span class="built_in">find</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="模板题-1"><a href="#模板题-1" class="headerlink" title="模板题"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1182">模板题</a></h3><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>生成树：是一个极小连通子图，它含有图中的全部顶点，但只有n-1条边。<br>生成森林：由若干棵生成树组成，含全部顶点，但构成这些树的边是最少的。<br>最小生成树：所有节点的最小连通子图，即：以最小的成本（边的权值）将图中所有节点链接到一起。</p>
<h3 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h3><h4 id="三部曲-1"><a href="#三部曲-1" class="headerlink" title="三部曲"></a>三部曲</h4><blockquote>
<p>第一步，选距离生成树最近节点<br>第二步，最近节点加入生成树<br>第三步，更新非生成树节点到生成树的距离（即更新minDist数组）</p>
</blockquote>
<h4 id="适用条件：无向图-连通图-无回路-权值无论正负"><a href="#适用条件：无向图-连通图-无回路-权值无论正负" class="headerlink" title="适用条件：无向图 连通图 无回路 权值无论正负"></a>适用条件：无向图 连通图 无回路 权值无论正负</h4><h4 id="模板题-2"><a href="#模板题-2" class="headerlink" title="模板题"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1053">模板题</a></h4><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a><a target="_blank" rel="noopener" href="https://programmercarl.com/kamacoder/0053.%E5%AF%BB%E5%AE%9D-prim.html#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">思路</a></h4><h4 id="代码模板-12"><a href="#代码模板-12" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> v, e;</span><br><span class="line">    <span class="type">int</span> x, y, k;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; e;</span><br><span class="line">    <span class="comment">// 填一个默认最大值，题目描述val最大为10000</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(v + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v + <span class="number">1</span>, <span class="number">10001</span>));</span><br><span class="line">    <span class="keyword">while</span> (e--) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">        <span class="comment">// 因为是双向图，所以两个方向都要填上</span></span><br><span class="line">        grid[x][y] = k;</span><br><span class="line">        grid[y][x] = k;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有节点到最小生成树的最小距离</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(v + <span class="number">1</span>, <span class="number">10001</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个节点是否在树里</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isInTree</span><span class="params">(v + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们只需要循环 n-1次，建立 n - 1条边，就可以把n个节点的图连在一起</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; v; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、prim三部曲，第一步：选距离生成树最近节点</span></span><br><span class="line">        <span class="type">int</span> cur = <span class="number">-1</span>; <span class="comment">// 选中哪个节点 加入最小生成树</span></span><br><span class="line">        <span class="type">int</span> minVal = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++) &#123; <span class="comment">// 1 - v，顶点编号，这里下标从1开始</span></span><br><span class="line">            <span class="comment">//  选取最小生成树节点的条件：</span></span><br><span class="line">            <span class="comment">//  （1）不在最小生成树里</span></span><br><span class="line">            <span class="comment">//  （2）距离最小生成树最近的节点</span></span><br><span class="line">            <span class="keyword">if</span> (!isInTree[j] &amp;&amp;  minDist[j] &lt; minVal) &#123;</span><br><span class="line">                minVal = minDist[j];</span><br><span class="line">                cur = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、prim三部曲，第二步：最近节点（cur）加入生成树</span></span><br><span class="line">        isInTree[cur] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新minDist数组）</span></span><br><span class="line">        <span class="comment">// cur节点加入之后， 最小生成树加入了新的节点，那么所有节点到 最小生成树的距离（即minDist数组）需要更新一下</span></span><br><span class="line">        <span class="comment">// 由于cur节点是新加入到最小生成树，那么只需要关心与 cur 相连的 非生成树节点 的距离 是否比 原来 非生成树节点到生成树节点的距离更小了呢</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++) &#123;</span><br><span class="line">            <span class="comment">// 更新的条件：</span></span><br><span class="line">            <span class="comment">// （1）节点是 非生成树里的节点</span></span><br><span class="line">            <span class="comment">// （2）与cur相连的某节点的权值 比 该某节点距离最小生成树的距离小</span></span><br><span class="line">            <span class="comment">// 很多录友看到自己 就想不明白什么意思，其实就是 cur 是新加入 最小生成树的节点，那么 所有非生成树的节点距离生成树节点的最近距离 由于 cur的新加入，需要更新一下数据了</span></span><br><span class="line">            <span class="keyword">if</span> (!isInTree[j] &amp;&amp; grid[cur][j] &lt; minDist[j]) &#123;</span><br><span class="line">                minDist[j] = grid[cur][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计结果</span></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= v; i++) &#123; <span class="comment">// 不计第一个顶点，因为统计的是边的权值，v个节点有 v-1条边</span></span><br><span class="line">        result += minDist[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h3><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><blockquote>
<p>边的权值排序，因为要优先选最小的边加入到生成树里<br>遍历排序后的边<br>如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环<br>如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合</p>
</blockquote>
<h4 id="代码模板-13"><a href="#代码模板-13" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Union</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; father;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Union</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">        father.<span class="built_in">resize</span>(n<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) father[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==father[u]) <span class="keyword">return</span> father[u];</span><br><span class="line">        father[u]=<span class="built_in">find</span>(father[u]);</span><br><span class="line">        <span class="keyword">return</span> father[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        u=<span class="built_in">find</span>(u);</span><br><span class="line">        v=<span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">return</span>;</span><br><span class="line">        father[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(u)==<span class="built_in">find</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> v,e;</span><br><span class="line">    cin&gt;&gt;v&gt;&gt;e;</span><br><span class="line">    vector&lt;Edge&gt; edges;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        edges.<span class="built_in">push_back</span>(&#123;u,v,w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(),edges.<span class="built_in">end</span>(),[&amp;](<span class="type">const</span> Edge a,<span class="type">const</span> Edge b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="function">Union <span class="title">setv</span><span class="params">(v)</span></span>;</span><br><span class="line">    <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> edge:edges)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!setv.<span class="built_in">isSame</span>(edge.u,edge.v))&#123;</span><br><span class="line">            setv.<span class="built_in">join</span>(edge.u,edge.v);</span><br><span class="line">            result+=edge.w;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="prim与kruskal对比总结"><a href="#prim与kruskal对比总结" class="headerlink" title="prim与kruskal对比总结"></a>prim与kruskal对比总结</h4><ul>
<li>prim维护的是节点的集合，而 Kruskal 维护的是边的集合。</li>
<li>Prim 算法 时间复杂度为 O(n^2)，其中 n 为节点数量，它的运行效率和图中边树无关，适用稠密图。</li>
<li>Kruskal算法 时间复杂度 为 nlogn，其中n 为边的数量，适用稀疏图。</li>
</ul>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h3><ul>
<li>AOV网：用顶点表示活动的网络</li>
<li>AOE网：用边表示活动的网络</li>
</ul>
<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>给出一个 有向图，把这个有向图转成线性的排序 就叫拓扑排序。</li>
<li>拓扑排序也是图论中判断有向无环图的常用方法。</li>
</ul>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><ul>
<li>找到入度为0 的节点，加入结果集</li>
<li>将该节点从图中移除</li>
<li>循环以上俩步</li>
</ul>
<h3 id="代码模板-14"><a href="#代码模板-14" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(N);</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> S,T;</span><br><span class="line">        cin&gt;&gt;S&gt;&gt;T;</span><br><span class="line">        graph[S].<span class="built_in">push_back</span>(T);</span><br><span class="line">        inDegree[T]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) <span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> cur=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:graph[cur]) <span class="keyword">if</span>(--inDegree[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result.<span class="built_in">size</span>()==N)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>;i++) cout&lt;&lt;result[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;result[N<span class="number">-1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断是否有环"><a href="#判断是否有环" class="headerlink" title="判断是否有环"></a>判断是否有环</h3><ul>
<li>结果集元素个数 不等于 图中节点个数，我们就可以认定图中一定有 有向环！</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>O(n+e)</li>
</ul>
<h3 id="AOE网络核心定义"><a href="#AOE网络核心定义" class="headerlink" title="AOE网络核心定义"></a>AOE网络核心定义</h3><ul>
<li>Ve(j)：从起点到本节点的最长的路径。意味着事件最早能够发生的时刻。</li>
<li>Vl(j)：不影响工程的如期完工，本节点事件必须发生的时刻。</li>
<li>e(ai)：活动的最早开始时间 e(ai)&#x3D;Ve(j)</li>
<li>l(ai)：活动的最迟开始时间 l(ai)&#x3D;Vl(k)-dut(j,k)</li>
<li>关键活动：最早开始时间&#x3D;最迟开始时间的活动</li>
<li>关键路径：从原点到汇点的最长的一条路径，或者全部由关键活动构成的路径</li>
</ul>
<h3 id="AOE网络关键路径求解"><a href="#AOE网络关键路径求解" class="headerlink" title="AOE网络关键路径求解"></a>AOE网络关键路径求解</h3><ul>
<li>核心步骤：<br>拓扑排序得到拓扑序列；<br>按拓扑序计算Ve（事件最早发生时间）；<br>按逆拓扑序计算Vl（事件最迟发生时间）；<br>计算所有活动的e和l，找出关键活动；<br>关键活动构成的路径即为关键路径。</li>
<li>代码模板</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边结构体：to=邻接顶点，weight=活动持续时间</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, weight;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t, <span class="type">int</span> w) : <span class="built_in">to</span>(t), <span class="built_in">weight</span>(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> N, M; <span class="comment">// N=事件数（顶点），M=活动数（边）</span></span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    vector&lt;list&lt;Edge&gt;&gt; <span class="built_in">graph</span>(N);       <span class="comment">// 正邻接表</span></span><br><span class="line">    vector&lt;list&lt;Edge&gt;&gt; <span class="built_in">reverseGraph</span>(N);<span class="comment">// 逆邻接表（用于逆拓扑序计算Vl）</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(N, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Ve</span><span class="params">(N, <span class="number">0</span>)</span></span>;              <span class="comment">// 事件最早发生时间</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Vl</span><span class="params">(N, INT_MAX)</span></span>;        <span class="comment">// 事件最迟发生时间</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; topoOrder;             <span class="comment">// 拓扑序列</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="type">int</span> S, T, W;</span><br><span class="line">        cin &gt;&gt; S &gt;&gt; T &gt;&gt; W;</span><br><span class="line">        graph[S].<span class="built_in">emplace_back</span>(T, W);</span><br><span class="line">        reverseGraph[T].<span class="built_in">emplace_back</span>(S, W);</span><br><span class="line">        inDegree[T]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤1：拓扑排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        topoOrder.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge : graph[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--inDegree[edge.to] == <span class="number">0</span>) q.<span class="built_in">push</span>(edge.to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (topoOrder.<span class="built_in">size</span>() != N) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;存在环，无法计算关键路径&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤2：计算Ve（拓扑序）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u : topoOrder) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge : graph[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = edge.to;</span><br><span class="line">            Ve[v] = <span class="built_in">max</span>(Ve[v], Ve[u] + edge.weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤3：计算Vl（逆拓扑序）</span></span><br><span class="line">    Vl[topoOrder.<span class="built_in">back</span>()] = Ve[topoOrder.<span class="built_in">back</span>()]; <span class="comment">// 汇点Vl=Ve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = topoOrder.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> u = topoOrder[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge : graph[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = edge.to;</span><br><span class="line">            Vl[u] = <span class="built_in">min</span>(Vl[u], Vl[v] - edge.weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤4：输出关键活动和工程最短完成时间</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;关键活动（边&lt;u,v&gt;）：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; N; u++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge : graph[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = edge.to;</span><br><span class="line">            <span class="type">int</span> e = Ve[u];          <span class="comment">// 活动最早开始时间</span></span><br><span class="line">            <span class="type">int</span> l = Vl[v] - edge.weight; <span class="comment">// 活动最迟开始时间</span></span><br><span class="line">            <span class="keyword">if</span> (e == l) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; u &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;&gt; （持续时间：&quot;</span> &lt;&lt; edge.weight &lt;&lt; <span class="string">&quot;）&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;工程最短完成时间：&quot;</span> &lt;&lt; Ve[topoOrder.<span class="built_in">back</span>()] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="dijkstra算法"><a href="#dijkstra算法" class="headerlink" title="dijkstra算法"></a>dijkstra算法</h3><ul>
<li><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1047">模板题</a></li>
</ul>
<h4 id="朴素版dijkstra"><a href="#朴素版dijkstra" class="headerlink" title="朴素版dijkstra"></a>朴素版dijkstra</h4><h5 id="三部曲-2"><a href="#三部曲-2" class="headerlink" title="三部曲"></a>三部曲</h5><blockquote>
<p>1、选源点到哪个节点近且该节点未被访问过<br>(源点距离源点最近，距离为0，且未被访问。)<br>2、该最近节点被标记访问过<br>(标记源点访问过)<br>3、更新非访问节点到源点的距离<br>(即更新minDist数组)</p>
</blockquote>
<h5 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h5><p>&#x3D;&#x3D;单源&#x3D;&#x3D;最短路，即可求一点出发到任意点的最短路径。<br>不能出现&#x3D;&#x3D;负数权值&#x3D;&#x3D;</p>
<h5 id="与prim算法的区别"><a href="#与prim算法的区别" class="headerlink" title="与prim算法的区别"></a>与prim算法的区别</h5><p>对比prim算法的三部曲：<br>第一步，选距离生成树最近节点<br>第二步，最近节点加入生成树<br>第三步，更新非生成树节点到生成树的距离（即更新minDist数组）<br>prim算法支持负数权值</p>
<h5 id="代码模板-15"><a href="#代码模板-15" class="headerlink" title="代码模板"></a>代码模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, p1, p2, val;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, INT_MAX));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;</span><br><span class="line">        grid[p1][p2] = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end = n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储从源点到每个节点的最短距离</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录顶点是否被访问过</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    minDist[start] = <span class="number">0</span>;  <span class="comment">// 起始点到自身的距离为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历所有节点</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> minVal = INT_MAX;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、选距离源点最近且未访问过的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; ++v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; minDist[v] &lt; minVal) &#123;</span><br><span class="line">                minVal = minDist[v];</span><br><span class="line">                cur = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[cur] = <span class="literal">true</span>;  <span class="comment">// 2、标记该节点已被访问</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; minDist[cur] + grid[cur][v] &lt; minDist[v]) &#123;</span><br><span class="line">                minDist[v] = minDist[cur] + grid[cur][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="comment">// 不能到达终点</span></span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl; <span class="comment">// 到达终点最短路径</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(n^2)</li>
</ul>
<h5 id="如何求路径？"><a href="#如何求路径？" class="headerlink" title="如何求路径？"></a>如何求路径？</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, p1, p2, val;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, INT_MAX));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;</span><br><span class="line">        grid[p1][p2] = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end = n;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    minDist[start] = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//加上初始化</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> minVal = INT_MAX;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; ++v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; minDist[v] &lt; minVal) &#123;</span><br><span class="line">                minVal = minDist[v];</span><br><span class="line">                cur = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[cur] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; minDist[cur] + grid[cur][v] &lt; minDist[v]) &#123;</span><br><span class="line">                minDist[v] = minDist[cur] + grid[cur][v];</span><br><span class="line">                parent[v] = cur; <span class="comment">// 记录边</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最短情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; parent[i] &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1</span>-&gt;<span class="number">1</span></span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line"><span class="number">2</span>-&gt;<span class="number">3</span></span><br><span class="line"><span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line"><span class="number">4</span>-&gt;<span class="number">5</span></span><br><span class="line"><span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line"><span class="number">5</span>-&gt;<span class="number">7</span></span><br></pre></td></tr></table></figure>
<h4 id="堆优化版dijkstra"><a href="#堆优化版dijkstra" class="headerlink" title="堆优化版dijkstra"></a>堆优化版dijkstra</h4><h5 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h5><p>用最小堆自动排序，时间缩短至logn。<br>用邻接表优化邻接矩阵（适用于稀疏图）</p>
<h5 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h5><p>堆： 一般用stl中的优先队列(priority_queue)实现。<br>自定义堆的排序规则:<br>一般用自定义比较结构体实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123; <span class="type">int</span> val; <span class="type">int</span> weight; &#125;;</span><br><span class="line"><span class="comment">// 自定义比较器：按weight降序（weight大的优先级高）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareNode</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Node&amp; a, <span class="type">const</span> Node&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.weight &lt; b.weight; <span class="comment">// comp(a,b) = a.weight &lt; b.weight</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, CompareNode&gt; pq;</span><br><span class="line">pq.<span class="built_in">push</span>(&#123;<span class="number">1</span>, <span class="number">5</span>&#125;); <span class="comment">// a</span></span><br><span class="line">pq.<span class="built_in">push</span>(&#123;<span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// b</span></span><br></pre></td></tr></table></figure>
<p>如何确定优先级？</p>
<blockquote>
<p>要理解「comp(a, b) &#x3D; true 则 b 优，false 则 a 优」的底层原理，核心要抓住两个关键点：<br>C++ priority_queue 的底层是二叉堆，堆的核心规则是「父节点优先级 ≥ 子节点优先级」；<br>比较器 comp 的设计语义是：判断 a 是否应该被放在 b 的下方（优先级更低） —— 这是 STL 对 “严格弱序” 比较器的标准化设计。</p>
</blockquote>
<p>快速验证：</p>
<blockquote>
<p>目标：x(weight&#x3D;3) 优先级 &gt; y(weight&#x3D;5)；<br>比较器：comp(a,b) &#x3D; a.weight &gt; b.weight；<br>计算 comp(x,y) &#x3D; 3&gt;5 → false → 符合预期（x 优先级高）。</p>
</blockquote>
<h6 id="代码模板-16"><a href="#代码模板-16" class="headerlink" title="代码模板"></a>代码模板</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="comment">// 小顶堆</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义一个结构体来表示带权重的边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to;  <span class="comment">// 邻接顶点</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 边的权重</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t, <span class="type">int</span> w): <span class="built_in">to</span>(t), <span class="built_in">val</span>(w) &#123;&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, p1, p2, val;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;list&lt;Edge&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val; </span><br><span class="line">        <span class="comment">// p1 指向 p2，权值为 val</span></span><br><span class="line">        grid[p1].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(p2, val));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start = <span class="number">1</span>;  <span class="comment">// 起点</span></span><br><span class="line">    <span class="type">int</span> end = n;    <span class="comment">// 终点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储从源点到每个节点的最短距离</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录顶点是否被访问过</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 优先队列中存放 pair&lt;节点，源点到该节点的权值&gt;</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化队列，源点到源点的距离为0，所以初始为0</span></span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(start, <span class="number">0</span>)); </span><br><span class="line">    </span><br><span class="line">    minDist[start] = <span class="number">0</span>;  <span class="comment">// 起始点到自身的距离为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）</span></span><br><span class="line">        <span class="comment">// &lt;节点， 源点到该节点的距离&gt;</span></span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cur = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (visited[cur.first]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 第二步，该最近节点被标记访问过</span></span><br><span class="line">        visited[cur.first] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）</span></span><br><span class="line">        <span class="keyword">for</span> (Edge edge : grid[cur.first]) &#123; <span class="comment">// 遍历 cur指向的节点，cur指向的节点为 edge</span></span><br><span class="line">            <span class="comment">// cur指向的节点edge.to，这条边的权值为 edge.val</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[edge.to] &amp;&amp; minDist[cur.first] + edge.val &lt; minDist[edge.to]) &#123; <span class="comment">// 更新minDist</span></span><br><span class="line">                minDist[edge.to] = minDist[cur.first] + edge.val;</span><br><span class="line">                pq.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(edge.to, minDist[edge.to]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="comment">// 不能到达终点</span></span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl; <span class="comment">// 到达终点最短路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间复杂度：O(ElogE) E 为边的数量</li>
<li>空间复杂度：O(N + E) N 为节点的数量</li>
</ul>
<h3 id="Floy算法"><a href="#Floy算法" class="headerlink" title="Floy算法"></a>Floy算法</h3><h4 id="核心：动态规划求多源最短路径（对边的权值正负没有要求）"><a href="#核心：动态规划求多源最短路径（对边的权值正负没有要求）" class="headerlink" title="核心：动态规划求多源最短路径（对边的权值正负没有要求）"></a>核心：动态规划求多源最短路径（对边的权值正负没有要求）</h4><h4 id="思路：最好直接看三维讲解"><a href="#思路：最好直接看三维讲解" class="headerlink" title="思路：最好直接看三维讲解"></a>思路：最好直接看<a target="_blank" rel="noopener" href="https://programmercarl.com/kamacoder/0097.%E5%B0%8F%E6%98%8E%E9%80%9B%E5%85%AC%E5%9B%AD.html#%E6%80%9D%E8%B7%AF">三维讲解</a></h4><h4 id="动态规划五部曲："><a href="#动态规划五部曲：" class="headerlink" title="动态规划五部曲："></a>动态规划五部曲：</h4><ul>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ul>
<h4 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h4><ul>
<li>grid[i][j][k] &#x3D; m，表示 节点i 到 节点j 以[1…k] 集合中的一个节点为中间节点的最短距离为m。</li>
<li>递推公式定义（俩种情况）：<br>节点i 到 节点j 的最短路径经过节点k<br>节点i 到 节点j 的最短路径不经过节点k</li>
<li>遍历顺序(和积分类似，以k为基础，遍历ij面，对于每k层的每个ij点，更新其最小值)：从k&#x3D;0层开始向上递推&#x3D;&#x3D;更新&#x3D;&#x3D;</li>
</ul>
<h4 id="代码模板-17"><a href="#代码模板-17" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, p1, p2, val;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">10005</span>)));  <span class="comment">// 因为边的最大距离是10^4</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;</span><br><span class="line">        grid[p1][p2][<span class="number">0</span>] = val;</span><br><span class="line">        grid[p2][p1][<span class="number">0</span>] = val; <span class="comment">// 注意这里是双向图</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始 floyd</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                grid[i][j][k] = <span class="built_in">min</span>(grid[i][j][k<span class="number">-1</span>], grid[i][k][k<span class="number">-1</span>] + grid[k][j][k<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="type">int</span> z, start, end;</span><br><span class="line">    cin &gt;&gt; z;</span><br><span class="line">    <span class="keyword">while</span> (z--) &#123;</span><br><span class="line">        cin &gt;&gt; start &gt;&gt; end;</span><br><span class="line">        <span class="keyword">if</span> (grid[start][end][n] == <span class="number">10005</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; grid[start][end][n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>内容及代码有任何错误欢迎留言指正。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>数据结构与算法(长期更新)</p><p><a href="http://example.com/2026/01/23/数据结构与算法-长期更新/">http://example.com/2026/01/23/数据结构与算法-长期更新/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>jasper0507</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2026-01-23</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2026-01-23</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><a class="link-muted mr-2" rel="tag" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">期末复习</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2026/01/23/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%A9%E7%94%A8Github%E3%80%81Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E8%B6%85%E8%AF%A6%E7%BB%86%E7%89%88/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">零基础利用Github、Hexo搭建个人博客(超详细版)</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2026/01/22/%E5%A6%82%E4%BD%95%E6%96%B0%E5%A2%9E%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%EF%BC%9F/"><span class="level-item">如何新增博客内容？</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card" id="comments"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="SOHUCS" sid="2026/01/23/数据结构与算法-长期更新/"></div><script charset="utf-8" src="https://changyan.sohu.com/upload/changyan.js"></script><script>window.changyan.api.config({appid: 'cyykBqHOU',conf: 'prod_dd381aee15200b0623a13b743fafb099'});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.webp" alt="jasper0507"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">jasper0507</p><p class="is-size-6 is-block">Software Engineering student at SYSU</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">10</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/jasper0507" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/jasper0507"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="QQ" href="https://s41.ax1x.com/2026/01/23/pZgZmH1.jpg"><i class="fab fa-qq"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="WeChat" href="https://s41.ax1x.com/2026/01/23/pZgZuAx.jpg"><i class="fab fa-weixin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Bilibili" href="https://space.bilibili.com/501118683?spm_id_from=333.1007.0.0"><i class="fab fa-bilibili"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#栈与队列"><span class="level-left"><span class="level-item">1</span><span class="level-item">栈与队列</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#逆波兰表达式"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">逆波兰表达式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#中缀表达式转化为后缀表达式"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">中缀表达式转化为后缀表达式</span></span></a></li><li><a class="level is-mobile" href="#后缀表达式求值"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">后缀表达式求值</span></span></a></li><li><a class="level is-mobile" href="#代码实现"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">代码实现</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#字符串"><span class="level-left"><span class="level-item">2</span><span class="level-item">字符串</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#KMP算法"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">KMP算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#关键定义"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">关键定义</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#二叉树"><span class="level-left"><span class="level-item">3</span><span class="level-item">二叉树</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#理论基础"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">理论基础</span></span></a></li><li><a class="level is-mobile" href="#遍历方式"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">遍历方式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#DFS"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">DFS</span></span></a></li><li><a class="level is-mobile" href="#BFS-层序遍历"><span class="level-left"><span class="level-item">3.2.2</span><span class="level-item">BFS(层序遍历)</span></span></a></li><li><a class="level is-mobile" href="#应用"><span class="level-left"><span class="level-item">3.2.3</span><span class="level-item">应用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二叉搜索树"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">二叉搜索树</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#验证二叉搜索树"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">验证二叉搜索树</span></span></a></li><li><a class="level is-mobile" href="#二叉搜索树的插入"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">二叉搜索树的插入</span></span></a></li><li><a class="level is-mobile" href="#二叉搜索树的删除"><span class="level-left"><span class="level-item">3.3.3</span><span class="level-item">二叉搜索树的删除</span></span></a></li></ul></li><li><a class="level is-mobile" href="#平衡二叉树（AVL树）"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">平衡二叉树（AVL树）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#理论理解"><span class="level-left"><span class="level-item">3.4.1</span><span class="level-item">理论理解</span></span></a></li><li><a class="level is-mobile" href="#代码模板"><span class="level-left"><span class="level-item">3.4.2</span><span class="level-item">代码模板</span></span></a></li></ul></li><li><a class="level is-mobile" href="#哈夫曼树"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">哈夫曼树</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#定义-1"><span class="level-left"><span class="level-item">3.5.1</span><span class="level-item">定义</span></span></a></li><li><a class="level is-mobile" href="#构建思路"><span class="level-left"><span class="level-item">3.5.2</span><span class="level-item">构建思路</span></span></a></li><li><a class="level is-mobile" href="#哈夫曼编码"><span class="level-left"><span class="level-item">3.5.3</span><span class="level-item">哈夫曼编码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#m阶B-树"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">m阶B-树</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#性质"><span class="level-left"><span class="level-item">3.6.1</span><span class="level-item">性质</span></span></a></li><li><a class="level is-mobile" href="#区别"><span class="level-left"><span class="level-item">3.6.2</span><span class="level-item">区别</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#查找"><span class="level-left"><span class="level-item">4</span><span class="level-item">查找</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#查找方法评价指标"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">查找方法评价指标</span></span></a></li><li><a class="level is-mobile" href="#查找方法分类"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">查找方法分类</span></span></a></li><li><a class="level is-mobile" href="#二分查找"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">二分查找</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#代码模板-1"><span class="level-left"><span class="level-item">4.3.1</span><span class="level-item">代码模板</span></span></a></li><li><a class="level is-mobile" href="#经典题"><span class="level-left"><span class="level-item">4.3.2</span><span class="level-item">经典题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#哈希表"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">哈希表</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#理论基础-1"><span class="level-left"><span class="level-item">4.4.1</span><span class="level-item">理论基础</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#排序"><span class="level-left"><span class="level-item">5</span><span class="level-item">排序</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#排序算法的稳定性"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">排序算法的稳定性</span></span></a></li><li><a class="level is-mobile" href="#衡量排序方法的标准"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">衡量排序方法的标准</span></span></a></li><li><a class="level is-mobile" href="#插入排序"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">插入排序</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#直接插入排序"><span class="level-left"><span class="level-item">5.3.1</span><span class="level-item">直接插入排序</span></span></a></li><li><a class="level is-mobile" href="#希尔排序"><span class="level-left"><span class="level-item">5.3.2</span><span class="level-item">希尔排序</span></span></a></li></ul></li><li><a class="level is-mobile" href="#交换排序"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">交换排序</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#冒泡排序"><span class="level-left"><span class="level-item">5.4.1</span><span class="level-item">冒泡排序</span></span></a></li><li><a class="level is-mobile" href="#快速排序"><span class="level-left"><span class="level-item">5.4.2</span><span class="level-item">快速排序</span></span></a></li></ul></li><li><a class="level is-mobile" href="#选择排序"><span class="level-left"><span class="level-item">5.5</span><span class="level-item">选择排序</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简单选择排序"><span class="level-left"><span class="level-item">5.5.1</span><span class="level-item">简单选择排序</span></span></a></li><li><a class="level is-mobile" href="#树形选择排序-打擂台"><span class="level-left"><span class="level-item">5.5.2</span><span class="level-item">树形选择排序(打擂台)</span></span></a></li><li><a class="level is-mobile" href="#堆排序"><span class="level-left"><span class="level-item">5.5.3</span><span class="level-item">堆排序</span></span></a></li></ul></li><li><a class="level is-mobile" href="#归并排序"><span class="level-left"><span class="level-item">5.6</span><span class="level-item">归并排序</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路-1"><span class="level-left"><span class="level-item">5.6.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码模板-8"><span class="level-left"><span class="level-item">5.6.2</span><span class="level-item">代码模板</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#图论"><span class="level-left"><span class="level-item">6</span><span class="level-item">图论</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#图的遍历"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">图的遍历</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#深度搜索DFS"><span class="level-left"><span class="level-item">6.1.1</span><span class="level-item">深度搜索DFS</span></span></a></li><li><a class="level is-mobile" href="#广度搜索BFS"><span class="level-left"><span class="level-item">6.1.2</span><span class="level-item">广度搜索BFS</span></span></a></li></ul></li><li><a class="level is-mobile" href="#并查集"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">并查集</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#适用场景"><span class="level-left"><span class="level-item">6.2.1</span><span class="level-item">适用场景</span></span></a></li><li><a class="level is-mobile" href="#思路-4"><span class="level-left"><span class="level-item">6.2.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#模板题-1"><span class="level-left"><span class="level-item">6.2.3</span><span class="level-item">模板题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#最小生成树"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">最小生成树</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#概念"><span class="level-left"><span class="level-item">6.3.1</span><span class="level-item">概念</span></span></a></li><li><a class="level is-mobile" href="#prim算法"><span class="level-left"><span class="level-item">6.3.2</span><span class="level-item">prim算法</span></span></a></li><li><a class="level is-mobile" href="#kruskal算法"><span class="level-left"><span class="level-item">6.3.3</span><span class="level-item">kruskal算法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#拓扑排序"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">拓扑排序</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#前置概念"><span class="level-left"><span class="level-item">6.4.1</span><span class="level-item">前置概念</span></span></a></li><li><a class="level is-mobile" href="#适用场景-1"><span class="level-left"><span class="level-item">6.4.2</span><span class="level-item">适用场景</span></span></a></li><li><a class="level is-mobile" href="#思路-7"><span class="level-left"><span class="level-item">6.4.3</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码模板-14"><span class="level-left"><span class="level-item">6.4.4</span><span class="level-item">代码模板</span></span></a></li><li><a class="level is-mobile" href="#判断是否有环"><span class="level-left"><span class="level-item">6.4.5</span><span class="level-item">判断是否有环</span></span></a></li><li><a class="level is-mobile" href="#时间复杂度"><span class="level-left"><span class="level-item">6.4.6</span><span class="level-item">时间复杂度</span></span></a></li><li><a class="level is-mobile" href="#AOE网络核心定义"><span class="level-left"><span class="level-item">6.4.7</span><span class="level-item">AOE网络核心定义</span></span></a></li><li><a class="level is-mobile" href="#AOE网络关键路径求解"><span class="level-left"><span class="level-item">6.4.8</span><span class="level-item">AOE网络关键路径求解</span></span></a></li></ul></li><li><a class="level is-mobile" href="#最短路径"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">最短路径</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#dijkstra算法"><span class="level-left"><span class="level-item">6.5.1</span><span class="level-item">dijkstra算法</span></span></a></li><li><a class="level is-mobile" href="#Floy算法"><span class="level-left"><span class="level-item">6.5.2</span><span class="level-item">Floy算法</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#结尾"><span class="level-left"><span class="level-item">7</span><span class="level-item">结尾</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://blog.csdn.net/2402_82377921?spm=1000.2115.3001.5343" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/jasper0507" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Markdown/"><span class="level-start"><span class="level-item">Markdown</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E5%AD%A6/"><span class="level-start"><span class="level-item">博客搭建教学</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2026-01-23T10:00:46.000Z">2026-01-23</time></p><p class="title"><a href="/2026/01/23/Markdown%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E8%AF%AD%E6%B3%95/">Markdown快速上手语法</a></p><p class="categories"><a href="/categories/Markdown/">Markdown</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2026-01-23T09:57:17.000Z">2026-01-23</time></p><p class="title"><a href="/2026/01/23/git%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E5%8F%82%E8%80%83/">git新手入门参考</a></p><p class="categories"><a href="/categories/Git/">Git</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2026-01-23T07:45:34.000Z">2026-01-23</time></p><p class="title"><a href="/2026/01/23/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%A9%E7%94%A8Github%E3%80%81Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E8%B6%85%E8%AF%A6%E7%BB%86%E7%89%88/">零基础利用Github、Hexo搭建个人博客(超详细版)</a></p><p class="categories"><a href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E5%AD%A6/">博客搭建教学</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2026-01-23T07:45:34.000Z">2026-01-23</time></p><p class="title"><a href="/2026/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/">数据结构与算法(长期更新)</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2026-01-22T14:00:00.000Z">2026-01-22</time></p><p class="title"><a href="/2026/01/22/%E5%A6%82%E4%BD%95%E6%96%B0%E5%A2%9E%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%EF%BC%9F/">如何新增博客内容？</a></p><p class="categories"><a href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E5%AD%A6/">博客搭建教学</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2026/01/"><span class="level-start"><span class="level-item">January 2026</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Markdown/"><span class="tag">Markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%99%E7%A8%8B/"><span class="tag">教程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/markdown/"><span class="tag">markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Github/"><span class="tag">Github</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js/"><span class="tag">Node.js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="tag">数据结构与算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"><span class="tag">期末复习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"><span class="tag">博客搭建</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"></p><p class="is-size-7">© 2026 jasper0507 用💖发电</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/jasper0507/jasper0507.github.io"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>